<!-- https://www.dataedupt.kr/sub/study/exam1result1.php?exam=93&qNum=1 -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <base href="https://www.dataedupt.kr/">
</head>
<style>
body {width:100%;}
	.container {width:600px;margin:0 auto}	
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;}
	.cp1question1 {padding-bottom:12px;}
img {
  width: 100%;
  height: 100%;
  object-fit: contain; /* 또는 cover */
}
	
</style>
<body>

<div id="body_content">
<!-- container -->
<div class="container clearfix">

	<div class="sg1">
		<div class="w1-1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
		</div>
	</div>



<h3 class="hb1 h3">5장 - 정형 데이터 마이닝</h3>

<!-- cp1question1 -->
<div class="cp1question1">

	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">1.</span>
			<span class="tt1t1">
				다음 중 기업이 보유하고 있는 거래 데이터, 고객 데이터 등과 기타 외부 데이터를 포함하는 모든 데이터를 기반으로 새로운 규칙 등을 발견하고 이를 실제 비즈니스 의사결정 등에 유용한 정보로 활용하고자 하는 일련의 작업을 무엇이라고 하는가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			회귀분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터마이닝					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터웨어하우징					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정지원시스템					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a1" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a1" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			데이터마이닝			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		데이터마이닝은 기업이 보유한 내부 데이터와 외부 데이터를 분석하여 패턴, 규칙, 관계 등을 발견하고 이를 비즈니스 의사결정에 활용하는 일련의 과정이다. 회귀분석은 특정 변수 간의 관계를 설명하거나 예측하기 위한 통계적 방법이고, 데이터웨어하우징은 데이터를 통합하고 관리하는 과정이며, 의사결정지원시스템은 분석 결과를 바탕으로 의사결정을 지원하는 시스템이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터마이닝은 대량의 데이터를 분석하여 유용한 정보를 추출하고 패턴을 발견하는 과정입니다. 이는 기업이 보유한 다양한 데이터를 활용하여 비즈니스 의사결정에 필요한 정보를 얻는 데 중점을 둡니다. <br>
   1. 회귀분석: 회귀분석은 변수 간의 관계를 모델링하여 예측하는 기법으로, 데이터마이닝의 일부 기법일 수 있지만 전체 과정은 아닙니다. 데이터 전체를 분석하여 새로운 규칙을 발견하는 것보다는 특정 변수 간의 관계를 분석하는 데 초점을 맞춥니다.<br>
   2. 데이터마이닝: 데이터마이닝은 대량의 데이터를 분석하여 유용한 정보를 추출하고 패턴을 발견하는 과정으로, 문제에서 설명하는 작업과 일치합니다. 이는 다양한 데이터 소스를 활용하여 비즈니스 의사결정에 필요한 정보를 제공합니다.<br>
   3. 데이터웨어하우징: 데이터웨어하우징은 데이터를 저장하고 관리하는 시스템으로, 데이터마이닝을 위한 기반을 제공하지만 직접적으로 새로운 규칙을 발견하는 작업은 아닙니다. 데이터의 저장과 접근을 용이하게 하는 데 중점을 둡니다.<br>
   4. 의사결정지원시스템: 의사결정지원시스템은 의사결정을 지원하는 시스템으로, 데이터마이닝의 결과를 활용할 수 있지만 직접적으로 데이터를 분석하여 규칙을 발견하는 과정은 아닙니다. 주로 분석된 정보를 활용하여 의사결정을 돕는 역할을 합니다.<br>
			</div>
			<div class="t2">
									#데이터마이닝									# 비즈니스 의사결정									# 데이터 분석							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5998);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">2.</span>
			<span class="tt1t1">
				다음 설명에 맞는 텍스트 마이닝의 작업은 무엇인가?					
					<span class="tt1t1">
						어근에 차이가 있더라도 관련이 있는 단어들을 동일한 어간으로 매핑이 될 수 있도록 정해진 규칙에 따라 단어에서 어간을 분리하여 공통 어간을 가지는 단어를 묶는 작업					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			형태소 분석 (Morphological Analysis)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			어간 추출 (Stemming)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			표제어 추출 (Lemmatization)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			구문 분석 (Syntax Analysis)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a2" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a2" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			어간 추출 (Stemming)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		어간 추출(Stemming)은 단어의 형태가 다르더라도 공통된 의미를 가진 어근을 동일한 형태로 변환하기 위한 작업이다. 형태소 분석은 문장을 형태소 단위로 나누는 작업이고, 표제어 추출은 단어를 사전에 기재된 기본형으로 변환하는 작업이다. 구문 분석은 문장의 문법적 구조를 분석하는 작업으로 어간 추출과는 관련이 없다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				텍스트 마이닝에서 단어를 정규화(normalization)하는 작업은 데이터의 차원을 줄이고 의미적으로 연관된 단어를 묶는 데 유용합니다. 어간 추출은 어근을 찾기 위해 규칙적인 방법으로 단어를 변환하며, 언어적 맥락을 고려하지 않는 특징이 있습니다.<br>
<br>
1. 형태소 분석 (Morphological Analysis)<br>
: 형태소 분석은 문장을 구성하는 단어를 형태소(의미를 가지는 최소 단위)로 분리하는 작업입니다. 이는 단어의 구조를 분석하며, 어간 추출과는 다르게 문법적 정보를 보존하면서 단어를 세부적으로 분석합니다.<br>
<br>
2. 어간 추출 (Stemming)<br>
: 어간 추출은 단어를 구성하는 어근을 분리하고, 단순히 어미를 제거하여 공통된 어근을 가지는 단어로 변환하는 작업입니다. 이는 규칙 기반으로 동작하며, 문법적 맥락을 고려하지 않기 때문에 정확도는 낮을 수 있지만, 텍스트 마이닝에서 자주 사용됩니다. 문제에서 언급된 "정해진 규칙에 따라 단어에서 어간을 분리"한다는 내용과 정확히 일치합니다.<br>
<br>
3. 표제어 추출 (Lemmatization)<br>
: 표제어 추출은 단어의 문법적 맥락과 의미를 고려하여 표제어(사전에 등재된 기본 형태)로 변환하는 작업입니다. 예를 들어, "running"은 "run"으로 변환됩니다. 이는 문법적 맥락까지 고려하므로 어간 추출보다 정확하지만, 문제의 "정해진 규칙에 따라"라는 단순 변환에는 해당하지 않습니다.<br>
<br>
4. 구문 분석 (Syntax Analysis)<br>
: 구문 분석은 문장의 문법적 구조를 분석하여, 주어와 동사 등의 문법 단위 간 관계를 파악하는 작업입니다. 이는 단어를 변환하거나 어근을 추출하는 작업이 아니므로 문제와는 무관합니다.<br>
			</div>
			<div class="t2">
									#어간 추출									# 단어 정규화									# 텍스트 마이닝							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6497);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">3.</span>
			<span class="tt1t1">
				데이터를 이용해 분석한 결과 “샌드위치를 사는 고객의 30%가 탄산수를 함께 산다”와 같은 결과를 얻기 위해 실행되는 데이터 마이닝 분석 방법론은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			군집분석(Clustering) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류분석(Classification Analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			장바구니분석(Market Basket Analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			순차분석(Sequence Analysis)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a3" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a3" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			장바구니분석(Market Basket Analysis) 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		장바구니분석(Market Basket Analysis)은 고객이 구매한 상품들 간의 연관성을 분석하여 "A를 구매한 고객이 B도 구매할 확률"과 같은 패턴을 찾는 데 사용된다. 군집분석은 데이터를 그룹화하는 데 사용되며, 분류분석은 데이터에 레이블을 할당하는 데 초점이 있다. 순차분석은 데이터의 시간적 순서를 고려한 분석 방법으로, 문제와는 부합하지 않는다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 마이닝 분석 방법론 중에서 "장바구니분석(Market Basket Analysis)"은 고객의 구매 패턴을 분석하여 어떤 제품들이 함께 구매되는지를 파악하는 데 사용됩니다. 이는 고객이 특정 제품을 구매할 때 다른 제품도 함께 구매할 확률을 계산하여 마케팅 전략을 수립하는 데 유용합니다.<br>
   <br>
   1. 군집분석(Clustering): 데이터 포인트를 유사한 그룹으로 묶는 방법으로, 서로 다른 고객 그룹을 식별하는 데 사용되며, 특정 제품 간의 연관성을 분석하는 데 적합하지 않습니다.<br>
   <br>
   2. 분류분석(Classification Analysis): 데이터를 미리 정의된 클래스에 할당하는 방법으로, 구매 패턴보다는 특정 속성에 따라 데이터를 분류하는 데 사용됩니다.<br>
   <br>
   3. 장바구니분석(Market Basket Analysis): 고객의 구매 패턴을 분석하여 어떤 제품들이 함께 구매되는지를 파악하는 방법으로, 문제에서 제시된 "샌드위치를 사는 고객의 30%가 탄산수를 함께 산다"와 같은 결과를 얻는 데 적합합니다.<br>
   <br>
   4. 순차분석(Sequence Analysis): 데이터의 시간적 순서를 고려하여 분석하는 방법으로, 특정 이벤트가 발생한 후 어떤 이벤트가 발생하는지를 분석하는 데 사용되며, 동시 구매 패턴 분석과는 다릅니다.<br>
			</div>
			<div class="t2">
									#데이터 마이닝									# 장바구니분석									# 구매 패턴							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6498);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">4.</span>
			<span class="tt1t1">
				다음 데이터 마이닝의  대표적인 기능 중 이질적인 모집단을 세분화하는 기능으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			분류분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모수추정					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a4" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a4" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			군집분석			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		군집분석은 데이터 내의 이질적인 모집단을 동질적인 하위집단으로 나누는 데이터 마이닝 기법이다. 분류분석은 레이블이 지정된 데이터를 학습하여 새로운 데이터를 분류하는 작업이고, 모수추정은 통계적 방법으로 모집단의 모수를 추정하는 기법이다. 연관분석은 데이터 항목들 간의 관계를 찾는 데 사용된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 마이닝의 대표적인 기능 중 이질적인 모집단을 세분화하는 기능은 "군집분석"입니다. 이는 데이터 내의 유사한 특성을 가진 개체들을 그룹으로 묶어주는 기법으로, 서로 다른 그룹 간의 차이를 극대화합니다.<br>
   1. 분류분석: 주어진 데이터에 대한 사전 정의된 클래스에 따라 데이터를 분류하는 기법으로, 새로운 데이터가 어떤 클래스에 속할지를 예측합니다. 이는 이미 정의된 클래스가 필요하므로 이질적인 모집단을 세분화하는 데 적합하지 않습니다.<br>
   2. 모수추정: 모집단의 특성을 추정하기 위해 통계적 방법을 사용하는 기법으로, 데이터의 평균이나 분산과 같은 모수를 추정합니다. 이는 개체를 그룹으로 묶는 기능이 아니므로 세분화와는 관련이 없습니다.<br>
   3. 군집분석: 주어진 데이터에서 유사한 특성을 가진 개체들을 그룹으로 묶어주는 기법으로, 이질적인 모집단을 세분화하는 데 적합합니다.<br>
   4. 연관분석: 데이터 내의 항목 간의 연관성을 찾는 기법으로, 주로 장바구니 분석에 사용됩니다. 이는 개체를 그룹으로 묶는 것이 아니라 항목 간의 관계를 찾는 것이므로 세분화와는 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#데이터 마이닝									# 군집분석									# 세분화									# 이질적인 모집단							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6499);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">5.</span>
			<span class="tt1t1">
				다음 중 k-폴드 교차검증(k-fold Cross Validation)에 대한 설명으로 가정 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			모형이 데이터에 과적합하는 문제를 해결하기 위한 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			K=2인 경우, LOOCV(Leave-One-Out Cross-Va lidat ion)이라고 한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하나의 그룹을 검증용 셋(Validation set)으로, K-1개 그룹을 훈련용 셋(Train set)으로 사용하여 K번 반복 측정하고 결과를 평균낸 값을 최종 평가로 사용한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 셋을 K개의 그룹으로 분할한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a5" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a5" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			K=2인 경우, LOOCV(Leave-One-Out Cross-Va lidat ion)이라고 한다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-폴드 교차검증은 데이터를 K개의 그룹으로 나누고, 각 그룹을 한 번씩 검증 데이터로 사용하는 방법이다. 이 과정은 K번 반복되며, 결과를 평균내어 모형의 성능을 평가한다. LOOCV(Leave-One-Out Cross Validation)는 K=2가 아니라 K=N인 경우를 의미하며, 이는 데이터 셋의 크기가 K와 같아 각 데이터 포인트가 검증 데이터로 한 번씩 사용되는 방식이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				k-폴드 교차검증은 데이터를 K개의 그룹으로 나누어 모델의 일반화 성능을 평가하는 방법입니다. 이는 과적합 문제를 줄이고 데이터의 모든 부분을 훈련과 검증에 활용할 수 있게 합니다.<br>
   1. 모형이 데이터에 과적합하는 문제를 해결하기 위한 방법이다. <br>
      - k-폴드 교차검증은 모형의 일반화 성능을 높이고 과적합을 방지하는 데 효과적입니다. <br>
   2. K=2인 경우, LOOCV(Leave-One-Out Cross-Validation)이라고 한다.<br>
      - K=2는 두 개의 폴드로 나누는 것이며, LOOCV는 K가 데이터 수와 같은 경우로, 각 데이터 포인트를 검증용으로 사용하는 방법입니다. <br>
   3. 하나의 그룹을 검증용 셋(Validation set)으로, K-1개 그룹을 훈련용 셋(Train set)으로 사용하여 K번 반복 측정하고 결과를 평균낸 값을 최종 평가로 사용한다.<br>
      - k-폴드 교차검증의 기본 원리를 설명하고 있으며, 정확한 설명입니다.<br>
   4. 데이터 셋을 K개의 그룹으로 분할한다.<br>
      - k-폴드 교차검증의 핵심 절차 중 하나로, 데이터 셋을 K개의 그룹으로 나누는 것이 맞습니다.<br>
			</div>
			<div class="t2">
									#k-폴드 교차검증									# 과적합									# 데이터 분할									# LOOCV							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6500);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">6.</span>
			<span class="tt1t1">
				Hitters 데이터셋은 메이저리그에서 활약하는 322명의 선수에 대한 타자 기록으로 연봉을 비롯한 20개의 변수를 포함하고 있다. 아래는 모형적합에 앞서 데이터를 Train set과 Test set으로 분할하는 과정이다. 다음 중 아래에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=0c14f664-986c-fa5b-ae61-15742a7de63e.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/0c14f664-986c-fa5b-ae61-15742a7de63e.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			50:50으로 데이터를 분할하고 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			50%의 데이터(Train set)를 사용하여 모형을 학습하고 나머지 50%의 데이터(Test set)로 모형을 평가하기 위한 사전작업이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모형 학습과 평가를 동일한 데이터셋에 진행하면 모형이 과적합 될 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a6" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a6" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		주어진 코드는 Hitters 데이터셋을 Train set과 Test set으로 50:50으로 분할하는 작업을 수행하고 있다. 이는 모형이 과적합(overfitting)되는 것을 방지하기 위한 일반적인 접근 방법이다. <br>
 nrow(Hitters)/2로 데이터셋의 절반을 샘플링하고 나머지를 Test set으로 설정하고 있다. 모형 학습과 평가를 동일한 데이터셋에 진행하면 과적합의 위험이 있으므로 데이터를 분할하는 작업은 적절하다. 일반적으로 Train set에서의 성능은 Test set에서의 성능보다 더 높다. 이는 Train set에서 모형이 학습된 데이터에 최적화되어 있기 때문이며, Test set에서는 학습되지 않은 데이터에 대한 일반화된 성능을 평가하기 때문에 성능이 더 낮아지는 경향이 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분할의 핵심 개념은 모델의 일반화 능력을 평가하기 위해 데이터를 학습용과 평가용으로 나누는 것입니다.  <br>
   1. "50:50으로 데이터를 분할하고 있다."는 설명은 데이터 분할 비율을 정확히 설명하고 있습니다.  <br>
   2. "50%의 데이터(Train set)를 사용하여 모형을 학습하고 나머지 50%의 데이터(Test set)로 모형을 평가하기 위한 사전작업이다."는 데이터 분할의 목적과 과정을 잘 설명하고 있습니다.  <br>
   3. "모형 학습과 평가를 동일한 데이터셋에 진행하면 모형이 과적합 될 수 있다."는 과적합의 위험성을 잘 설명하고 있습니다.  <br>
   4. "일반적으로 Test set에 대한 모형평가 결과가 Train set에 대한 모형평가 결과보다 좋다."는 일반적인 상황과 반대의 설명으로, Test set의 결과가 Train set보다 좋을 수 없습니다.<br>
			</div>
			<div class="t2">
									#데이터 분할									# Train set									# Test set									# 과적합							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5547);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">7.</span>
			<span class="tt1t1">
				아래의 오분류표를 이용하여 계산한 F1-score 값은? (단, 값은 분수로 나타내시오.)							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=5061b4e5-63cb-d0ab-543f-65d1a82d586f.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/5061b4e5-63cb-d0ab-543f-65d1a82d586f.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			6/19 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			3/19 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			2/9 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			6/17 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a7" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a7" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			6/19 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		F1-score를 계산하기 위해 정밀도(Precision)와 재현율(Recall)을 먼저 구한 뒤, 이를 바탕으로 F1-score를 계산한다. 정밀도는 30/(30+60) = 1/3 이며 재현율은 30/(30+70) = 3/10이다. 이 둘의 조화평균을 구하면 2*{(정밀도*재현율)/(정밀도+재현율)} 이므로 정답은 6/19 이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				F1-score 공식은 아래와 같습니다.<br>
F1-score=2⋅ Precision⋅Recall/Precision+Recall<br>
​<br>
Precision과 Recall은 각각 다음과 같이 정의됩니다.<br>
정밀도는 모델이 예측한 Positive 중에서 실제로 Positive인 비율을 뜻하며, 공식은 아래와 같습니다.<br>
Precision(정밀도): Precision= TP/TP+FP<br>
<br>
재현율은 실제로 Positive인 데이터 중에서 모델이 Positive로 올바르게 예측한 비율을 의미하며, 공식은 아래와 같습니다.<br>
Recall(재현율): Recall= TP/TP+FN <br>
<br>
주어진 오분류표를 살펴보면, 아래와 같은 값을 확인할 수 있습니다.<br>
TP (True Positive): 30<br>
FP (False Positive): 60<br>
FN (False Negative): 70<br>
<br>
주어진 값들로 차례대로 계산을 진행해보면 다음과 같이 계산이 됩니다.<br>
1. Precision<br>
Precision= TP/TP+FP = 30/30+60 = 30/90 = 1/3 ​<br>
 <br>
2. Recall<br>
Recall= TP/TP+FN = 30/30+70 = 3/10​<br>
 <br>
3. F1-score <br>
F1-score=2⋅ Precision⋅Recall/Precision+Recall<br>
 <br>
분자:<br>
2⋅1/3⋅3/10 = 2⋅3/30 = 6/30<br>
 <br>
분모:<br>
1/3+3/10 = 10/30+9/30 = 19/30<br>
<br>
F1-score= (6/30)/(19/30) = 6/19<br>
			</div>
			<div class="t2">
									#F1-score									# 정밀도									# 재현율									# 혼동행렬							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6125);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">8.</span>
			<span class="tt1t1">
				이진 분류 모델의 성능을 평가하는 ROC 그래프에서 완벽히 분류한 모형의 좌표로 적합한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			(0, 0) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(0, 1) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(1, 0) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(1, 1)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a8" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a8" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			(0, 1) 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		ROC 그래프에서 좌표 (0, 1)은 완벽한 분류를 나타낸다. 이 좌표는 FPR(False Positive Rate)이 0이고 TPR(True Positive Rate)이 1인 경우로, 모든 양성 데이터를 정확히 분류하면서도 거짓 양성이 없는 이상적인 모델을 의미한다. (0, 0)과 (1, 0)은 낮은 성능을 나타내며, (1, 1)은 무작위 분류와 가까운 결과이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				ROC 그래프에서 완벽히 분류한 모형은 FPR(False Positive Rate)이 0이고 TPR(True Positive Rate)이 1인 지점에 위치합니다. 이는 잘못된 양성 예측이 없고 모든 양성 사례를 정확히 예측한 상태를 의미합니다.<br>
<br>
1. (0, 0)<br>
: 이 좌표는 민감도(TPR)가 0이고, 1-특이도(FPR)도 0임을 나타냅니다. 이는 모델이 모든 사례를 음성으로 예측하여, 양성 사례를 하나도 올바르게 분류하지 못한 경우로, 완벽한 분류 모델과는 거리가 멉니다.<br>
<br>
2. (0, 1)<br>
: 이 좌표는 민감도(TPR)가 1이고, 1-특이도(FPR)가 0인 경우로, 완벽한 분류를 의미합니다. 모든 양성 사례를 정확히 예측하고, 음성 사례도 잘못 분류하지 않은 이상적인 상태를 나타냅니다.<br>
<br>
3. (1, 0)<br>
: 이 좌표는 민감도(TPR)가 0이고, 1-특이도(FPR)가 1임을 나타냅니다. 이는 모델이 모든 사례를 양성으로 예측하여, 음성 사례를 전부 잘못 분류한 경우로, 이 역시 완벽한 분류 모델과는 거리가 먼 모형입니다.<br>
<br>
4. (1, 1)<br>
: 이 좌표는 민감도(TPR)가 1이고, 1-특이도(FPR)도 1임을 나타냅니다. 이는 모든 사례를 양성으로 예측하여, 양성과 음성 모두를 잘못 분류한 상태를 의미하며, 완벽한 분류와는 반대되는 결과입니다.<br>
			</div>
			<div class="t2">
									#ROC 그래프									# 민감도(TPR)									# 1-특이도							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6502);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">9.</span>
			<span class="tt1t1">
				과대적합(Overfitting)은 통계나 기계학습의 모델에서 변수가 너무 많아 모델이 복잡하고 과대하게 학습될 때 주로 발생한다. 다음 중 과대 적합에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			학습 데이터가 모집단의 특성을 충분히 설명하지 못할 때 자주 발생한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			변수가 너무 많아 모형이 복잡할 때 생긴다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과대적합이 발생할 것으로 예상되면 학습을 종료하고 업데이트하는 과정을 반복해 과대적합을 방지할 수 있다. 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a9" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a9" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		과대적합은 모델이 훈련 데이터에 지나치게 최적화되어 테스트 데이터에서 일반화 성능이 떨어지는 현상이다. 과대적합은 주로 훈련 데이터의 특징을 과도하게 학습하거나, 변수의 수가 많아 모델이 지나치게 복잡해질 때 발생한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				과대적합은 모델이 훈련 데이터에 너무 최적화되어 일반화 능력이 떨어지는 현상입니다. <br>
<br>
1. "생성된 모델이 훈련 데이터에 너무 최적화되어 학습하여 테스트 데이터의 작은 변화에 민감하게 반응하는 경우는 발생하지 않는다."는 과대적합의 정의와 반대되는 설명입니다. 과대적합된 모델은 훈련 데이터의 노이즈나 작은 패턴까지 학습하여, 새로운 데이터의 작은 변화에도 예측 결과가 크게 달라지는 민감한 반응을 보입니다. 따라서 이 설명은 과대적합에 대한 설명으로 가장 부적절합니다.<br>
<br>
2. "학습 데이터가 모집단의 특성을 충분히 설명하지 못할 때 자주 발생한다."는 과대적합의 원인 중 하나로, 학습 데이터가 모집단의 특성을 충분히 대표하지 못할 경우, 모델은 훈련 데이터에 나타난 특정 패턴에만 과도하게 적합될 수 있습니다. 이는 모집단의 실제 분포와 다른 모델을 생성하여 새로운 데이터에 대한 성능 저하를 유발하므로 과대적합이 자주 발생하는 원인 중 하나입니다.<br>
<br>
3. "변수가 너무 많아 모형이 복잡할 때 생긴다."는 과대적합의 전형적인 원인으로, 모델에 사용된 변수의 수가 너무 많거나 모델이 지나치게 복잡해지면, 모델은 훈련 데이터의 모든 세부 사항을 학습하려고 합니다. 이 과정에서 불필요한 노이즈까지 학습하게 되어 과대적합이 발생하기 쉽습니다.<br>
<br>
4. "과대적합이 발생할 것으로 예상되면 학습을 종료하고 업데이트하는 과정을 반복해 과대적합을 방지할 수 있다."는 과대적합을 방지하기 위한 일반적인 방법 중 하나입니다. 예를 들어, 검증 데이터셋의 성능이 더 이상 향상되지 않거나 오히려 감소하기 시작하면 학습을 멈추는 것이 과대적합을 막는 효과적인 전략입니다.<br>
<br>
따라서 과대적합에 대한 설명으로 가장 부적절한 것은 1번 입니다.<br>
			</div>
			<div class="t2">
									#과대적합									# 모델 복잡성									# 일반화 능력									# 데이터 특성							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5527);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">10.</span>
			<span class="tt1t1">
				모형의 성능을 평가하기 위해 다양한 방법이 사용되며, 이는 데이터 분석과 기계 학습에서 중요한 단계 중 하나이다. 다음 중 모형의 성능을 평가하기 위한 방법으로 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			홀드 아웃 방법(Hold-out method)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			오분류표(Confusion Matrix) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			엔트로피(Entropy)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			k-fold 교차검증(k-fold Cross validation)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a10" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a10" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			엔트로피(Entropy)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		모형의 성능 평가에는 홀드아웃 방법, 오분류표, k-폴드 교차검증 등 다양한 방법이 사용된다. 홀드아웃 방법은 데이터를 학습용과 검증용으로 나누어 평가하며, 오분류표는 분류 모델의 성능을 평가하는 데 사용된다. k-폴드 교차검증은 데이터를 여러 그룹으로 나누어 평가하는 방법이다. 엔트로피는 데이터의 불확실성을 측정하는 개념으로, 모형 성능 평가 방법이 아니다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				모형의 성능을 평가하기 위해서는 주로 데이터를 나누어 테스트하는 방법이나, 예측 결과를 분석하는 방법이 사용됩니다.  <br>
   <br>
1. 홀드 아웃 방법(Hold-out method)<br>
: 데이터를 학습용과 테스트용으로 나누어 모형의 성능을 평가하는 방법입니다.  <br>
   <br>
2. 오분류표(Confusion Matrix) <br>
: 예측 결과와 실제 결과를 비교하여 모형의 성능을 평가하는 데 사용됩니다.  <br>
   <br>
3. 엔트로피(Entropy)<br>
: 정보 이론에서 불확실성을 측정하는 지표로, 모형의 성능 평가와는 직접적인 관련이 없습니다.  <br>
   <br>
4. k-fold 교차검증(k-fold Cross validation)<br>
: 데이터를 여러 부분으로 나누어 여러 번 학습과 테스트를 반복하여 모형의 성능을 평가하는 방법입니다.<br>
			</div>
			<div class="t2">
									#모형 성능 평가									# 홀드 아웃									# 오분류표									# 교차검증									# 엔트로피							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6503);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">11.</span>
			<span class="tt1t1">
				이익도표(Lift)를 작성함에 있어 평가도구 중 %Captured Response를 표현한 계산식으로 올바른 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			해당집단에서 목표변수의 특정범주 빈도 / 해당집단에서 전체 빈도 x 100 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			전체에서 목표변수의 특정범주 빈도 / 전체 빈도 x 100 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			해당집단의 %Response / BASE line Lift x 100					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a11" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a11" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		이익도표(Lift) 작성에서 %Captured Response는 목표 변수의 특정 범주에 대해 특정 집단이 차지하는 비율을 나타낸다. 이를 계산하기 위해서는 "해당 집단에서 목표변수의 특정범주 빈도"를 "전체 목표변수의 특정범주 빈도"로 나누고, 100을 곱한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
이익도표(Lift Chart)는 모델이 얼마나 효율적으로 긍정적인 반응(예: 구매, 클릭 등)을 포착했는지를 시각적으로 보여주는 도구입니다.<br>
<br>
이 중 % Captured Response는 다음과 같이 계산합니다.<br>
% Captured Response = (해당집단의 목표변수 특정범주 빈도) / (전체 목표변수 특정범주 빈도) × 100<br>
즉, 전체 타깃 반응 중에서 현재 집단이 몇 %나 잡아냈는지를 나타냅니다.<br>
<br>
1. 해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100<br>
: 이 식은 전체 목표 반응 중 해당 집단이 얼마나 포착했는지를 나타내며, %Captured Response의 정의와 정확히 일치합니다. 예를 들어 전체 100명의 구매자 중 상위 20% 집단에서 40명이 구매자라면, 이 집단은 40%의 %Captured Response를 가진 것입니다.<br>
<br>
2. 해당집단에서 목표변수의 특정범주 빈도 / 해당집단에서 전체 빈도 x 100<br>
: 이 식은 해당 집단 내 반응률(Response Rate)을 의미합니다. 즉, 해당 집단 중에서 실제 반응을 보인 비율이지, 전체 반응 중에서 차지하는 비율은 아닙니다.<br>
<br>
3. 전체에서 목표변수의 특정범주 빈도 / 전체 빈도 x 100<br>
: 이 식은 전체 데이터의 기준 반응률(Base Rate)을 의미합니다. Lift나 Captured Response 계산에는 직접적으로 사용되지 않습니다.<br>
<br>
4. 해당집단의 %Response / BASE line Lift x 100<br>
: 이 식은 올바른 수식 구조가 아니며, Captured Response를 계산하는 방식과 무관합니다. Lift 계산에서 %Response와 Baseline을 비교할 수는 있지만, 이 표현은 잘못된 식입니다.<br>
<br>
따라서 정답은 '1. 해당집단에서 목표변수의 특정범주 빈도 / 전체 목표변수의 특정범주 빈도 x 100'입니다.<br>
			</div>
			<div class="t2">
									#%Captured Response									# 목표 변수									# 빈도									# 이익도표(Lift)							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6139);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">12.</span>
			<span class="tt1t1">
				다음 오분류표를 기반으로 계산한 재현율(Recall)은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=2e9b95a2-8bb5-5d78-db7d-0e3c37291237.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/2e9b95a2-8bb5-5d78-db7d-0e3c37291237.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.35					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.4					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.6					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a12" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a12" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			0.4			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		재현율은 TP/(TP+FN) 으로 계산한다. 따라서 정답은 0.4이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				재현율(Recall)은 실제 True로 예측해야 할 값 중에서 모델이 정확히 예측한 비율을 의미하며, 아래와 같이 계산됩니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="0" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">재</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">현</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">율</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c></mjx-mtext></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c2B"></mjx-c><mjx-c class="mjx-c46"></mjx-c><mjx-c class="mjx-c4E"></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>재현율(Recall)</mtext><mo>=</mo><mfrac><mtext>TP</mtext><mtext>TP+FN</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
• TP(True Positive): 실제값이 True이고 예측값도 True인 경우의 수 = 40<br>
• FN(False Negative): 실제값이 True인데 예측값이 False인 경우의 수 = 60<br>
<br>
공식에 주어진 값을 대입하여 계산해보면 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="1" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">재</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">현</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">율</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>재현율</mtext><mo>=</mo><mfrac><mn>40</mn><mrow><mn>40</mn><mo>+</mo><mn>60</mn></mrow></mfrac><mo>=</mo><mfrac><mn>40</mn><mn>100</mn></mfrac><mo>=</mo><mn>0.4</mn></math></mjx-assistive-mml></mjx-container><br>
따라서, 재현율은 '3. 0.4'입니다.<br>
			</div>
			<div class="t2">
									#재현율									# 오분류표									# TP									# FN							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6505);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">13.</span>
			<span class="tt1t1">
				아래는 오분류표를 나타낸 것이다. 다음 중 특이도(Specificiy)는 얼마인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=3760816e-60ff-5bf6-337b-91a763928db3.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/3760816e-60ff-5bf6-337b-91a763928db3.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			3/10					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			4/10					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			13/20					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			7/11					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a13" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a13" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			4/10			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		특이도는 TN/(TN+FP) 으로 계산한다. 따라서 정답은 4/10이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				특이도(Specificity)는 실제로 음성인 데이터 중에서 모델이 음성으로 정확히 예측한 비율을 나타냅니다. 이는 진짜 음성(TN) / (진짜 음성(TN) + 가짜 양성(FP))으로 계산됩니다.<br>
   <br>
   1. 3/10: 이 선택지는 진짜 음성(TN)과 가짜 양성(FP)의 합을 잘못 계산한 것입니다. 특이도를 계산할 때 분모가 잘못되었습니다.<br>
   2. 4/10: 이 선택지는 진짜 음성(TN)과 가짜 양성(FP)의 합을 잘못 계산한 것입니다. 특이도를 계산할 때 분모가 잘못되었습니다.<br>
   3. 13/20: 이 선택지는 진짜 음성(TN)과 가짜 양성(FP)의 합을 올바르게 계산하여 특이도를 정확히 나타냅니다.<br>
   4. 7/11: 이 선택지는 진짜 음성(TN)과 가짜 양성(FP)의 합을 잘못 계산한 것입니다. 특이도를 계산할 때 분모가 잘못되었습니다.<br>
			</div>
			<div class="t2">
									#특이도									# 진짜 음성									# 가짜 양성									# 데이터 분류							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6506);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">14.</span>
			<span class="tt1t1">
				다음 중 반응 변수가 범주형인 경우 예측모형의 주목적으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			연관 분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시뮬레이션					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최적화					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a14" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a14" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			분류			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		반응 변수가 범주형인 경우, 예측 모형의 주목적은 각 관측치가 특정 범주에 속할 확률을 예측하고 이를 기반으로 범주를 할당하는 것이다. 이는 분류(Classification)의 주된 목표로, 로지스틱 회귀, 의사결정나무 등이 대표적이다. 연관 분석은 항목 간의 관계를 탐구하는 데 사용되며, 시뮬레이션은 시스템의 동작을 모사하는 기법이고, 최적화는 주어진 제약조건 내에서 최적의 해를 찾는 과정이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				반응 변수가 범주형인 경우, 예측 모형의 주목적은 데이터를 특정 범주로 분류하는 것입니다. <br>
   1. 연관 분석: 주로 항목 간의 관계를 찾는 데 사용되며, 범주형 변수를 예측하는 데 적합하지 않습니다.<br>
   2. 분류: 범주형 변수를 예측하는 데 사용되며, 데이터를 미리 정의된 범주로 나누는 데 가장 적합합니다.<br>
   3. 시뮬레이션: 시스템의 동작을 모방하는 데 사용되며, 범주형 변수 예측과는 관련이 없습니다.<br>
   4. 최적화: 주어진 조건에서 최적의 해를 찾는 데 사용되며, 범주형 변수 예측과는 직접적인 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#반응 변수									# 범주형									# 분류									# 예측 모형							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6778);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">15.</span>
			<span class="tt1t1">
				아래는 붓꽃 데이터를 활용하여 특정 분류 분석을 수행한 결과이다. 이에 대한 설명으로 가장 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=a4a932a5-3455-4990-0cfe-bcb574b487d9.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/a4a932a5-3455-4990-0cfe-bcb574b487d9.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			iris의 setosa와 versicolor 두 종을 구분하기 위해 이항 로지스틱 회귀 모형으로 분석하였다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Residual deviance는 예측변수 Sepal.Length가 추가된 적합 모형의 이탈도를 나타내며, Null deviance에 비해 자유도 1 기준으로 이탈도가 크게 감소해 관측값에 잘 적합한다고 볼 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Sepal.Length의 회귀계수는 매우 유의미하며, Sepal.Length가 한 단위 증가할 때 versicolor일 오즈가 약 5.14배 증가한다고 해석할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Sepal.Length의 p-값이 거의 0에 가까우므로 이 변수는 setosa와 versicolor를 분류하는 데 매우 유의미한 변수임을 알 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a15" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a15" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Sepal.Length의 회귀계수는 매우 유의미하며, Sepal.Length가 한 단위 증가할 때 versicolor일 오즈가 약 5.14배 증가한다고 해석할 수 있다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		회귀계수의 검정에서 p-값은 거의 0으로 Sepal.Length가 매우 유의한 변수임을 알 수 있으며, 이 값이 양수이므로 Sepal.Length가 한 단위 증가함에 따라 versicolor(Y=2)일 오즈가 증가한다. 오즈 증가율은 exp(5.140)≈170배로, 약 5.14배 증가한다고 해석한 것은 회귀계수 자체를 오즈로 잘못 해석한 것이므로 틀린 설명이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				이항 로지스틱 회귀 분석은 두 범주를 구분하기 위한 통계적 방법입니다. Sepal.Length의 회귀계수가 유의미하다는 것은 p-값이 작다는 것을 의미하며, 오즈 비율이 5.14배라는 해석은 잘못되었습니다. <br>
   1. 이항 로지스틱 회귀 모형을 사용하여 setosa와 versicolor를 구분하는 것은 적절한 방법입니다. 이는 두 범주를 구분하는 데 적합한 분석 방법입니다.<br>
   2. Residual deviance가 Null deviance에 비해 크게 감소했다는 것은 모형이 데이터를 잘 설명한다는 것을 의미합니다. 자유도 1 기준으로 이탈도가 감소했다는 설명은 적절합니다.<br>
   3. Sepal.Length의 회귀계수가 유의미하다는 것은 맞지만, 오즈 비율이 5.14배라는 해석은 잘못되었습니다. 오즈 비율은 회귀계수의 지수 함수로 계산되며, 직접적으로 5.14배라는 수치를 제공하지 않습니다.<br>
   4. Sepal.Length의 p-값이 거의 0에 가까운 것은 이 변수가 매우 유의미하다는 것을 나타냅니다. 이는 setosa와 versicolor를 분류하는 데 중요한 변수임을 의미합니다.<br>
			</div>
			<div class="t2">
									#이항 로지스틱 회귀									# 회귀계수									# 오즈 비율									# p-값							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6099);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">16.</span>
			<span class="tt1t1">
				다음 설명에 맞는 (ㄱ)과 (ㄴ)에 들어갈 용어는 무엇인가?					
					<span class="tt1t1">
						로지스틱 회귀 분석에서 회귀계수가 설명변수가 한 단위 증가할 때, 종속변수가 1일 확률에 대한 (ㄱ)이/가 (ㄴ) 배 만큼 변화(증가 또는 감소)한다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			(ㄱ) : 오즈 (Odds) / (ㄴ) : b (여기서, b는 설명변수의 회귀계수)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(ㄱ) : 오즈비 (Odds Ratio) / (ㄴ) : exp(b) (여기서, b는 설명변수의 회귀계수)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(ㄱ) : 오즈 (Odds) / (ㄴ) : exp(b) (여기서, b는 설명변수의 회귀계수)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(ㄱ) : 오즈비 (Odds Ratio) / (ㄴ) : b (여기서, b는 설명변수의 회귀계수)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a16" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a16" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			(ㄱ) : 오즈 (Odds) / (ㄴ) : exp(b) (여기서, b는 설명변수의 회귀계수)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		로지스틱 회귀 분석에서 회귀계수(b)는 설명변수가 한 단위 증가할 때 종속변수의 로그 오즈가 얼마나 증가하는지를 나타낸다. 이를 지수화한 값 exp(b)는 오즈비(Odds Ratio)로, 종속변수가 1일 확률에 대해 오즈가 몇 배 만큼 변화(증가 또는 감소) 하는지를 표현한다. 따라서 (ㄱ)은 오즈(Odds), (ㄴ)은 exp(b)이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				로지스틱 회귀 분석에서 회귀계수 b는 설명변수가 한 단위 증가할 때 종속변수의 로그 오즈(log-odds)에 미치는 영향을 나타냅니다. 이를 지수화한 값인 exp(b)는 독립변수가 종속변수의 오즈(Odds)에 미치는 영향을 상대적인 비율로 표현하며, 이 값을 오즈비(Odds Ratio)라고 합니다.<br>
<br>
1. (ㄱ): 오즈(Odds), (ㄴ): b<br>
: 오즈(Odds)는 특정 사건이 발생할 확률과 발생하지 않을 확률의 비율을 나타냅니다. 그러나 b는 로그 오즈에 미치는 영향을 나타낼 뿐 오즈를 직접적으로 설명하지 않습니다. 따라서 이 조합은 문제의 조건과 부합하지 않습니다. 오즈(Odds)는 지수화된 회귀계수 exp(b)와 연결되어야 하므로 이 선택지는 틀렸습니다.<br>
<br>
2. (ㄱ): 오즈비(Odds Ratio), (ㄴ): exp(b)<br>
: 오즈비(Odds Ratio)는 회귀계수 b를 지수화한 값 exp(b)로 계산되는 것은 맞습니다. 그러나 문제에서 오즈(Odds)의 변화를 물었으므로 (ㄱ)은 오즈(Odds)가 되어야 합니다. 이 선택지는 조건에 부합하지 않으므로 부적절합니다.<br>
<br>
3. (ㄱ): 오즈(Odds), (ㄴ): exp(b)<br>
: 오즈(Odds)는 사건이 발생할 확률과 발생하지 않을 확률의 비율을 나타내며, exp(b)는 독립변수가 한 단위 증가할 때 오즈가 몇 배 변화하는지를 나타냅니다. 문제의 조건과 정확히 부합하므로 이 선택지가 옳습니다.<br>
<br>
4. (ㄱ): 오즈비(Odds Ratio), (ㄴ): b<br>
: 회귀계수 b는 로그 오즈(log-odds)에 미치는 영향을 나타냅니다. b를 지수화한 값인 exp(b)가 오즈비(Odds Ratio)를 나타내므로 이 선택지는 틀렸습니다. 오즈비와 b는 직접적으로 연결되지 않으며, 오즈비는 항상 지수화된 값으로 표현됩니다.<br>
			</div>
			<div class="t2">
									#오즈(Odds)									# 오즈비(Odds Ratio)									# 로지스틱 회귀분석									# 설명변수의 회귀계수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6509);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">17.</span>
			<span class="tt1t1">
				Default 데이터셋은 10,000명의 신용카드 고객에 대한 연체여부(default:1-default,0-not default), 카드대금 납입 후 남은 평균 카드잔고(balance), 연봉(income)을 포함하고 있다. 아래는 연체 가능성을 95% 신뢰수준으로 모형화한 결과이다. 다음 설명이 부적절한 것은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=82aef411-c99a-b6f9-cace-b6e300162784.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/82aef411-c99a-b6f9-cace-b6e300162784.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀모형의 적합 결과이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			balance는 default를 설명하는데 통계적으로 유의하다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			balance가 높을수록 default 가능성이 높다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			income이 높을수록 default 가능성이 낮다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a17" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a17" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			income이 높을수록 default 가능성이 낮다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		주어진 출력은 로지스틱 회귀 분석 결과로, 종속변수는 default(연체 여부)이며, 독립변수는 balance와 income이다. balance의 계수는 5.647e-03이며, p-value가 매우 작아(2e-16) 통계적으로 유의하다. 따라서 balance는 default를 설명하는데 통계적으로 유의하다. balance의 계수가 양수이므로, balance가 높을수록 default 가능성이 증가한다는 해석도 적절하다. 그러나 income의 계수는 2.081e-05로 양수이며, 이는 income이 증가할수록 default 가능성이 증가한다는 것을 의미한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				income이 높을수록 default 가능성이 낮다는 설명은 일반적인 가정일 수 있지만, 데이터에 따라 다를 수 있습니다. 따라서 이 설명은 부적절할 수 있습니다.<br>
			</div>
			<div class="t2">
									#로지스틱 회귀모형									# 통계적 유의성									# 변수의 방향성							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6510);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">18.</span>
			<span class="tt1t1">
				다음 중 로지스틱 회귀모형에서 설명 변수가 한 개인 경우 해당 회귀 계수의 부호가 0보다 작을 때 표현되는 그래프의 형태로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			S자 그래프					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			양의 선형 그래프					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			역 S자 그래프					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			음의 선형 그래프					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a18" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a18" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			역 S자 그래프			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		로지스틱 회귀모형에서 설명 변수가 한 개인 경우, 회귀 계수의 부호가 음수면 그래프는 역 S자 형태를 나타낸다. 이는 설명변수가 증가함에 따라 종속 변수의 성공 확률이 감소하는 관계를 의미한다. 양의 선형 그래프나 음의 선형 그래프는 선형 회귀에서 나타나는 형태이며, S자 그래프는 양의 회귀 계수에서 나타나는 로지스틱 회귀의 일반적인 형태이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				로지스틱 회귀모형에서 설명 변수가 한 개인 경우, 회귀 계수의 부호가 0보다 작으면 그래프는 역 S자 형태를 나타냅니다. 이는 설명 변수가 증가할수록 종속 변수의 확률이 감소하는 것을 의미합니다.<br>
1. S자 그래프: 로지스틱 회귀모형에서 회귀 계수가 양수일 때 나타나는 그래프 형태입니다. 설명 변수가 증가할수록 종속 변수의 확률이 증가하는 경우를 나타냅니다.<br>
2. 양의 선형 그래프: 선형 회귀에서 설명 변수와 종속 변수 간의 양의 선형 관계를 나타내는 그래프입니다. 로지스틱 회귀모형의 특성과는 맞지 않습니다.<br>
3. 역 S자 그래프: 회귀 계수가 음수일 때 로지스틱 회귀모형에서 나타나는 그래프 형태입니다. 설명 변수가 증가할수록 종속 변수의 확률이 감소하는 경우를 나타냅니다.<br>
4. 음의 선형 그래프: 선형 회귀에서 설명 변수와 종속 변수 간의 음의 선형 관계를 나타내는 그래프입니다. 로지스틱 회귀모형의 특성과는 맞지 않습니다.<br>
			</div>
			<div class="t2">
									#로지스틱 회귀									# 회귀 계수									# 그래프 형태									# 설명 변수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5548);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">19.</span>
			<span class="tt1t1">
				두 정수 x1과 x2는 다음과 같은 기본조건을 가진다. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="2" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c7B"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c7C"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c2264"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c2264"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c7D"></mjx-c></mjx-mtext></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>{ x1 | 6 ≤ x1 ≤ 8 }</mtext></math></mjx-assistive-mml></mjx-container> <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="3" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c7B"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c7C"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c2264"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c78"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c2264"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c20"></mjx-c><mjx-c class="mjx-c7D"></mjx-c></mjx-mtext></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>{ x2 | 2 ≤ x2 ≤ 5 }</mtext></math></mjx-assistive-mml></mjx-container> x1과 x2의 최종 값은 아래와 같은 분류체계를 따른다고 할 때, E 노드에 해당하는 x1과 x2의 값으로 각각 x1 = 8, x2 = 2가 도출되기 위한 아래의 (A)와 (B)의 값은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=0935b50d-bbdc-debc-93be-2aeca6cf993f.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/0935b50d-bbdc-debc-93be-2aeca6cf993f.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			A=3, B=8					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A=2.5, B=7.5					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A=4.5, B=6					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A=5, B=7					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a19" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a19" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			A=3, B=8			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		주어진 조건을 분류체계에 적용하고 x1=8,x2=2가 Node E에 도달하기 위한 A와 B 값을 분석한다. 1. x2&lt;A를 만족해야 한다. 2.x1&gt;=B를 만족해야 한다. 이 두 조건을 만족하는 선택지는 A=3, B=8 이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				E 노드에 도달하기 위한 조건은 아래와 같습니다.<br>
• x2 &lt; A<br>
: Node A에서 왼쪽 자식 노드로 이동하기 위한 조건으로, x2는 A보다 작아야 합니다.<br>
• x1 ≥ B<br>
: Node B에서 오른쪽 자식 노드로 이동하기 위한 조건으로, x1은 B보다 크거나 같아야 합니다.<br>
<br>
주어진 값 x1 = 8, x2 = 2를 조건에 대입해 보면,<br>
2 &lt; A, 8 ≥ B 를 만족해야 한다는 것을 알 수 있습니다.<br>
<br>
1. A=3, B=8<br>
: A=3 &gt; 2, B=8 ≥ 8로, 두 조건을 정확히 만족하며, 각각의 임계값에 가장 근접한 기준값을 제시하고 있어 분류 기준으로 가장 명확하고 간결한 선택지입니다.<br>
<br>
2. A=2.5, B=7.5<br>
: A=2.5 &gt; 2, B=7.5 ≤ 8로, 조건은 만족하지만, 분기 기준으로서의 직관성과 명확성을 고려할 때 정수 기준값이 더 적절하다고 볼 수 있습니다.<br>
<br>
3. A=4.5, B=6<br>
: A=4.5 &gt; 2, B=6 ≤ 8로, 조건은 충족되지만, 분기 기준이 너무 느슨해져서 정확한 분류 경계로서의 의미가 희미해질 수 있습니다. 따라서 ①번처럼 임계값에 가까운 값보다는 덜 적합합니다.<br>
<br>
4. A=5, B=7<br>
: A=5 &gt; 2, B=7 ≤ 8로, 조건은 만족하지만, ①번에 비해 기준값이 경계에서 멀어 상대적으로 덜 직관적입니다.<br>
<br>
모든 보기에서 조건은 충족되지만, ①번은 각각의 조건을 가장 단순하고 정확하게 경계값에서 만족시키는 선택지입니다.<br>
분류 기준으로 사용되는 값은 가능한 한 명확하고 일관되게 설정하는 것이 바람직하므로, ‘A = 3, B = 8’이 문제의 의도에 가장 부합하는 가장 적절한 기준값 조합이라 할 수 있습니다.<br>
<br>
따라서 정답은 '1. A=3, B=8'입니다.<br>
			</div>
			<div class="t2">
									#결정 트리									# 조건 분류									# 리프 노드									# 조건 최적화							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6515);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">20.</span>
			<span class="tt1t1">
				아래는 kyphosis라는 자료를 이용하여 의사결정나무 분석을 수행한 결과이다. 결과에 대한 해석으로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=e946ea8b-1ffb-fe3c-e913-5ce6468ed5c7.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/e946ea8b-1ffb-fe3c-e913-5ce6468ed5c7.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			뿌리마디의 자료는 Start 변수를 이용하여 분리했을 때 present와 absent를 가장 잘 분리시킬 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위 결과의 단계에서 멈추지 않고 추가로 가지를 생성한다면, 새로운 자료에 대한 예측력은 떨어질 수도 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이 자료에서 Start 변수의 값이 14.5이상인 관찰치는 Kyphosis 변수의 값이 모두 absent 였을 것이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a20" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a20" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		의사결정나무에서 불순도(impurity)는 분할 후 각 노드의 순도가 증가하도록 설계된다. 즉, 뿌리마디(root node)에서 분할이 이루어질수록 각 자식 노드에서 불순도는 감소하는 것이 일반적이다. 뿌리마디의 자료는 Start 변수를 이용하여 분리했으며, 이는 가장 좋은 분리 기준(불순도 감소를 최대로 만드는 변수)으로 선택되었다. 가지치기 없이 계속적으로 가지를 생성하면 모형이 과적합(overfitting)되어 새로운 자료에 대한 예측력이 감소한다. Start 변수의 값이 14.5 이상인 경우, 해당 관찰치에서는 Kyphosis 값이 모두 absent였음을 출력에서 확인할 수 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정나무에서 뿌리마디에서 아래로 내려갈수록 각 마디의 불순도는 점차 감소하는 것이 일반적입니다. 이는 의사결정나무가 각 마디에서 데이터를 분리하여 불순도를 줄이는 방향으로 학습하기 때문입니다.<br>
   1. 뿌리마디에서 아래로 내려갈수록 불순도는 감소해야 합니다. 의사결정나무는 데이터를 분리하여 불순도를 줄이는 방향으로 학습하는데, 이 선택지는 그 반대의 설명을 하고 있습니다.<br>
   2. 뿌리마디의 자료는 Start 변수를 이용하여 가장 잘 분리된다는 설명은 일반적인 의사결정나무의 특성을 반영합니다. 이는 뿌리마디에서 가장 큰 정보 이득을 주는 변수를 선택하기 때문입니다.<br>
   3. 추가로 가지를 생성하면 과적합이 발생할 수 있어 새로운 자료에 대한 예측력이 떨어질 수 있습니다. 이는 의사결정나무의 과적합 문제를 설명하는 적절한 선택지입니다.<br>
   4. Start 변수의 값이 14.5 이상인 관찰치가 모두 absent라는 설명은 특정 조건에서의 결과를 설명하는 것으로, 의사결정나무의 결과 해석에 적절합니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 불순도									# 과적합									# 데이터 분리							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6516);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">21.</span>
			<span class="tt1t1">
				다음 중 의사결정나무 모형의 학습 방법에 대한 설명으로 부족한 것은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			이익도표 또는 검정용 자료에 의한 교차타당성 등을 이용해 의사결정나무를 평가한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 마디에서의 최적 분리규칙은 분리변수의 선택과 분리기준에 의해 결정된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가지치기는 분류 오류를 크게 할 위험이 높거나 부적절한 규칙을 가지고 있는 가지를 제거하는 작업이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a21" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a21" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			분리 변수의 P차원 공간에 대한 현재 분할은 이전 분할에 영향을 받지 않고 이루어지며, 공간을 분할하는 모든 직사각형들이 가능한 순수하게 되도록 만든다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		의사결정나무 모형은 데이터를 여러 기준에 따라 반복적으로 분할하여 예측하거나 분류하는 데 사용된다. 분리 변수의 선택은 이전 분할의 영향을 받으며, 각 단계에서 최적의 분리 규칙을 통해 분할이 이루어진다. 나머지 설명들은 이익도표나 교차타당성 평가, 가지치기의 역할 등 의사결정나무의 특징을 적절히 설명하고 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정나무 모형은 데이터를 분할하여 예측을 수행하는 기법으로, 각 단계에서 최적의 분리 기준을 선택하여 나무를 성장시킵니다. <br>
   1. 이익도표나 교차타당성을 통해 의사결정나무의 성능을 평가하는 것은 일반적인 방법입니다. 이는 모델의 일반화 능력을 확인하는 데 유용합니다.<br>
   2. 의사결정나무의 분할은 이전 분할에 영향을 받을 수 있으며, 순수하게 만드는 것이 목표이지만 항상 가능한 것은 아닙니다. 이 설명은 의사결정나무의 학습 방법에 대한 이해가 부족합니다.<br>
   3. 각 마디에서 최적의 분리규칙을 결정하는 것은 의사결정나무의 핵심 과정 중 하나입니다. 이는 분리변수와 분리기준을 선택하여 이루어집니다.<br>
   4. 가지치기는 과적합을 방지하기 위해 불필요하거나 오류가 큰 가지를 제거하는 과정입니다. 이는 모델의 일반화 능력을 향상시키는 데 중요합니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 학습 방법									# 교차타당성									# 가지치기							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6151);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">22.</span>
			<span class="tt1t1">
				다음 설명에 맞는 지표는 무엇인가?					
					<span class="tt1t1">
						불순도를 측정하는 지표로, 노드의 불순도를 나타내는 값이다. 클수록 이질적이고 순수도가 낮다고 볼 수 있으며, CART에서 목적변수가 범주형일 경우 사용한다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지니지수 (Gini Index)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			엔트로피 (Entropy)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			평균제곱오차 (Mean Squared Error)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			크로스 엔트로피 (Cross Entropy)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a22" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a22" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			지니지수 (Gini Index)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		지니지수(Gini Index)는 범주형 목표 변수의 불순도를 측정하는 지표로, 값이 클수록 데이터가 더 이질적임을 나타낸다. 이는 CART(분류 및 회귀 나무) 알고리즘에서 노드의 분할 기준으로 사용된다. 엔트로피도 불순도를 측정하지만, 주로 정보 이득을 계산할 때 사용된다. 평균제곱오차는 연속형 목표 변수의 예측 오차를 측정하는 지표이며, 크로스 엔트로피는 주로 딥러닝에서 사용되는 손실 함수이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				불순도를 측정하는 지표로, 노드의 불순도를 나타내는 값은 지니지수입니다.  이는 CART(Classification and Regression Tree)에서 범주형 변수의 불순도를 측정하는 데 사용되며, 값이 클수록 이질적이고 순수도가 낮음을 의미합니다.  <br>
   <br>
1. 지니지수 (Gini Index)<br>
: 지니지수는 불순도를 측정하는 지표로, 각 클래스의 비율을 이용해 계산됩니다. 값이 작을수록 데이터가 더 순수하며, 주로 CART에서 목적변수가 범주형일 때 사용됩니다.<br>
   <br>
2. 엔트로피 (Entropy)<br>
: 엔트로피 역시 불순도를 측정하는 지표로 사용되지만, 지문에서는 CART 알고리즘과 관련된 지니지수를 설명하고 있습니다. 엔트로피는 주로 ID3 또는 C4.5 알고리즘에서 사용됩니다.<br>
   <br>
3. 평균제곱오차 (Mean Squared Error)<br>
: 평균제곱오차는 회귀 분석에서 사용되는 지표로, 예측값과 실제값의 차이를 제곱하여 평균을 계산합니다. 범주형 변수의 불순도와는 관련이 없습니다.<br>
   <br>
4. 크로스 엔트로피 (Cross Entropy)<br>
: 크로스 엔트로피는 주로 분류 문제에서 확률 기반 모델(예: 로지스틱 회귀, 신경망)에서 사용되며, 지문에서 설명한 불순도 측정과는 거리가 있습니다.<br>
			</div>
			<div class="t2">
									#불순도									# 지니지수									# CART									# 범주형 변수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6517);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">23.</span>
			<span class="tt1t1">
				아래 집단에 대해 지니지수(Gini Index)는 얼마인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=485e6eaf-b8d7-85e4-a28f-97f7b4fd2422.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/485e6eaf-b8d7-85e4-a28f-97f7b4fd2422.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			1					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			1/2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			12/25					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a23" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a23" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			12/25			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		집단에 총 5개의 항목이 있으며, 3개는 원(circle), 2개는 다이아몬드(diamond) 모양이다. 원의 비율은 3/5이고 다이아몬드의 비율은 2/5이므로 각 비율의 제곱의 합을 구한 뒤 1에서 빼면 지니지수가 된다. 따라서 12/25 이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				지니지수(Gini Index)는 데이터의 불순도를 측정하는 지표로, 값이 낮을수록 데이터가 더 순수함을 나타냅니다. 주어진 집단의 지니지수를 계산하면 12/25가 됩니다. <br>
   1. 지니지수는 0과 1 사이의 값을 가지며, 1은 완전한 불순도를 의미합니다. 1은 지니지수로서 부적절한 값입니다.<br>
   2. 지니지수는 0과 1 사이의 값을 가지며, 2는 범위를 벗어난 값입니다.<br>
   3. 1/2는 지니지수로 가능한 값이지만, 주어진 집단의 실제 계산 결과와 일치하지 않습니다.<br>
   4. 12/25는 주어진 집단의 지니지수를 정확히 계산한 결과입니다.<br>
			</div>
			<div class="t2">
									#지니지수									# 불순도									# 데이터 분석									# 의사결정나무							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6132);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">24.</span>
			<span class="tt1t1">
				다음 중 앙상블 기법에 대한 설명으로 적절한 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			앙상블 기법에서 모델들이 서로 강하게 연관될수록 성능이 향상된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			앙상블 기법은 분산을 유지함으로써 예측 정확도를 높이는 데 효과적이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대표적인 앙상블 기법은 배깅, 부스팅이 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트는 앙상블 기법 중 비지도학습 기반으로 작동한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a24" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a24" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			대표적인 앙상블 기법은 배깅, 부스팅이 있다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		앙상블 기법은 여러 예측 모형을 결합하여 예측 성능을 향상시키는 방법으로, 대표적인 기법으로 배깅(Bagging)과 부스팅(Boosting)이 있다. 모델 간의 강한 연관성은 오히려 과적합을 유발할 수 있으므로, 앙상블 기법에서는 모델 간 독립성을 유지하는 것이 중요하다. 랜덤 포레스트는 앙상블 기법의 일종이지만, 비지도학습이 아닌 교사학습에 기반한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				앙상블 기법(Ensemble Method)은 여러 개의 모델을 결합하여 성능을 향상시키는 기법입니다. 일반적으로 약한 학습기(Weak Learner) 여러 개를 결합하여 강한 학습기(Strong Learner)를 만드는 방식입니다. 주요 방식으로 배깅(Bagging)과 부스팅(Boosting)이 있으며, 랜덤 포레스트(Random Forest)는 배깅의 대표적인 예시입니다.<br>
<br>
1. 앙상블 기법에서 모델들이 서로 강하게 연관될수록 성능이 향상된다.<br>
: 앙상블 기법의 핵심은 여러 개의 독립적인 모델을 결합하여 예측력을 높이는 것입니다. 모델 간의 상관관계가 강할수록 비슷한 예측 결과를 내므로, 오히려 성능 향상이 제한됩니다. 따라서 모델들이 서로 독립적일수록(즉, 상관관계가 낮을수록) 성능이 향상됩니다.<br>
<br>
2. 앙상블 기법은 분산을 유지함으로써 예측 정확도를 높이는 데 효과적이다.<br>
: 앙상블 기법은 분산(Variance)을 줄이는 것이 핵심입니다. 특히 배깅(Bagging)은 모델의 분산을 낮춰 과적합을 방지하는 역할을 합니다. 반면, 부스팅(Boosting)은 여러 모델을 순차적으로 학습하면서 편향(Bias)을 줄이는 방식입니다. 분산을 유지하는 것이 아니라, 분산을 줄임으로써 예측 성능을 개선하는 것이 목표입니다.<br>
<br>
3. 대표적인 앙상블 기법은 배깅, 부스팅이 있다.<br>
: 앙상블 기법에는 대표적으로 배깅(Bagging)과 부스팅(Boosting)이 있습니다. 배깅은 데이터 샘플을 랜덤하게 선택하여 여러 모델을 독립적으로 학습시키고 결과를 평균화하는 방식이며, 부스팅은 이전 모델이 만든 오류를 보완하는 방식으로 학습을 진행합니다.<br>
<br>
4. 랜덤 포레스트는 앙상블 기법 중 비지도학습 기반으로 작동한다.<br>
: 랜덤 포레스트(Random Forest)는 배깅 기반의 대표적인 앙상블 모델이지만, 지도학습(Supervised Learning) 알고리즘입니다. 주로 분류(Classification)와 회귀(Regression) 문제에서 사용되며, 다수의 결정 트리(Decision Tree)를 결합하여 예측 성능을 향상시킵니다.<br>
			</div>
			<div class="t2">
									#앙상블 기법									# 배깅									# 부스팅									# 랜덤 포레스트							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(7220);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">25.</span>
			<span class="tt1t1">
				아래에서 설명하는 앙상블 모형은 무엇인가?					
					<span class="tt1t1">
						원 데이터 집합으로부터 크기가 같은 표본을 여러 번 단순 임의 복원추출하여 각 표본에 대해 분류기를 생성 한 후 그 결과를 앙상블하는 방법					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			배깅(bagging)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			에이다부스트(AdaBoost)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스태킹(Stacking)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(random forest) 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a25" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a25" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			배깅(bagging)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		배깅(Bagging)은 원 데이터에서 복원추출한 여러 표본을 생성하고, 각 표본에 대해 독립적인 분류기를 학습한 뒤 이를 결합하여 최종 예측을 수행하는 앙상블 방법이다. 에이다부스트(AdaBoost)는 각 반복에서 잘못 예측한 데이터에 가중치를 부여하는 방식이며, 스태킹(Stacking)은 서로 다른 예측 모형의 결과를 결합하는 방식이다. 랜덤 포레스트는 배깅에 무작위성을 추가한 기법이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				앙상블 모형 중 배깅(bagging)은 원 데이터 집합에서 여러 번 복원추출하여 각각의 표본에 대해 분류기를 생성하고 그 결과를 결합하는 방법입니다. 이는 데이터의 다양성을 높여 예측 성능을 향상시키는 데 목적이 있습니다.<br>
<br>
1. 배깅(bagging)<br>
: 배깅은 "복원추출"을 통해 원 데이터에서 크기가 동일한 여러 표본 데이터를 생성하고, 각 표본에 대해 개별 모델(예: 의사결정나무)을 학습시킨 후 결과를 앙상블하는 방법입니다. 주로 과적합(overfitting)을 방지하고 모델의 안정성을 높이는 데 사용됩니다.<br>
<br>
2. 에이다부스트(AdaBoost)<br>
: 에이다부스트는 가중치 기반 부스팅(Boosting) 기법으로, 이전 모델이 잘못 예측한 샘플에 가중치를 부여하여 다음 모델이 이를 개선하도록 학습을 진행합니다. 에이다부스트는 배깅과 달리 "복원추출" 대신 가중치를 재조정하며 샘플의 중요도를 반영합니다.<br>
<br>
3. 스태킹(Stacking)<br>
: 스태킹은 서로 다른 종류의 모델(예: 결정나무, 로지스틱 회귀, SVM)을 학습시키고, 그 결과를 기반으로 최종 메타 모델을 학습시켜 결과를 결합합니다. 복원추출을 사용하지 않으며, 주로 서로 다른 모델의 강점을 결합하여 성능을 극대화하는 데 초점을 둡니다.   <br>
<br>
4. 랜덤포레스트(random forest)<br>
: 랜덤포레스트는 배깅을 기반으로 하지만, 특성을 무작위로 선택하는 추가적인 랜덤성을 포함합니다. 문제에서 언급된 "복원추출과 분류기 생성"만으로는 배깅의 기본 구조를 설명하고 있어, 랜덤포레스트의 고유 특징이 포함되지 않으므로 정답이 될 수 없습니다.<br>
			</div>
			<div class="t2">
									#앙상블 모형									# 배깅									# 복원추출									# 랜덤포레스트							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6088);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">26.</span>
			<span class="tt1t1">
				앙상블 모형은 여러 예측 모형을 결합하여 성능을 개선하는 기법이다. 다음 중 앙상블 모형에 대한 설명으로 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			배깅은 주어진 자료로 여러 붓스트랩 자료를 생성하고 각 자료에서 생성된 예측 모형을 결합하여 최종 모형을 만든다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부스팅은 배깅과 유사하며, 각 자료에 동일한 가중치를 부여한 후 여러 예측 모형을 결합하는 방식이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트(Random Forest)는 배깅에 무작위성을 추가하여 여러 약한 학습기를 결합하여 강력한 학습기를 만든다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			앙상블 모형은 데이터를 학습하여 예측을 수행하며, 교사학습법(Supervised Learning)의 한 방법이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a26" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a26" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			부스팅은 배깅과 유사하며, 각 자료에 동일한 가중치를 부여한 후 여러 예측 모형을 결합하는 방식이다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		부스팅은 배깅과는 달리 이전 단계에서 잘못 예측된 데이터에 더 높은 가중치를 부여하고, 이후 단계에서 이를 수정하는 방식으로 동작한다. 배깅, 랜덤 포레스트, 그리고 앙상블 모형에 대한 나머지 설명들은 모두 적절하다. 부스팅은 데이터에 차별적인 가중치를 부여하여 성능을 개선한다는 점에서 배깅과 차이가 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				부스팅은 배깅과 달리 각 단계에서 이전 단계의 오류를 보완하는 방식으로 학습합니다. 따라서 부스팅은 동일한 가중치를 부여하지 않고, 각 단계에서 가중치를 조정하여 학습합니다.<br>
<br>
1. 배깅은 주어진 자료로 여러 붓스트랩 자료를 생성하고 각 자료에서 생성된 예측 모형을 결합하여 최종 모형을 만든다.<br>
: 배깅(Bagging, Bootstrap Aggregating)은 데이터를 여러 번 샘플링하여 각 샘플로 개별 예측 모형을 학습한 후, 이들의 예측을 평균(회귀)하거나 다수결(분류)을 통해 결합하는 기법입니다. 이는 분산을 줄이고 안정적인 예측 결과를 제공하므로, 적절한 설명입니다. <br>
<br>
2. 부스팅은 배깅과 유사하며, 각 자료에 동일한 가중치를 부여한 후 여러 예측 모형을 결합하는 방식이다.<br>
: 부스팅(Boosting)은 배깅과 달리 각 모형이 이전 모형의 오류를 보완하도록 학습합니다. 초기에는 동일한 가중치를 부여하지만, 학습이 진행될수록 잘못 예측된 데이터에 더 높은 가중치를 부여합니다. 이로 인해 각 모형이 점진적으로 더 나은 성능을 발휘하도록 학습합니다. 따라서 "동일한 가중치를 부여"한다는 설명은 부스팅의 핵심 특성과 맞지 않으며 부적절합니다.<br>
<br>
3. 랜덤 포레스트(Random Forest)는 배깅에 무작위성을 추가하여 여러 약한 학습기를 결합하여 강력한 학습기를 만든다.<br>
: 랜덤 포레스트는 배깅을 기반으로 하되, 개별 결정 트리를 학습할 때 사용되는 변수 중 일부를 무작위로 선택하여 분할함으로써 다변량 데이터에서 상관성을 줄이고 다양성을 증가시킵니다. 이 과정은 과적합을 방지하며 모델 성능을 향상시킵니다. <br>
<br>
4. 앙상블 모형은 데이터를 학습하여 예측을 수행하며, 교사학습법(Supervised Learning)의 한 방법이다.<br>
: 앙상블 모형은 주로 교사학습(Supervised Learning)에서 사용되며, 여러 학습 알고리즘을 결합하여 분류, 회귀 등의 문제를 해결합니다. 예를 들어, 배깅, 부스팅, 랜덤 포레스트 모두 지도학습 알고리즘의 일환입니다.<br>
			</div>
			<div class="t2">
									#앙상블 모형									# 배깅									# 부스팅									# 랜덤 포레스트									# 지도학습							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5546);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">27.</span>
			<span class="tt1t1">
				아래에서 설명하는 앙상블 방법은?					
					<span class="tt1t1">
						- 배깅에 랜덤 과정을 추가한 방법 <br>
- 원자료로부터 붓스트랩 샘플을 추출하고 각 붓스트랩 샘플에 대해 형성해 나간다는 점에서 배깅과 유사 <br>
- 각 노드마다 예측변수를 임의로 추출하고, 추출된 변수 내에서 최적의 분할을 생성					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트 (Random Forest)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부스팅 (Boosting)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			배깅 (Bagging)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스태킹 (Stacking) 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a27" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a27" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			랜덤 포레스트 (Random Forest)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		랜덤 포레스트(Random Forest)는 배깅에 무작위성을 추가한 방법으로, 각 노드마다 무작위로 선택된 변수들 내에서 최적의 분할을 수행한다. 이는 모델의 분산을 줄이고 일반화 성능을 향상시키는 데 효과적이다. 부스팅은 이전 단계의 오류를 수정하는 방식이며, 배깅은 무작위성을 포함하지 않는다. 스태킹은 여러 모형의 결과를 결합하여 최종 예측을 생성하는 기법이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				앙상블 방법 중 랜덤 포레스트는 배깅에 랜덤 과정을 추가하여 각 노드마다 예측변수를 임의로 추출하는 방법입니다. 이는 배깅과 유사하지만, 랜덤하게 선택된 변수 내에서 최적의 분할을 생성하여 모델의 다양성을 높입니다. <br>
<br>
1. 랜덤 포레스트 (Random Forest)<br>
: 랜덤 포레스트는 배깅에 랜덤성을 추가하여 각 노드에서 예측 변수를 임의로 선택하는 방식입니다. 이는 문제에서 설명한 방식과 정확히 일치합니다.   <br>
<br>
2. 부스팅 (Boosting)<br>
: 부스팅은 약한 학습기를 순차적으로 학습시켜 강한 학습기를 만드는 방법으로, 랜덤 포레스트의 랜덤 변수 선택과는 다릅니다. 부스팅은 이전 모델의 오류를 보정하는 방식으로 작동합니다.   <br>
<br>
3. 배깅 (Bagging)<br>
: 배깅은 원자료로부터 붓스트랩 샘플을 추출하여 각각의 모델을 학습시키는 방식으로, 랜덤 포레스트와 달리 노드별 변수 선택을 하지 않습니다. 이는 문제에서 설명한 랜덤 과정이 추가되지 않은 방법입니다.   <br>
<br>
4. 스태킹 (Stacking)<br>
: 스태킹은 여러 모델의 예측을 결합하여 최종 예측을 만드는 방법으로, 문제에서 설명한 랜덤 변수 선택과는 관련이 없습니다. 이는 서로 다른 모델의 예측을 조합하는 방식입니다.<br>
			</div>
			<div class="t2">
									#앙상블									# 스태킹									# 모델 조합									# 예측 성능 향상 							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5583);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">28.</span>
			<span class="tt1t1">
				데이터에 관측치가 d개 있을 때, 각 관측치가 학습용 데이터로 선정될 확률이 ({1 over d})라고 가정하자. 학습용 데이터를 구성하기 위해 d번의 랜덤 샘플링을 수행했을 때, 특정 관측치가 학습용 데이터에 포함되지 않을 확률은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=6cfe0bc4-d1ca-983a-0d34-dee751e43613.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/6cfe0bc4-d1ca-983a-0d34-dee751e43613.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="4" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="5" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="6" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mrow data-mjx-texclass="ORD"><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow></mrow></msup></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="7" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi></math></mjx-assistive-mml></mjx-container>					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a28" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a28" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="8" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		특정 관측치가 학습용 데이터에 포함되지 않을 확률을 계산하려면, 랜덤 샘플링 과정에서 특정 관측치가 선택되지 않을 확률가 이를 d번 반복했을 때의 결과를 고려해야 한다. 관측치가 각 샘플에서 선택되지 않을 확률은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="9" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow></math></mjx-assistive-mml></mjx-container> 이며, 이를 d번 독립적으로 반복하므로 확률은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="10" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>이다. 				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				특정 관측치가 학습용 데이터에 포함되지 않을 확률을 계산하는 과정은 아래와 같습니다.<br>
<br>
1. 관측치가 선택되지 않을 확률<br>
데이터에 관측치가  d개 있을 때, 각 관측치가 샘플링 과정에서 선택될 확률은 1/d입니다. 따라서 선택되지 않을 확률은 (1 - frac{1}{d}) 입니다.<br>
<br>
2. d번의 랜텀 샘플링에서 선택되지 않을 확률<br>
랜덤 샘플링은 서로 독립적으로 수행되므로, 특정 관측치가 d번의 샘플링 동안 모두 선택되지 않을 확률은 위 확률의 d번 곱으로 계산됩니다. 이를 식으로 나타내면 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="11" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D459 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D44E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D450 TEX-I"></mjx-c></mjx-mi><mjx-texatom texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom><mjx-texatom texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45F TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c210E TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>d</mi></mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container> 와 같습니다.<br>
			</div>
			<div class="t2">
									#랜덤 샘플링									# 확률									# 반복 시행							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6049);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">29.</span>
			<span class="tt1t1">
				다음 설명에 맞는 데이터 마이닝 기법은 무엇인가?					
					<span class="tt1t1">
						동물의 뇌신경계를 모방하여 분류(또는 예측)을 위해 만들어진 모형					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 (Decision Tree)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인공신경망 (Artificial Neural Networks)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀 (Logistic Regression)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			서포트 벡터 머신 (Support Vector Machine)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a29" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a29" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			인공신경망 (Artificial Neural Networks)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		인공신경망(Artificial Neural Networks)은 동물의 뇌신경계를 모방하여 분류와 예측에 사용되는 모델이다. 의사결정나무는 데이터를 분할하여 예측을 수행하며, 로지스틱 회귀는 확률 기반의 분류 모형이고, 서포트 벡터 머신은 초평면을 사용해 데이터를 분류하는 기법이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				인공신경망(ANN)은 생물학적 뉴런에서 영감을 받아 설계된 모델입니다. 입력 데이터와 출력 사이의 복잡한 관계를 학습하며, 뉴런(Neuron)으로 이루어진 층(layer)을 통해 정보를 처리합니다. 비선형적이고 복잡한 문제를 해결하는 데 효과적이며, 이미지 분류, 음성 인식, 예측 모델링 등 다양한 분야에서 활용됩니다.<br>
<br>
1. 의사결정나무 (Decision Tree)<br>
: 의사결정나무는 데이터를 분할하여 의사결정 규칙을 생성하고, 이를 기반으로 분류나 예측을 수행하는 모델입니다. 트리 형태의 계층적 구조를 사용하며, 동물의 뇌신경계를 모방한 방식이 아니기 때문에 문제의 설명과는 일치하지 않습니다.<br>
<br>
2. 인공신경망 (Artificial Neural Networks)<br>
: 인공신경망은 동물의 뇌신경계를 모방한 모델로, 입력 뉴런, 은닉층(hidden layer), 출력 뉴런의 구조를 가지고 있습니다. 데이터의 복잡한 패턴을 학습하며, 분류와 예측 문제를 해결하는 데 강력한 성능을 발휘합니다. 문제에서 설명한 내용과 정확히 일치하는 모델입니다.<br>
<br>
3. 로지스틱 회귀 (Logistic Regression)<br>
: 로지스틱 회귀는 데이터의 종속 변수(결과)가 범주형일 때 이를 예측하기 위해 사용하는 통계적 기법입니다. 단일 방정식을 기반으로 하며 비선형적 관계를 모델링하는 데 제한적입니다. 동물의 뇌신경계를 모방한 모델이 아니므로 문제의 설명과는 맞지 않습니다.<br>
<br>
4. 서포트 벡터 머신 (Support Vector Machine)<br>
: 서포트 벡터 머신은 초평면(hyperplane)을 사용해 데이터를 분류하는 기법입니다. 데이터의 경계선을 정의하여 분류를 수행하며, 동물의 뇌신경계를 모방한 모델이 아니기 때문에 문제의 설명과는 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#인공신경망									# 뉴런									# 분류									# 예측							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6524);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">30.</span>
			<span class="tt1t1">
				신경망 모형은 자신이 가진 데이터로부터 반복적인 학습과정을 거처 패턴을 찾아내고 이를 일반화하는 예측방법이다. 다음 중 신경망 모형에 대한 설명으로 부적절한 것은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			피드 포워드 신경망은 정보가 전방으로 전달되는 것으로 생물학적 신경계에서 나타나는 형태이며 딥러닝에서 가장 핵심적인 구조 개념이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			일반적으로 인공신경망은 다층 퍼셉트론을 의미한다. 다층 퍼셉트론에서 정보의 흐름은 입력층에서 시작하여 은닉층을 거쳐 출력층으로 진행된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			역전파 알고리즘은 연결강도를 갱신하기 위해 예측된 결과와 실제값의 차이인 에러의 역전파를 통해  가중치를 구하는데서 시작되었다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a30" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a30" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			은닉층의 뉴런 수와 개수는 신경망 모형에서 자동으로 설정된다. 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		신경망 모형에서 은닉층의 뉴런 수와 개수는 설계자가 실험적으로 설정해야 하며, 자동으로 결정되지 않는다. 피드 포워드 신경망은 딥러닝에서 중요한 구조로 정보가 전방으로만 흐르는 특징을 가지며, 다층 퍼셉트론은 입력층, 은닉층, 출력층을 통해 정보를 처리한다. 역전파 알고리즘은 오차 역전파를 통해 가중치를 갱신하는 방법으로 신경망 학습의 핵심이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				신경망 모형에서 은닉층의 뉴런 수와 개수는 자동으로 설정되지 않으며, 사용자가 직접 설정해야 하는 하이퍼파라미터입니다. 이는 모델의 성능에 큰 영향을 미치므로 신중히 선택해야 합니다.<br>
			</div>
			<div class="t2">
									#신경망 모형									# 피드 포워드									# 은닉층									# 다층 퍼셉트론									# 역전파 알고리즘							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6100);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">31.</span>
			<span class="tt1t1">
				다음 설명에 맞는 함수는 무엇인가?					
					<span class="tt1t1">
						신경망 모형에서 출력값 z가 여러 개로 주어지고 목표치가 다범주인 경우, 각 범주에 속할 사후 확률을 제공하여 출력 노드에 주로 사용되는 함수					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			시그모이드 함수 (Sigmoid Function)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			소프트맥스 함수 (Softmax Function)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			하이퍼볼릭 탄젠트 함수 (Tanh Function)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ReLU 함수 (Rectified Linear Unit)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a31" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a31" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			소프트맥스 함수 (Softmax Function)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		소프트맥스 함수는 신경망 모형에서 다범주 목표치에 대한 확률 분포를 제공하는 데 사용된다. 이는 각 출력값을 정규화하여 범주 확률로 변환하며, 분류 문제의 출력층에서 주로 사용된다. 시그모이드 함수는 이진 분류 문제에 적합하며, 하이퍼볼릭 탄젠트 함수는 연속형 값에 사용된다. ReLU 함수는 활성화 함수로 음수를 0으로 변환한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				신경망 모형에서 다범주 분류 문제를 해결하기 위해 각 범주에 속할 사후 확률을 제공하는 함수는 소프트맥스 함수입니다. 이는 여러 출력값을 받아 각 범주에 대한 확률을 계산하여, 총합이 1이 되도록 정규화하는 역할을 합니다.<br>
<br>
1. 시그모이드 함수 (Sigmoid Function)<br>
: 시그모이드 함수는 이진 분류 문제에 주로 사용되며, 출력값을 0과 1 사이로 변환합니다. 다범주 분류 문제에서는 적합하지 않습니다.<br>
<br>
2. 소프트맥스 함수 (Softmax Function)<br>
: 소프트맥스 함수는 여러 출력값을 받아 각 범주에 대한 확률을 계산하여 총합이 1이 되도록 정규화합니다. 다범주 분류 문제에 적합한 함수입니다.<br>
<br>
3. 하이퍼볼릭 탄젠트 함수 (Tanh Function)<br>
: 하이퍼볼릭 탄젠트 함수는 출력값을 -1과 1 사이로 변환하며, 주로 이진 분류나 회귀 문제에 사용됩니다. 다범주 분류 문제에서는 적합하지 않습니다.<br>
<br>
4. ReLU 함수 (Rectified Linear Unit)<br>
: ReLU 함수는 음수를 0으로 변환하고 양수는 그대로 출력하는 활성화 함수로, 주로 은닉층에서 사용됩니다. 확률을 제공하는 기능은 없습니다.<br>
			</div>
			<div class="t2">
									#다범주 분류									# 소프트맥스 함수									# 사후 확률							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5531);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">32.</span>
			<span class="tt1t1">
				인공신경망 모형에서 활성함수인 시그모이드(sigmoid)의 함수의 결과값으로 올바른 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			-0.5 또는 0.5					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0 또는 0.9					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0 ≤y ≤ 1 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			-1 ≤y ≤ 1					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a32" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a32" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			0 ≤y ≤ 1 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		시그모이드 함수의 출력값은 입력값의 범위에 관계없이 항상 0과 1 사이의 값을 갖는다. 이는 출력값을 확률처럼 해석할 수 있게 한다. -0.5 또는 0.5, 0 또는 0.9, -1 ≤ y ≤ 1은 시그모이드 함수의 특성과 맞지 않는다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				시그모이드 함수는 비선형 활성화함수로, 입력값 x가 어떤 값이든 상관없이, 출력값은 항상 0과 1 사이에 위치합니다. 이진 분류와 같이 확률적인 결과를 나타낼 때 유용합니다.<br>
<br>
1. -0.5 또는 0.5<br>
: 시그모이드 함수의 출력값은 항상 0과 1 사이에 위치하며, 특정 고정된 값(-0.5 또는 0.5)만 반환하지 않습니다. 특히, -0.5는 시그모이드 함수에서 나올 수 없는 값입니다.<br>
<br>
2. 0 또는 0.9<br>
: 시그모이드 함수는 입력값에 따라 연속적인 0에서 1 사이의 값을 반환합니다. 특정 값(예: 0 또는 0.9)만 반환하지 않으며, 출력값이 특정한 입력값에 고정되지 않습니다.<br>
<br>
3. 0 ≤ y ≤ 1<br>
: 시그모이드 함수는 입력값이 양수이든 음수이든 관계없이 항상 0과 1 사이의 값을 반환합니다. 예를 들어, x=0일 때 출력값은 0.5이며, x→∞일 때 출력값은 1에 가까워지고, x→−∞일 때 출력값은 0에 가까워집니다. 이는 시그모이드 함수의 정의와 수학적 특성에 따른 결과입니다.<br>
<br>
4. -1 ≤ y ≤ 1<br>
:  -1에서 1 사이의 값을 출력하는 함수는 하이퍼볼릭 탄젠트(tanh) 함수의 특성입니다. 시그모이드 함수는 항상 0과 1 사이의 값을 반환하므로, 이 설명은 시그모이드 함수의 특성과 맞지 않습니다.<br>
			</div>
			<div class="t2">
									#시그모이드 함수									# 출력값 범위									# 활성함수									# 인공신경망							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6101);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">33.</span>
			<span class="tt1t1">
				신경망 모형의 학습을 위한 역전파 과정에서 오차를 더 줄일 수 있는 가중치가 존재함에도 기울기가 0이 되어버려 더 이상 학습이 진행되지 않는 문제를 나타내는 용어는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			과적합 (Overfitting)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기울기 소실 (Vanishing Gradient)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			기울기 폭주 (Exploding Gradient)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			초기화 문제 (Initialization Problem)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a33" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a33" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			기울기 소실 (Vanishing Gradient)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		기울기 소실(Vanishing Gradient)은 역전파 과정에서 가중치 갱신 시 기울기가 점점 작아져 0에 가까워지며 학습이 멈추는 문제를 말한다. 과적합은 학습 데이터에만 최적화된 경우 발생하며, 기울기 폭주는 가중치가 지나치게 커지는 문제이다. 초기화 문제는 가중치 초기값 설정과 관련된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				신경망 모형의 학습에서 기울기 소실 문제는 역전파 과정에서 기울기가 점점 작아져 0에 가까워지면서 학습이 멈추는 현상을 의미합니다. 이는 주로 깊은 신경망에서 발생하며, 가중치가 업데이트되지 않아 학습이 진행되지 않는 문제를 야기합니다.<br>
<br>
1. 과적합 (Overfitting)<br>
: 과적합은 모델이 학습 데이터에 지나치게 적응하여 새로운 데이터에 대한 일반화 성능이 저하되는 현상입니다. 과적합은 학습 데이터와 테스트 데이터의 성능 차이에 대한 문제이며, 기울기가 0이 되어 학습이 멈추는 기울기 소실과는 무관합니다.<br>
<br>
2. 기울기 소실 (Vanishing Gradient)<br>
: 역전파 과정에서 활성화 함수의 도함수가 매우 작은 값을 가질 때, 기울기(Gradient)가 점점 작아져 0에 가까워지는 현상을 기울기 소실이라고 합니다. 이로 인해 가중치 업데이트가 거의 이루어지지 않으면서 학습이 정체됩니다.<br>
<br>
3. 기울기 폭주 (Exploding Gradient)<br>
: 기울기 폭주는 기울기 소실과 반대되는 문제로, 값이 0에 가까워지는 대신 매우 큰 값을 가지는 경우를 나타냅니다. 이 문제는 주로 순환 신경망(RNN)과 같은 깊은 네트워크에서 발생하며, 기울기를 안정화하기 위해 Gradient Clipping 등의 기술이 사용됩니다.<br>
<br>
4. 초기화 문제 (Initialization Problem)<br>
: 초기화 문제는 학습 시작 시 가중치의 초기값을 부적절하게 설정하여 기울기 소실 또는 폭주를 유발하는 문제입니다. 초기값이 너무 작으면 기울기 소실로 이어지고, 초기값이 너무 크면 기울기 폭주로 이어질 수는 있으나, 초기화 문제는 기울기가 0이 되어 학습이 멈추는 기울기 소실을 직접 설명하는 용어는 아닙니다.<br>
			</div>
			<div class="t2">
									#기울기 소실									# 역전파									# 활성화 함수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6525);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">34.</span>
			<span class="tt1t1">
				다음 중 다층인공신경망에서 노드의 개수가 적을 경우 발생하는 특징으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			계산 복잡도가 증가한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정과 설명이 복잡해진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			과적합이 발생 가능성이 작아 진다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			학습 시간이 길어진다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a34" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a34" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			과적합이 발생 가능성이 작아 진다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		다층 인공신경망에서 노드 개수가 적으면 모델의 복잡도가 낮아져 과적합 발생 가능성이 줄어든다. 계산 복잡도는 감소하고, 학습 시간도 단축된다. 의사결정과 설명은 복잡성과 관계가 있으며, 노드 수가 적을수록 모델이 단순해진다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				다층 인공신경망에서 노드의 개수가 적을 경우, 모델의 복잡성이 낮아져 과적합 발생 가능성이 줄어듭니다. 이는 모델이 학습 데이터에 너무 맞춰지는 것을 방지하고, 일반화 능력을 향상시킵니다.<br>
   1. 계산 복잡도가 증가한다: 노드의 개수가 적으면 계산 복잡도가 감소합니다. 노드가 적을수록 계산해야 할 양이 줄어들기 때문에 복잡도가 증가하지 않습니다.<br>
   2. 의사결정과 설명이 복잡해진다: 노드가 적을수록 모델이 단순해져 설명이 더 쉬워집니다. 복잡한 모델일수록 의사결정이 복잡해지므로, 이 선택지는 부적절합니다.<br>
   3. 과적합이 발생 가능성이 작아 진다: 노드가 적으면 모델의 복잡성이 낮아져 과적합이 줄어듭니다. 이는 모델이 학습 데이터에 너무 맞춰지는 것을 방지합니다.<br>
   4. 학습 시간이 길어진다: 노드가 적으면 학습해야 할 파라미터가 줄어들어 학습 시간이 짧아집니다. 따라서 학습 시간이 길어지지 않습니다.<br>
			</div>
			<div class="t2">
									#다층 인공신경망									# 노드 개수									# 과적합									# 모델 복잡성							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5644);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">35.</span>
			<span class="tt1t1">
				군집분석은 데이터 내의 숨겨진 그룹을 찾아내는 기법이다. 다음 설명 중 부적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			군집분석에서는 독립변수 간의 관계를 분석하며 별도의 반응변수는 필요하지 않다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			계층적 군집 분석은 데이터를 병합하거나 나누는 방식으로 군집을 형성한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			집단 간 이질성과 집단 내 동질성이 모두 낮아지는 방법으로 군집을 만든다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집화 방법에는 밀도기반 접근법과 중심점 기반 접근법 등이 포함된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a35" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a35" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			집단 간 이질성과 집단 내 동질성이 모두 낮아지는 방법으로 군집을 만든다. 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		군집분석은 집단 내 동질성을 높이고 집단 간 이질성을 증가시키는 것을 목표로 한다. 독립변수 간의 관계 분석은 반응변수가 없다는 점에서 적절하며, 계층적 군집분석은 병합과 분할 방식으로 이루어진다. 또한 밀도기반 및 중심점 기반 접근법은 군집화 기법의 일부이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집분석은 집단 간의 이질성을 높이고 집단 내의 동질성을 높이는 것이 목표입니다. 선택지 3은 이 원칙에 어긋나며, 군집분석의 기본 개념을 잘못 설명하고 있습니다.<br>
<br>
1. 군집분석에서는 독립변수 간의 관계를 분석하며 별도의 반응변수는 필요하지 않다.<br>
: 군집분석은 비지도학습 기법으로, 데이터의 구조적 패턴을 탐색하는 데 사용됩니다. 예를 들어, 고객 데이터를 군집화할 때 "나이, 구매 빈도, 소비 금액" 등의 독립변수만 활용하며, 특정 반응변수(종속변수)를 요구하지 않습니다.<br>
<br>
2. 계층적 군집 분석은 데이터를 병합하거나 나누는 방식으로 군집을 형성한다.<br>
: 계층적 군집분석은 데이터 간의 유사성을 측정하여 병합(상향식) 또는 분할(하향식) 방식으로 군집을 형성합니다. 병합 방식은 각각의 데이터를 개별 군집으로 시작해 점진적으로 병합하며, 분할 방식은 전체 데이터를 하나의 군집으로 시작해 점차 분리합니다.<br>
<br>
3. 집단 간 이질성과 집단 내 동질성이 모두 낮아지는 방법으로 군집을 만든다. <br>
: 군집분석의 목표는 집단 내 동질성을 최대화하고, 집단 간 이질성을 최대화하는 것입니다. 예를 들어, 고객 데이터를 군집화할 때, 같은 군집에 속한 고객들은 비슷한 소비 패턴을 가지며, 다른 군집의 고객들과는 다른 특성을 가집니다. "집단 간 이질성과 집단 내 동질성이 모두 낮아진다"는 설명은 군집분석의 원리와 완전히 반대되는 부적절한 설명입니다.<br>
<br>
4. 군집화 방법에는 밀도기반 접근법과 중심점 기반 접근법 등이 포함된다.<br>
: 군집화 방법은 데이터의 특성에 따라 다양한 접근법이 있으며, 그 중에는 중심점 기반 접근법과 밀도기반 접근법이 포함되어 있습니다. 중심점 기반 접근법은 K-Means와 같은 방법으로, 군집의 중심을 기준으로 데이터를 그룹화하는 접근법이며, 밀도기반 접근법은 DBSCAN과 같은 방법으로, 데이터의 밀도가 높은 영역을 그룹화하는 접근법입니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 비지도 학습									# 계층적 군집									# 밀도기반 접근법									# 중심점 기반 접근법							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6526);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">36.</span>
			<span class="tt1t1">
				다음 군집화 방법 중 DBSCAN, DENCLUE 기법 등 임의적인(Arbitrarity) 모양의 군집 탐색에 가장 효과적인 방법은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			밀도기반 군집 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모형기반 군집 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			격자기반 군집 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			커널기반 군집					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a36" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a36" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			밀도기반 군집 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		밀도기반 군집화(DBSCAN, DENCLUE)는 밀도가 높은 영역을 군집으로 정의하며, 임의적인 모양의 군집 탐색에 효과적이다. 모형기반 군집은 군집이 특정 분포를 따른다고 가정하며, 격자기반 군집은 격자 공간에서 데이터를 분할한다. 커널기반 군집은 커널 밀도 추정 기법을 사용한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 군집화 방법 중 밀도기반 군집화는 데이터의 밀도를 기준으로 군집을 형성하여 임의적인 모양의 군집 탐색에 효과적입니다. 이는 데이터의 밀도가 높은 지역을 군집으로 정의하고, 밀도가 낮은 지역은 군집 외부로 간주하는 방식입니다.<br>
   <br>
   1. 밀도기반 군집: DBSCAN과 같은 밀도기반 군집화 방법은 데이터의 밀도를 기준으로 군집을 형성하여 임의적인 모양의 군집 탐색에 효과적입니다. 이는 밀도가 높은 지역을 군집으로 정의하고, 밀도가 낮은 지역은 군집 외부로 간주하는 방식입니다.<br>
   <br>
   2. 모형기반 군집: 모형기반 군집화는 데이터가 특정 확률 분포를 따른다고 가정하여 군집을 형성하는 방법입니다. 이는 임의적인 모양의 군집을 탐색하기에는 적합하지 않습니다.<br>
   <br>
   3. 격자기반 군집: 격자기반 군집화는 공간을 격자로 나누어 군집을 형성하는 방법으로, 임의적인 모양의 군집 탐색에는 한계가 있습니다. 이는 주로 데이터가 균일하게 분포된 경우에 효과적입니다.<br>
   <br>
   4. 커널기반 군집: 커널기반 군집화는 데이터의 분포를 커널 함수로 추정하여 군집을 형성하는 방법입니다. 이는 임의적인 모양의 군집 탐색에 효과적이지 않습니다.<br>
			</div>
			<div class="t2">
									#밀도기반 군집화									# DBSCAN									# 임의적 모양 군집									# 데이터 밀도							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6527);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">37.</span>
			<span class="tt1t1">
				군집분석에서는 관측값들이 얼마나 유사한지 또는 유사하지 않은지를 측정할 수 있는 측도가 필요하다. 다음 중 유사도 측도에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유클리드 거리는 데이터 간의 절대적인 거리를 기반으로 유사도를 측정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			코사인 거리는 두 단위 벡터의 내적을 이용하여, 단위 벡터의 내각의 크기로 유사도를 측정한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자카드는 Boolean 속성으로 이루어진 두 객체 간의 유사도 측정에 사용된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a37" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a37" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		피어슨 상관계수는 두 변수 간의 선형 관계를 측정하는 방식으로, 데이터 간의 유사성를 측정하는 데 직접 사용되지 않는다. 유사도 측도는 일반적으로 두 객체 간의 거리나 유사한 특성 정도를 수치화하는 것이며, 피어슨 상관계수는 상관 분석의 도구로 분류된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
군집분석(Cluster Analysis)에서 관측값들을 유사한 그룹으로 묶기 위해서는 데이터 간의 유사성(Similarity) 또는 비유사성(Dissimilarity, 즉 거리)을 측정하는 기준이 필요하며, 이러한 측도들은 데이터의 특성에 따라 다양하게 적용됩니다.<br>
<br>
1. 유클리드 거리는 데이터 간의 절대적인 거리를 기반으로 유사도를 측정한다.<br>
: 유클리드 거리(Euclidean Distance)는 가장 흔하게 사용되는 거리 측도로, 다차원 공간에서 두 점 사이의 '직선 거리'를 의미합니다. 데이터 포인트 간의 절대적인 차이(크기)를 기반으로 거리를 측정하며, 거리가 짧을수록 유사하다고 판단합니다.<br>
<br>
2. 코사인 거리는 두 단위 벡터의 내적을 이용하여, 단위 벡터의 내각의 크기로 유사도를 측정한다.<br>
: 코사인 거리(Cosine Distance)는 두 벡터가 이루는 각도의 코사인 값을 이용하여 유사도를 측정합니다. 두 벡터가 가리키는 방향이 얼마나 유사한지를 측정하며, 벡터의 크기보다는 방향성에 중점을 둡니다. 두 벡터의 내적을 각 벡터의 크기로 나눈 값이며, 그 값은 -1에서 1 사이이다. 코사인 유사도가 1에 가까울수록 두 벡터의 방향이 같아 유사하다고 판단합니다.<br>
<br>
3. 자카드는 Boolean 속성으로 이루어진 두 객체 간의 유사도 측정에 사용된다.<br>
: 자카드 계수(Jaccard Coefficient)는 두 집합 간의 유사도를 측정하는 데 사용되며, 특히 이진(Boolean) 속성을 가진 데이터에 적합하다. 두 집합의 교집합 크기를 합집합 크기로 나눈 값으로 계산됩니다. 예를 들어, 두 고객이 구매한 상품 목록의 유사도를 측정할 때 사용될 수 있습니다.<br>
<br>
4. 피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.<br>
: 피어슨 상관계수(Pearson Correlation Coefficient)는 두 변수 간의 선형 관계의 강도와 방향을 측정하는 지표입니다. 즉, 한 변수가 변할 때, 다른 변수가 얼마나 선형적으로 함께 변하는지를 측정합니다. 그 값은 -1에서 1 사이이며, 1에 가까울수록 강한 양의 선형 관계, -1에 가까울수록 강한 음의 선형 관계, 0에 가까울수록 선형 관계가 약하다는 것을 의미합니다. '각 객체의 데이터 집합이 직선으로 표현되는 정도'라는 표현은 피어슨 상관계수의 본질적인 의미와 다릅니다.<br>
<br>
피어슨 상관계수는 두 변수 간의 선형 관계의 강도와 방향을 나타내는 지표이지, 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정하는 것이 아닙니다.<br>
<br>
따라서 정답은 '4. 피어슨 상관계수는 각 객체의 데이터 집합이 직선으로 표현되는 정도를 측정한다.'입니다.<br>
			</div>
			<div class="t2">
									#유사도 측도									# 유클리드 거리									# 코사인 거리									# 자카드 지수									# 피어슨 상관계수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5923);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">38.</span>
			<span class="tt1t1">
				계층적 군집 방법에서 두 개체(또는 군집) 간의 거리(또는 비유사성)를 정의할 때, 변수의 표준화와 변수 간의 상관성을 동시에 고려한 통계적 거리로 적합한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유클리디안 거리(Euclidean distance)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			민코우스키 거리(Minkowski distance)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마할라노비스 거리(Mahalanobis distance)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			코사인 유사도(Cosine similarity)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a38" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a38" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			마할라노비스 거리(Mahalanobis distance)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		마할라노비스 거리는 변수의 표준화와 변수 간 상관성을 동시에 고려하여 두 개체 간의 거리를 측정하는 통계적 방법이다. 유클리디안 거리는 단순한 직선 거리를 측정하며, 민코우스키 거리는 유클리디안 거리의 일반화 형태이다. 코사인 유사도는 벡터 간의 각도를 기반으로 유사성을 측정한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				계층적 군집 방법에서 두 개체 간의 거리를 정의할 때 변수의 표준화와 변수 간의 상관성을 동시에 고려하는 통계적 거리는 "마할라노비스 거리"입니다. 이는 변수들 간의 공분산을 고려하여, 서로 다른 척도를 가진 변수들 간의 거리 계산에 적합합니다.<br>
<br>
1. 유클리디안 거리(Euclidean distance)<br>
: 변수의 표준화나 상관성을 고려하지 않고 단순한 직선 거리를 계산합니다. 이는 변수 간의 척도가 다를 경우 적합하지 않습니다.<br>
<br>
2. 민코우스키 거리(Minkowski distance)<br>
: 유클리디안 거리를 일반화한 형태로, 특정 p값에 따라 다양한 거리를 계산할 수 있지만 변수 간의 상관성을 반영하지 않습니다.<br>
<br>
3. 마할라노비스 거리(Mahalanobis distance)<br>
: 변수의 표준화와 상관성을 고려하여 거리 계산에 적합합니다. 이는 변수 간의 공분산을 반영하여 보다 정확한 거리 측정이 가능합니다.<br>
<br>
4. 코사인 유사도(Cosine similarity)<br>
: 두 벡터 간의 각도를 측정하여 유사성을 평가하며, 거리보다는 방향성을 중시합니다. 이는 거리 측정보다는 유사성 측정에 사용됩니다.<br>
			</div>
			<div class="t2">
									#계층적 군집									# 마할라노비스 거리									# 변수 표준화									# 상관성							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6173);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">39.</span>
			<span class="tt1t1">
				아래 두 데이터 셋 A와 B의 유사성을 맨하탄 거리로 계산하면?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=3640056d-97b6-3706-3366-8cdeb1213a1a.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/3640056d-97b6-3706-3366-8cdeb1213a1a.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			10					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="12" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>8</mn></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="13" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.158em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>40</mn></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a39" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a39" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			10			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		맨하탄 거리(Manhattan Distance)는 두 데이터 간의 절대 거리 합을 계산한다. 따라서 180-175 =5 와 70-65 =5 의 합인 10이 정답이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				맨하탄 거리는 격자형 구조(예: 도시 거리)에서 두 점 사이의 거리를 계산하는 방식입니다. 각 좌표 축(특성)마다 차이를 계산하고, 그 절대값의 합을 구합니다. 공식은 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="14" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c44"></mjx-c><mjx-c class="mjx-c5F"></mjx-c><mjx-c class="mjx-c7B"></mjx-c><mjx-c class="mjx-c4D"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c68"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c7D"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-munderover space="4"><mjx-over style="padding-bottom: 0.192em; padding-left: 0.51em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-mrow space="2"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-mrow></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>D_{Manhattan}</mtext><mo>=</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo data-mjx-texclass="CLOSE">|</mo></mrow></math></mjx-assistive-mml></mjx-container><br>
<br>
1. 주어진 데이터<br>
A: 키 = 180, 몸무게 = 65<br>
B: 키 = 175, 몸무게 = 70<br>
<br>
2. 계산 과정<br>
• 키의 차이 계산<br>
∣180−175∣=5<br>
<br>
• 몸무게의 차이 계산<br>
∣65−70∣=5<br>
<br>
• 맨하탄 거리 계산<br>
D=∣180−175∣+∣65−70∣=5+5=10<br>
<br>
따라서 정답은 ② 10 입니다.<br>
			</div>
			<div class="t2">
									#맨하탄 거리									# 거리 계산									# 유사성							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5922);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">40.</span>
			<span class="tt1t1">
				다음 중 민코우스키 거리(Minkowski distance)의 정의로 적합한 수식을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=308a3ea3-66fb-0dc4-d15e-f1a5199084c9.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/308a3ea3-66fb-0dc4-d15e-f1a5199084c9.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="15" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-munderover space="4"><mjx-over style="padding-bottom: 0.111em; padding-left: 0.544em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.413em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="16" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mrow><mjx-mo class="mjx-s4"><mjx-c class="mjx-c28 TEX-S4"></mjx-c></mjx-mo><mjx-munderover><mjx-over style="padding-bottom: 0.111em; padding-left: 0.461em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c220F TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.065em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mo class="mjx-s4"><mjx-c class="mjx-c29 TEX-S4"></mjx-c></mjx-mo></mjx-mrow><mjx-script style="vertical-align: 1.477em;"><mjx-texatom size="s" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><munderover><mo data-mjx-texclass="OP">∏</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow></msup></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="17" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt class="mjx-tall"><mjx-surd><mjx-mo class="mjx-n"><mjx-stretchy-v class="mjx-c221A" style="height: 3.6em; vertical-align: -1.05em;"><mjx-beg><mjx-c></mjx-c></mjx-beg><mjx-ext><mjx-c></mjx-c></mjx-ext><mjx-end><mjx-c></mjx-c></mjx-end><mjx-mark></mjx-mark></mjx-stretchy-v></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.427em;"><mjx-munderover><mjx-over style="padding-bottom: 0.111em; padding-left: 0.544em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">|</mo></msqrt></math></mjx-assistive-mml></mjx-container>					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="18" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mrow><mjx-mo class="mjx-s4"><mjx-c class="mjx-c28 TEX-S4"></mjx-c></mjx-mo><mjx-munderover><mjx-over style="padding-bottom: 0.111em; padding-left: 0.544em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-script style="vertical-align: 0.413em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class="mjx-s4"><mjx-c class="mjx-c29 TEX-S4"></mjx-c></mjx-mo></mjx-mrow><mjx-script style="vertical-align: 1.477em;"><mjx-texatom size="s" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mi>m</mi></msup><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></msup></math></mjx-assistive-mml></mjx-container>					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a40" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a40" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="19" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mrow><mjx-mo class="mjx-s4"><mjx-c class="mjx-c28 TEX-S4"></mjx-c></mjx-mo><mjx-munderover><mjx-over style="padding-bottom: 0.111em; padding-left: 0.544em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-script style="vertical-align: 0.413em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class="mjx-s4"><mjx-c class="mjx-c29 TEX-S4"></mjx-c></mjx-mo></mjx-mrow><mjx-script style="vertical-align: 1.477em;"><mjx-texatom size="s" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" style="font-size: 71.4%;"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mi>m</mi></msup><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></msup></math></mjx-assistive-mml></mjx-container>			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		민코우스키 거리(Minkowski distance)는 두 점 x와 y 사이의 거리를 일반화한 거리 척도로, 차수 m에 따라 다양한 거리 측정을 가능하게 한다. 민코우스키 거리의 정의는 선택지 4의 수식과 일치하며, m=1일 때 맨해튼 거리, m=2일 때 유클리드 거리로 특화된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				민코우스키 거리는 두 점 사이의 거리를 일반화한 수식으로, 다양한 거리 계산에 사용됩니다. 이는 주어진 두 점의 각 차이의 절대값을 특정 지수로 거듭 제곱한 후, 그 합의 m제곱근을 구하는 방식입니다.<br>
 <br>
1. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="20" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-munderover space="4" limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.297em; margin-left: 0px;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-spacer style="margin-top: 0.18em;"></mjx-spacer><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-munderover><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container><br>
: 이 식은 민코우스키 거리의 정의와 다릅니다. 제곱합을 취하는 구조로, 이는 유클리드 거리의 제곱 형태와 유사하지만, 루트가 없으므로 거리로 사용할 수 없습니다.<br>
<br>
2. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="21" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mrow><mjx-mo class="mjx-sop"><mjx-c class="mjx-c28 TEX-S1"></mjx-c></mjx-mo><mjx-munderover limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c220F TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.297em; margin-left: 0px;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-spacer style="margin-top: 0.18em;"></mjx-spacer><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mo class="mjx-sop"><mjx-c class="mjx-c29 TEX-S1"></mjx-c></mjx-mo></mjx-mrow><mjx-script style="vertical-align: 0.577em;"><mjx-texatom size="s" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" style="font-size: 71.4%;"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><munderover><mo data-mjx-texclass="OP">∏</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow></msup></math></mjx-assistive-mml></mjx-container><br>
: 이 식은 거리 정의에 맞지 않습니다. 민코우스키 거리는 합산(∑) 연산을 기반으로 정의되며, 곱셈 연산은 거리 척도로 사용되지 않습니다.<br>
<br>
3. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="22" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.328em;"><mjx-munderover limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.297em; margin-left: 0px;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-spacer style="margin-top: 0.18em;"></mjx-spacer><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">|</mo></msqrt></math></mjx-assistive-mml></mjx-container><br>
: 이 식은 민코우스키 거리의 정의와 다릅니다. 절댓값의 합산 후 제곱근을 취하는 방식으로, 이는 어떤 표준적인 거리 척도의 정의와도 일치하지 않습니다.<br>
<br>
4. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="23" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msup space="4"><mjx-mrow><mjx-mo class="mjx-sop"><mjx-c class="mjx-c28 TEX-S1"></mjx-c></mjx-mo><mjx-munderover limits="false"><mjx-mo class="mjx-sop"><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-script style="vertical-align: -0.297em; margin-left: 0px;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-texatom><mjx-spacer style="margin-top: 0.18em;"></mjx-spacer><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-munderover><mjx-texatom space="2" texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-msup><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class="mjx-sop"><mjx-c class="mjx-c29 TEX-S1"></mjx-c></mjx-mo></mjx-mrow><mjx-script style="vertical-align: 0.577em;"><mjx-texatom size="s" texclass="ORD"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mi class="mjx-i" style="font-size: 71.4%;"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-texatom></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow data-mjx-texclass="ORD"><mi>p</mi></mrow></munderover><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mi>m</mi></msup><mo data-mjx-texclass="CLOSE">)</mo></mrow><mrow data-mjx-texclass="ORD"><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow></msup></math></mjx-assistive-mml></mjx-container><br>
: 민코우스키 거리의 정의와 정확히 일치합니다. m=1일 때 맨해튼 거리, m=2일 때 유클리드 거리, m→∞일 때 체비셰프 거리로 일반화됩니다.<br>
			</div>
			<div class="t2">
									#민코우스키 거리									# 유클리드 거리									# 맨해튼 거리									# 차수							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5596);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">41.</span>
			<span class="tt1t1">
				계층적 군집분석 결과를 아래와 같이 덴드로그램으로 시각화하였다고 할 때 Tree의 높이(height) 가 40일 경우 나타나는 군집의 수를 쓰시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=3e4344d7-59c2-908f-eae8-ed5276b59709.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/3e4344d7-59c2-908f-eae8-ed5276b59709.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			2개					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			3개					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			4개					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			5개					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a41" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a41" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			5개			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		계층적 군집분석의 덴드로그램에서 Tree의 높이(height)를 기준으로 군집을 나눌 때, height = 40에서 잘린다면 덴드로그램에서 5개의 군집이 형성된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 덴드로그램에서 군집의 수 결정 방법<br>
계층적 군집분석에서는 덴드로그램의 특정 높이(height)에서 수평선을 그어 군집을 나누는 방식으로 군집의 수를 결정합니다. Tree의 높이를 40으로 설정한 경우, 덴드로그램에서 높이 40에 수평선을 그리면 가지(branch) 개수에 따라 군집의 수를 확인할 수 있습니다. 가지가 교차하는 지점이 각 군집의 경계를 나타냅니다.<br>
<br>
2. Florida와 North Carolina의 군집 포함 여부<br>
덴드로그램에서 동일한 가지(branch)에 연결된 데이터는 하나의 군집으로 간주됩니다. 높이 40에서 수평선을 그리면 Florida와 North Carolina는 같은 가지에 속하므로, 개별 군집이 아닌 하나의 군집으로 묶입니다. 따라서 두 데이터는 독립된 군집으로 계산되지 않습니다.<br>
<br>
3. 군집 개수 계산<br>
높이 40에서 덴드로그램을 분석하면, 수평선 아래로 5개의 독립된 가지(branch)가 형성됩니다. 각 가지는 하나의 군집으로 간주되므로, 이 기준에 따라 형성되는 군집의 총 개수는 5개입니다.<br>
<br>
따라서, 문제의 정답은 '④ 5개'입니다.<br>
			</div>
			<div class="t2">
									#계층적 군집분석									# 덴드로그램									# 가지(branch)							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6530);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">42.</span>
			<span class="tt1t1">
				계층적 군집분석 수행 시 두 군집을 병합하는 방법 가운데 병합된 군집의 오차제곱합이 병합 이전 군집의 오차제곱합의 합에 비해 증가한 정도가 작아지는 방향으로 군집을 형성하는 방법은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			단일연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			중심연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			와드연결법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			완전연결법					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a42" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a42" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			와드연결법			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		와드연결법(Ward's method)은 군집을 병합할 때, 병합된 군집의 오차제곱합(ESS, Error Sum of Squares)이 병합 전보다 적게 증가하도록 군집을 형성한다. 단일연결법은 가장 가까운 두 관측치의 거리를 기준으로, 중심연결법은 군집의 중심 간 거리를 기준으로 군집을 병합하며, 완전연결법은 가장 먼 두 관측치 간 거리를 기준으로 한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				계층적 군집분석에서 와드연결법은 군집 내 오차제곱합의 증가를 최소화하는 방향으로 군집을 병합하는 방법입니다. 이는 군집 내의 데이터 간의 변동성을 최소화하여 보다 균일한 군집을 형성하는 데 초점을 맞춥니다.<br>
   1. 단일연결법: 두 군집 간의 가장 가까운 점 사이의 거리를 기준으로 병합하는 방법입니다. 이는 군집의 형태가 길고 늘어질 수 있어 오차제곱합을 최소화하는 데 적합하지 않습니다.<br>
   2. 중심연결법: 군집의 중심 간의 거리를 기준으로 병합하는 방법입니다. 이는 군집의 중심을 기준으로 하므로 오차제곱합의 증가를 최소화하는 데 직접적인 관련이 없습니다.<br>
   3. 와드연결법: 군집 내 오차제곱합의 증가를 최소화하는 방향으로 군집을 병합하는 방법입니다. 이는 군집의 내적 일관성을 유지하면서 병합을 진행합니다.<br>
   4. 완전연결법: 두 군집 간의 가장 먼 점 사이의 거리를 기준으로 병합하는 방법입니다. 이는 군집의 경계가 명확해지지만 오차제곱합의 증가를 최소화하는 데는 적합하지 않습니다.<br>
			</div>
			<div class="t2">
									#계층적 군집분석									# 와드연결법									# 오차제곱합							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6531);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">43.</span>
			<span class="tt1t1">
				아래는 학생들의 키와 몸무게를 정규화한 데이터이다. 최단연결법을 통해 학생들을 3개의 군집으로 나누고자 한다.(유클리디안 거리 사용) 다음 중 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=87f34530-2722-7745-6b9a-928448fac828.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/87f34530-2722-7745-6b9a-928448fac828.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			(A,C), (B), (D,E) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(A,D), (B), (C,E) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(A,E), (C), (B,D) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(A,B), (C), (D,E) 					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a43" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a43" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			(A,B), (C), (D,E) 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		최단연결법(Single Linkage)을 사용하여 학생들을 3개의 군집으로 나누기 위해 유클리디안 거리를 계산하고, 단계적으로 군집을 형성한다. 가장 거리가 가까운 D와 E가 결합되고 그 다음으로 가까운 거리인 B와 A가 결합되어 최종적으로 (A,B) , (C), (D,E)인 3개의 군집이 형성 된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				최단연결법은 군집 간의 가장 가까운 거리를 기준으로 군집을 형성하는 방법입니다. 이 방법은 데이터 포인트 간의 유클리디안 거리를 사용하여 가장 가까운 두 군집을 합치는 방식으로 진행됩니다.<br>
   1. (A,C), (B), (D,E): A와 C가 가장 가까운 거리로 묶여 있지만, B와 D가 각각 다른 군집에 포함되어 있어 최단연결법의 원칙에 맞지 않습니다.<br>
   2. (A,D), (B), (C,E): A와 D가 묶이는 것은 거리상 부적절하며, C와 E가 묶이는 것도 최단연결법의 거리 기준에 부합하지 않습니다.<br>
   3. (A,E), (C), (B,D): A와 E가 묶이는 것은 거리상 부적절하며, B와 D가 묶이는 것도 최단연결법의 거리 기준에 부합하지 않습니다.<br>
   4. (A,B), (C), (D,E): A와 B, D와 E가 각각 가장 가까운 거리로 묶여 최단연결법의 원칙에 부합합니다.<br>
			</div>
			<div class="t2">
									#최단연결법									# 유클리디안 거리									# 군집화							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6532);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">44.</span>
			<span class="tt1t1">
				아래 그림은 평균연결법을 통한 계층적 군집화 예제이다. 데이터 분석 목적 상 Height값을 1.5를 기준으로 하위 군집을 구성할 때 다음 중 생성된 하위 군집을 가장 잘 나타낸 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=73e16f3f-6b98-b49f-0a30-e6136faad473.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/73e16f3f-6b98-b49f-0a30-e6136faad473.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d}, {e,j}, {c}, {g,i} 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d}, {e,j}, {c,g,i} 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d,e,j}, {c,g,i} 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			{h,a,f}, {b,d,e,j}, {c}, {g,i}					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a44" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a44" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			{h,a,f}, {b,d,e,j}, {c}, {g,i}			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		평균연결법을 사용한 계층적 군집화에서 Height 값이 1.5일 때, 해당 값 이하의 거리로 연결된 데이터들을 하나의 군집으로 묶는다. 따라서 계층적 군집화를 통해 생성된 덴드로그램에서 주어진 Height 값 1.5를 기준으로 가지를 나누어 군집을 생성한다.  h,a,f는 한 군집을 형성, b,d,e,j는 한 군집으로 묶임, c는 독립적으로 남음, g,i는 한 군집으로 묶이므로 4번 선택지가 정답이다				</div>
        
		<!-- 비기봇 해설 -->
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6533);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">45.</span>
			<span class="tt1t1">
				비계층적 군집 방법의 기법인 k-means Clustering의 경우 이상값(Outlier)에 민감하여 군집 경계의 설정이 어렵다는 단점이 존재한다. 이러한 단점을 극복하기 위해 등장한 비계층적 군집 방법으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			PAM(Partitioning Around Medoids)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			혼합 분포 군집(Mixture Distribution Clustering) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Density based Clustering					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Fuzzy Clustering					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a45" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a45" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			PAM(Partitioning Around Medoids)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		PAM은 k-means 클러스터링에서 이상값에 민감한 단점을 극복하기 위해 평균 대신 중앙값(medoids)을 사용하여 군집을 형성한다. 혼합 분포 군집은 데이터가 특정 분포를 따른다고 가정하며, Density-based Clustering은 밀도 기반 방법이고, Fuzzy Clustering은 데이터가 여러 군집에 속할 수 있도록 하는 기법이다. 이상값 문제 해결에는 PAM이 적합하다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
비계층적 군집 방법 중 k-means는 효율적이지만 이상값에 민감하다는 단점이 있다. 이를 극복하기 위한 다양한 기법 중 PAM은 대표 객체 기반의 중심 선택을 통해 이 문제를 보완합니다.<br>
<br>
1. PAM(Partitioning Around Medoids)<br>
: PAM은 k-means처럼 군집 개수를 미리 정하지만, 중심을 평균이 아닌 실제 데이터 중 대표 객체인 medoid로 선택합니다. 이로 인해 이상값의 영향을 덜 받으며, 군집 경계의 안정성이 높아지는 장점이 있습니다. 따라서 k-means의 단점을 극복할 수 있는 가장 대표적인 비계층적 군집 기법으로 적절합니다.<br>
<br>
2. 혼합 분포 군집(Mixture Distribution Clustering)<br>
: 혼합 분포 군집은 주로 가우시안 혼합모형(GMM)처럼 확률 기반으로 각 데이터가 어느 군집에 속할 확률을 계산하는 방식입니다. 이는 이상값 문제를 직접적으로 해결하기 위한 목적보다는 군집 간의 불확실성을 모델링하기 위한 방식입니다.<br>
<br>
3. Density based Clustering<br>
: DBSCAN과 같은 밀도 기반 군집화는 이상값에 강인한 특성이 있지만, 이 문제는 '비계층적' 군집 기법 중에서 k-means의 단점을 보완하는 방법을 묻고 있으므로, DBSCAN은 일반적으로 비계층적 군집에 포함되지 않으며, 문제 조건과는 다소 맞지 않습니다.<br>
<br>
4. Fuzzy Clustering<br>
: 퍼지 군집화는 하나의 데이터가 여러 군집에 속할 수 있도록 소속 확률을 부여하는 방식입니다. 이는 이상값을 처리하는 데 직접적인 목적을 가진 기법은 아니며, 애매한 경계를 허용하기 위한 방식입니다.<br>
<br>
따라서 정답은 '1. PAM(Partitioning Around Medoids)'입니다.<br>
			</div>
			<div class="t2">
									#비계층적 군집									# k-means Clustering									# 이상값									# Density based Clustering							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6534);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">46.</span>
			<span class="tt1t1">
				다음 중 이상값 자료에 민감한 k-평균 군집의 단점을 보완하기 위해 평균 대신 사용되는 것으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			중앙값					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최대값					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조화평균					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가중평균					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a46" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a46" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			중앙값			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-means 군집은 평균을 중심으로 데이터를 분할하므로 이상값에 민감하다. 이를 보완하기 위해 평균 대신 중앙값을 사용하면 이상값의 영향을 줄일 수 있다. 최대값, 조화평균, 가중평균은 이상값의 영향을 줄이는 데 적합하지 않다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분석에서 이상값의 영향을 줄이기 위해 평균 대신 중앙값을 사용하는 것이 적절합니다. 중앙값은 데이터의 중간값을 사용하여 이상값의 영향을 최소화할 수 있습니다. <br>
   1. 중앙값: 중앙값은 데이터의 중간값을 나타내며, 이상값에 덜 민감하여 k-평균 군집의 단점을 보완하는 데 적합합니다.<br>
   2. 최대값: 최대값은 데이터의 가장 큰 값을 나타내며, 이상값에 매우 민감하여 군집화에 부적절합니다.<br>
   3. 조화평균: 조화평균은 비율 데이터에 적합하지만, 이상값에 민감하여 군집화에 적절하지 않습니다.<br>
   4. 가중평균: 가중평균은 각 데이터에 가중치를 부여한 평균으로, 이상값의 영향을 줄이지 못합니다.<br>
			</div>
			<div class="t2">
									#이상값									# k-평균 군집									# 중앙값							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5686);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">47.</span>
			<span class="tt1t1">
				다음은 k-평균 군집분석의 수행 절차이다. 아래에서 순서가 가장 적절한 것은?					
					<span class="tt1t1">
						가. 각 데이터를 가장 가까운 초기 중심점에 할당한다.<br>
나. 중심점 위치의 변화가 매우 작아지거나 사전에 정한 반복 횟수에 도달할 때까지 진행한다.<br>
다. 군집의 초기 중심으로 k개의 데이터를 무작위로 선택한다.<br>
라. 군집 내 데이터를 기준으로 중심 위치를 새롭게 계산한다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			다 → 라 → 가 → 나 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가 → 다 → 라 → 나 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가 → 라 → 다 → 나 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다 → 가 → 라 → 나					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a47" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a47" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			다 → 가 → 라 → 나			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-means 군집분석의 절차는 군집의 초기 중심으로 k개의 데이터를 무작위로 선택하고 각 데이터를 가장 가까운 초기 중심점에 할당하며 군집 내 데이터를 기준으로 중심 위치를 새롭게 계산한다. 마지막으로 중심점의 변화가 매우 작아지거나 정해진 반복 횟수에 도달할 때까지 반복한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				k-평균 군집분석(K-Means Clustering)은 데이터를 군집화하기 위해 초기 중심점을 설정한 뒤, 각 데이터를 가장 가까운 중심점에 할당하고 중심점을 반복적으로 갱신하는 과정으로 이루어집니다. 중심점의 변화가 거의 없거나 사전에 정한 반복 횟수에 도달하면 알고리즘이 종료됩니다.<br>
<br>
가. 각 데이터를 가장 가까운 초기 중심점에 할당한다.<br>
:각 데이터 포인트를 유클리드 거리 또는 다른 거리 기준을 사용하여 가장 가까운 중심점에 할당합니다. 이 과정에서 군집이 형성됩니다.<br>
<br>
나. 중심점 위치의 변화가 매우 작아지거나 사전에 정한 반복 횟수에 도달할 때까지 진행한다.<br>
: 중심점의 갱신이 멈추거나 변화가 미미할 때까지, 또는 사전에 정한 반복 횟수에 도달할 때까지 위 과정을 반복합니다.<br>
<br>
다. 군집의 초기 중심으로 k개의 데이터를 무작위로 선택한다.<br>
: 알고리즘의 첫 번째 단계로, k개의 초기 중심점을 무작위로 선택합니다. 이 단계는 초기 군집을 정의하는 데 필수적입니다.<br>
<br>
라. 군집 내 데이터를 기준으로 중심 위치를 새롭게 계산한다.<br>
: 각 군집 내 데이터의 평균 위치를 계산하여 중심점을 갱신합니다. 이는 군집의 중심이 데이터 분포를 반영하도록 하는 단계입니다.<br>
<br>
따라서, k-평균 군집분석은 다 → 가 → 라 → 나 순서로 진행됩니다.<br>
			</div>
			<div class="t2">
									#k-평균 군집분석									# 초기 중심점									# 군집 갱신							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6539);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">48.</span>
			<span class="tt1t1">
				다음 중 k-means 군집의 단점으로 가장 부적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			볼록한 형태가 아닌 군집이 존재하면 성능이 떨어진다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사전에 주어진 목적이 없으므로 결과 해석이 어렵다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			잡음이나 이상값에 영향을 많이 받는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a48" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a48" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			한번 군집이 형성되면 군집내 객체들은 다른 군집으로 이동할 수 없다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		k-means 군집화는 각 데이터가 가장 가까운 군집 중심으로 반복적으로 재할당되므로, 군집 내 객체들이 다른 군집으로 이동할 가능성이 항상 존재한다. 나머지 선택지들은 k-means의 단점으로, 비볼록 형태의 군집 성능 저하, 결과 해석의 어려움, 이상값과 잡음에 민감함 등이 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				k-means 군집화의 단점은 주로 군집의 형태, 잡음 및 이상값에 대한 민감성, 그리고 결과 해석의 어려움에 있습니다.  <br>
   1. k-means는 볼록한 형태의 군집에 적합하며, 비볼록한 군집에서는 성능이 떨어질 수 있습니다.  <br>
   2. k-means는 비지도 학습 방법으로, 사전에 주어진 목적이 없어 결과 해석이 어렵습니다.  <br>
   3. k-means는 잡음이나 이상값에 민감하여, 이러한 데이터가 있을 경우 군집화 결과에 영향을 미칩니다.  <br>
   4. k-means는 반복적인 재할당 과정을 통해 객체가 다른 군집으로 이동할 수 있으므로, 이 설명은 부적절합니다.<br>
			</div>
			<div class="t2">
									#k-means									# 군집화									# 비지도 학습									# 이상값									# 군집 이동							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5591);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">49.</span>
			<span class="tt1t1">
				혼합분포모형의 최대 가능도 추정량(Maximum Likelihood Estimation)을 계산하기 위한 알고리즘으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			k-means 알고리즘					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Naive Bayes 알고리즘					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			EM 알고리즘 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Decision Tree 알고리즘					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a49" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a49" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			EM 알고리즘 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		혼합분포모형(Mixture Model)의 최대 가능도 추정(Maximum Likelihood Estimation)을 계산하기 위해 주로 사용하는 알고리즘은 EM 알고리즘이다. 이 알고리즘은 반복적으로 기대(E-step)와 최대화(M-step) 단계를 수행하여 파라미터를 추정한다. k-means는 중심 기반 군집화, Naive Bayes는 조건부 확률 기반 분류, Decision Tree는 분류/회귀 트리를 생성하는 알고리즘으로, 혼합분포모형과 직접적인 관련은 없다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				혼합분포모형의 최대 가능도 추정량을 계산하기 위해서는 EM 알고리즘이 적합합니다. EM 알고리즘은 관측되지 않은 데이터가 있는 경우에도 최대 가능도 추정을 수행할 수 있는 알고리즘으로, 혼합분포모형의 매개변수를 추정하는 데 자주 사용됩니다.<br>
<br>
1. k-means 알고리즘<br>
: k-means는 클러스터링 알고리즘으로, 데이터를 k개의 군집으로 분할합니다. 이는 혼합분포모형과는 달리 각 데이터 포인트가 특정 군집에만 속한다고 가정하므로 확률적 추정을 포함하지 않습니다.   <br>
<br>
2. Naive Bayes 알고리즘<br>
: Naive Bayes는 베이즈 정리를 기반으로 한 분류 알고리즘으로, 클래스 간의 조건부 확률을 계산합니다. 이는 혼합분포모형의 최대 가능도 추정을 수행하는 알고리즘이 아닙니다.<br>
<br>
3. EM 알고리즘<br>
: EM 알고리즘은 혼합분포모형의 최대 가능도 추정을 위한 대표적인 알고리즘으로, 다음과 같은 과정을 반복하며, 수렴할 때까지 MLE를 계산합니다.<br>
• E-Step(기대 단계): 숨겨진 변수의 기대값을 계산합니다.<br>
• M-Step(최대화 단계): 숨겨진 변수의 기대값을 고정하여 매개변수를 최적화합니다.<br>
<br>
4. Decision Tree 알고리즘<br>
: Decision Tree는 데이터 분류와 회귀 분석에 사용되는 비확률적 알고리즘으로, 최대 가능도 추정과는 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#혼합분포모형									# 최대 가능도 추정									# EM 알고리즘							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6540);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">50.</span>
			<span class="tt1t1">
				다음 중 EM 알고리즘의 진행 과정 중 임의의 파라미터 값을 정한 후, Z의 기대치를 계산하는 단계는 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			파라미터 추정 단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			E-단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			M-단계					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조건부 기댓값 대입 단계					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a50" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a50" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			E-단계			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		EM 알고리즘의 E-단계는 현재의 파라미터 값을 바탕으로 Z의 기대값(잠재 변수의 분포)을 계산하는 단계이다. 이후 M-단계에서 파라미터 값을 업데이트하며, 이 과정을 반복하여 수렴에 도달한다. "파라미터 추정 단계"와 "조건부 기댓값 대입 단계"는 명확하지 않은 설명으로, EM 알고리즘의 공식 단계명과는 맞지 않다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				EM 알고리즘은 기대값 계산(E-step)과 최대화(M-step)를 반복하여 파라미터를 추정하는 과정입니다. 이 중 E-단계는 주어진 파라미터 값으로 숨겨진 변수의 기대값을 계산하는 단계입니다.<br>
   1. 파라미터 추정 단계: 이는 EM 알고리즘의 전체 과정에 해당하며, 특정 단계가 아닙니다. E-단계와 M-단계를 반복하여 파라미터를 추정하는 과정 전체를 의미합니다.<br>
   2. E-단계: 주어진 파라미터 값으로 숨겨진 변수의 기대값을 계산하는 단계입니다. 이 단계에서는 데이터와 현재 파라미터 값을 이용하여 숨겨진 변수의 기대치를 계산합니다.<br>
   3. M-단계: E-단계에서 계산된 기대값을 사용하여 파라미터를 업데이트하는 단계입니다. 이 단계는 파라미터를 최대화하는 과정에 해당합니다.<br>
   4. 조건부 기댓값 대입 단계: 이는 E-단계의 다른 표현일 수 있지만, 일반적으로 사용되는 용어가 아닙니다. E-단계에서 조건부 기댓값을 계산하지만, '대입'이라는 표현은 사용되지 않습니다.<br>
			</div>
			<div class="t2">
									#EM 알고리즘									# E-단계									# 기대값 계산									# 파라미터 추정							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6183);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">51.</span>
			<span class="tt1t1">
				SOM(Self-Organizing Map) 모델에 대한 설명으로 적절하지 않은 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			SOM은 데이터의 군집화를 위한 신경망 모델이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			입력층의 뉴런은 경쟁층에 있는 뉴런들과 부분적으로(locally) 연결되어 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			경쟁 학습 방식을 사용하여 뉴런 간 연결 강도를 조정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SOM은 입력 데이터에 비선형적인 구조를 반영하는 데 사용된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a51" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a51" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			입력층의 뉴런은 경쟁층에 있는 뉴런들과 부분적으로(locally) 연결되어 있다. 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		SOM(Self-Organizing Map)은 신경망을 이용한 군집화 기법으로, 입력층의 뉴런은 경쟁층에 있는 모든 뉴런들과 완전히 연결되어 있다. SOM은 경쟁 학습 방식을 사용하여 뉴런 간 연결 강도를 조정하며, 비선형 데이터 구조를 반영하는 데 유용하다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				SOM(Self-Organizing Map)은 데이터의 군집화를 위한 신경망 모델로, 경쟁 학습 방식을 사용하여 뉴런 간의 연결 강도를 조정합니다. 그러나 입력층의 뉴런은 경쟁층에 있는 뉴런들과 부분적으로 연결되어 있지 않고, 모든 입력 뉴런이 경쟁층의 모든 뉴런과 연결되어 있습니다.<br>
<br>
1. SOM은 데이터의 군집화를 위한 신경망 모델이다.<br>
: SOM은 데이터의 군집화 및 시각화에 사용되는 대표적인 신경망 모델로, 고차원 데이터를 저차원(2D 또는 3D)으로 변환하여 데이터의 구조를 시각적으로 이해할 수 있도록 돕습니다.<br>
<br>
2. 입력층의 뉴런은 경쟁층에 있는 뉴런들과 부분적으로(locally) 연결되어 있다.<br>
: SOM에서 입력층의 뉴런은 경쟁층의 모든 뉴런과 완전 연결(fully connected) 구조를 가집니다. 이 연결은 데이터의 학습과 군집화에 사용되며, 부분적 연결은 SOM의 구조와 일치하지 않습니다.<br>
<br>
3. 경쟁 학습 방식을 사용하여 뉴런 간 연결 강도를 조정한다.<br>
: SOM은 경쟁 학습(Competitive Learning)을 통해 각 뉴런이 입력 데이터에 얼마나 가까운지(유사성)를 기준으로 학습합니다. 가장 가까운 뉴런(BMU, Best Matching Unit)과 이웃 뉴런들의 가중치를 조정하는 방식으로 학습이 이루어집니다.<br>
<br>
4. SOM은 입력 데이터에 비선형적인 구조를 반영하는 데 사용된다.<br>
: SOM은 비선형 구조를 반영하여 데이터를 저차원 공간에 투영하기 때문에, 복잡한 데이터의 내재적 패턴을 이해하는 데 유용합니다.<br>
			</div>
			<div class="t2">
									#SOM									# 경쟁 학습									# 완전 연결									# 비지도 학습							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5637);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">52.</span>
			<span class="tt1t1">
				다음 중 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 변환하여 지도 형태로 구성하는 클러스터링 기법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			주성분 분석(Principal Component Analysis, PCA)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random Forest)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			K-평균 군집화(K-means clustering)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자기조직화지도(Self-Organizing Map)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a52" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a52" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			자기조직화지도(Self-Organizing Map)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		SOM(Self-Organizing Map)은 고차원의 데이터를 이해하기 쉬운 저차원의 지도 형태로 변환하는 군집화 기법이다. 주성분 분석(PCA)은 선형 변환을 통해 데이터의 차원을 축소하는 방법이고, 랜덤포레스트는 앙상블 학습 기법이며, k-means는 중심 기반의 군집화 방법이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				고차원의 데이터를 저차원의 형태로 변환하여 시각적으로 이해하기 쉽게 만드는 기법은 자기조직화지도(Self-Organizing Map)입니다. 이는 고차원 데이터를 저차원으로 변환하여 시각적으로 이해하기 쉽게 만드는 비지도 학습 방법입니다.<br>
<br>
1. 주성분 분석(Principal Component Analysis, PCA)<br>
: 주성분 분석은 고차원 데이터를 저차원으로 축소하는 기법이지만, 지도 형태로 구성하지는 않습니다. 주로 데이터의 분산을 최대화하는 방향으로 차원을 축소합니다.<br>
<br>
2. 랜덤포레스트(Random Forest)<br>
: 랜덤포레스트는 여러 개의 의사결정 트리를 결합하여 예측 성능을 높이는 앙상블 기법으로, 클러스터링 기법이 아닙니다. 주로 분류와 회귀 문제에 사용됩니다.<br>
<br>
3. K-평균 군집화(K-means clustering)<br>
: K-평균 군집화는 데이터를 K개의 클러스터로 나누는 비지도 학습 방법으로, 저차원 변환보다는 데이터의 중심을 찾는 데 중점을 둡니다. 지도 형태로 변환하지 않습니다.<br>
<br>
4. 자기조직화지도(Self-Organizing Map)<br>
: 자기조직화지도는 고차원 데이터를 저차원으로 변환하여 시각적으로 이해하기 쉽게 만드는 클러스터링 기법입니다. 이는 뉴런의 배열을 통해 데이터의 구조를 시각적으로 표현합니다.<br>
			</div>
			<div class="t2">
									#고차원 데이터									# 저차원 변환									# 자기조직화지도									# 클러스터링							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6541);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">53.</span>
			<span class="tt1t1">
				군집분석 시 데이터의 단위가 다를 경우 사용하는 기법으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			정규화 (Normalization)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			표준화 (Standardization)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			원핫 인코딩 (One-Hot Encoding)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스케일링 (Scaling)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a53" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a53" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			원핫 인코딩 (One-Hot Encoding)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		군집분석에서 데이터의 단위가 다를 경우, 정규화(Normalization), 표준화(Standardization), 스케일링(Scaling) 등의 방법을 사용해 변수의 스케일 차이를 조정한다. 원핫 인코딩은 범주형 데이터를 수치형으로 변환하는 기법으로, 단위 조정과 직접적으로 관련이 없다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집분석에서 데이터의 단위가 다를 경우, 데이터를 동일한 기준으로 맞추기 위해 정규화, 표준화, 스케일링 등의 기법을 사용합니다. 이는 데이터의 크기나 범위를 조정하여 분석의 정확성을 높이는 방법입니다. <br>
   1. 정규화 (Normalization): 데이터를 0과 1 사이의 값으로 변환하여 상대적인 크기를 조정하는 방법으로, 데이터 단위 차이를 줄이는 데 효과적입니다.<br>
   2. 표준화 (Standardization): 평균을 0, 표준편차를 1로 변환하여 데이터의 분포를 표준 정규분포로 만드는 방법으로, 단위 차이를 줄이는 데 적합합니다.<br>
   3. 원핫 인코딩 (One-Hot Encoding): 범주형 데이터를 수치형으로 변환하는 방법으로, 데이터의 단위를 맞추는 것과는 관련이 없습니다. 이는 범주형 변수를 처리하는 데 사용되며, 군집분석에서 단위 조정에는 부적절합니다.<br>
   4. 스케일링 (Scaling): 데이터의 범위를 조정하여 단위 차이를 줄이는 방법으로, 군집분석에 적합합니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 데이터 단위									# 정규화									# 표준화									# 스케일링									# 원핫 인코딩							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6149);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">54.</span>
			<span class="tt1t1">
				군집분석의 품질을 정량적으로 평가하는 대표적인 지표로 군집 내의 데이터 응집도(cohesion)와 군집간 분리도(separation)를 계산하여 군집 내의 데이터의 거리가 짧을수록, 군집 간 거리가 멀수록 값이 커지며 완벽한 분리일 경우 1의 값을 가지는 지표는?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			실루엣 계수 (Silhouette Score)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다빈치 지수 (Davies-Bouldin Index)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			칼린스키-하라바즈 지수 (Calinski-Harabasz Index)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			엘보우 방법 (Elbow Method)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a54" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a54" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			실루엣 계수 (Silhouette Score)			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		실루엣 계수(Silhouette Score)는 군집 내 데이터 응집도(cohesion)와 군집 간 분리도(separation)를 측정하는 대표적인 군집 품질 평가 지표이다. 값이 1에 가까울수록 군집이 잘 형성된 것을 나타낸다. 다빈치 지수와 칼린스키-하라바즈 지수도 군집 평가 지표지만, 각각 다른 계산 방법을 사용하며, 엘보우 방법은 적절한 군집 개수를 결정하는 데 사용된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집 품질 평가를 위한 대표적인 지표로 실루엣 계수는 응집도와 분리도를 동시에 고려하여 군집화 결과를 측정합니다.<br>
<br>
1. 실루엣 계수 (Silhouette Score)<br>
: 실루엣 계수는 각 데이터 포인트의 평균 응집 거리와 분리 거리를 계산하여 군집화 품질을 측정합니다. 군집 내 데이터 간 거리가 짧고, 군집 간 데이터 간 거리가 멀수록 실루엣 계수 값이 커집니다. 완벽한 분리일 경우 1의 값을 가지며, 군집 품질을 정량적으로 평가하는 데 자주 사용됩니다.<br>
<br>
2. 다빈치 지수 (Davies-Bouldin Index)<br>
: 다빈치 지수는 군집의 분산과 군집 중심 간 거리를 고려하여 군집 품질을 평가하지만, 낮은 값이 좋은 군집 품질을 나타냅니다. 지문에서 설명한 "1의 값을 가지는 지표"와는 다릅니다.<br>
<br>
3. 칼린스키-하라바즈 지수 (Calinski-Harabasz Index)<br>
: 칼린스키-하라바즈 지수는 군집 간 거리와 군집 내 거리의 비율을 측정하며, 값이 클수록 군집 품질이 우수함을 나타냅니다. 그러나 실루엣 계수와는 다른 방식으로 계산됩니다.<br>
<br>
4. 엘보우 방법 (Elbow Method)<br>
: 엘보우 방법은 군집 수를 결정하기 위한 시각적 기법으로, 군집 품질을 정량적으로 평가하지 않습니다. 군집 수에 따른 왜곡(WCSS, Within-Cluster Sum of Squares) 변화를 관찰하여 최적의 군집 수를 찾는 데 사용됩니다.<br>
			</div>
			<div class="t2">
									#실루엣 계수									# 응집도									# 분리도									# 군집 품질 평가							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6025);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">55.</span>
			<span class="tt1t1">
				아래의 표는 A,B,C,D 네 품목의 거래 전표이다. 연관규칙 ‘A→B’의 신뢰도(Confidence)를 구하시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=d354a587-8819-8a1c-e18d-e5f620a84186.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/d354a587-8819-8a1c-e18d-e5f620a84186.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.3					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.4					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.5					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a55" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a55" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			0.5			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		신뢰도는 A와 B를 동시에 포함하는 거래 건수<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="24" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D434 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="3"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>Support</mtext><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><mi>B</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>를 A를 포함하는 모든 거래 건수Support(A)로 나눈 값이다. 따라서 300/600 =0.5, 50% 가 정답이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 데이터 확인<br>
• A의 거래 건수 확인<br>
: {A} = 50<br>
{A, B, D} =250<br>
{A, D} = 200<br>
{A, B, C, D} = 50<br>
총합 = 50 + 250 + 200 + 50 = 600<br>
<br>
• A와 B를 모두 포함하는 거래 건수 확인<br>
: {A, B, D} = 250<br>
{A, B, C, D} = 50<br>
총합 = 250 + 50 = 300<br>
<br>
2. 신뢰도(Confidence)<br>
신뢰도(Confidence)는 A를 포함하는 거래 중에서 B도 포함된 거래의 비율입니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="25" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence</mtext><mo>=</mo><mfrac><mrow><mtext>Support(A</mtext><mo>∩</mo><mtext>B)</mtext></mrow><mtext>Support(A)</mtext></mfrac><mo>=</mo><mfrac><mn>300</mn><mn>600</mn></mfrac><mo>=</mo><mn>0.5</mn><mo stretchy="false">(</mo><mn>50</mn><mi mathvariant="normal">%</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container><br>
<br>
따라서 연관 규칙 A → B의 Confidence는 '4. 50%'입니다.<br>
			</div>
			<div class="t2">
									#연관 규칙									# 신뢰도									# 지지도							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6082);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">56.</span>
			<span class="tt1t1">
				연관규칙 분석은 품목 간 관계를 분석하는 데 사용된다. 다음 중 연관규칙 분석의 단점으로 가장 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			품목 수가 많아질수록 계산량이 급격히 증가한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			세부적인 품목으로 연관규칙을 분석할 경우 의미 없는 결과가 도출될 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			거래 빈도가 적은 품목은 규칙 발견에서 제외될 가능성이 높다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			품목 간의 연관성이 없더라도 직접적인 인과 관계를 정확히 설명할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a56" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a56" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			품목 간의 연관성이 없더라도 직접적인 인과 관계를 정확히 설명할 수 있다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		연관규칙 분석은 품목 간의 관계를 파악하고 규칙을 도출하는 데 유용하지만, 통계적 연관성을 기반으로 하므로 품목 간의 인과 관계를 정확히 설명할 수 없다. 나머지 선택지들은 연관규칙 분석의 단점으로, 계산량 증가, 거래 빈도가 낮은 품목의 배제 가능성, 세분화된 품목 분석 시 의미 없는 결과 도출 등의 문제가 실제로 존재한다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관규칙 분석(Association Rule Analysis)은 장바구니 분석(Market Basket Analysis) 등에서 사용되며, 품목 간 연관성을 발견하는 데 중점을 둔 분석 기법입니다. 주요 평가 지표로는 지지도(Support), 신뢰도(Confidence), 향상도(Lift)가 사용됩니다. 그러나 연관규칙 분석은 계산량 증가, 거래 빈도가 낮은 품목의 규칙 제외, 연관성은 찾을 수 있지만 인과 관계는 설명하지 못하는 등의 한계를 가지고 있습니다.<br>
<br>
1. 품목 수가 많아질수록 계산량이 급격히 증가한다.<br>
: 품목 수가 증가하면 조합 가능한 품목 쌍의 수가 기하급수적으로 늘어나 계산량이 급격히 증가합니다. 이는 연관규칙 분석의 주요 단점 중 하나입니다.<br>
<br>
2. 세부적인 품목으로 연관규칙을 분석할 경우 의미 없는 결과가 도출될 수 있다.<br>
: 분석 품목을 지나치게 세분화하면 연관성이 약하거나 무의미한 규칙이 도출될 가능성이 높습니다. 예를 들어, 지나치게 세부적인 품목 카테고리는 실질적인 인사이트를 제공하지 못할 수 있습니다.<br>
<br>
3. 거래 빈도가 적은 품목은 규칙 발견에서 제외될 가능성이 높다.<br>
: 거래 빈도가 낮은 품목은 지지도(Support)가 낮아 연관규칙에서 제외될 가능성이 높습니다. 이는 연관규칙 분석의 또 다른 한계입니다.<br>
<br>
4. 품목 간의 연관성이 없더라도 직접적인 인과 관계를 정확히 설명할 수 있다.<br>
: 연관규칙 분석은 연관성(Association)을 찾는 기법으로, 인과 관계(Causation)를 설명할 수 없습니다. 예를 들어, A와 B가 자주 함께 구매된다고 해서 A가 B의 구매를 유도했다고 단정할 수 없습니다. 따라서 이 설명은 부적절합니다.<br>
			</div>
			<div class="t2">
									#연관규칙 분석									# 지지도									# 신뢰도							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5525);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">57.</span>
			<span class="tt1t1">
				다음 중 연관분석에 대한 특징으로 가장 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 탐색이 주요 목적일 때도 유용하게 활용될 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석을 위한 계산이 복잡하다는 단점이 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			품목이 지나치게 세분화되면 의미 없는 결과를 도출할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석 결과는 "만약 A라면 B일 확률"과 같은 형태로 표현된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a57" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a57" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			분석을 위한 계산이 복잡하다는 단점이 있다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		연관분석은 데이터 탐색에 유용하고, 분석 결과는 "A라면 B일 확률"과 같은 형태로 표현되며, 품목의 지나친 세분화 시 의미 없는 결과를 초래할 수 있다. 또한 연관분석은 효율적인 알고리즘(Apriori, FP-Growth 등)을 통해 계산 복잡도를 줄일 수 있으므로 계산이 복잡하다는 설명은 부적절하다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관분석은 데이터 내의 항목 간 관계를 찾아내는 분석 기법으로, 주로 데이터 탐색과 패턴 발견에 사용됩니다.  <br>
   <br>
1. 데이터 탐색이 주요 목적일 때도 유용하게 활용될 수 있다.<br>
: 데이터 탐색 시 유용하게 활용될 수 있는 이유는, 연관분석이 데이터 내의 숨겨진 패턴을 발견하는 데 도움을 주기 때문입니다.  <br>
   <br>
2. 분석을 위한 계산이 복잡하다는 단점이 있다.<br>
: 연관분석은 계산이 복잡하지 않으며, 주로 빈도 기반의 간단한 계산을 통해 연관성을 찾습니다.  <br>
   <br>
3. 품목이 지나치게 세분화되면 의미 없는 결과를 도출할 수 있다.<br>
: 품목이 지나치게 세분화되면 분석 결과가 과도하게 세분화되어 실질적인 의미를 잃을 수 있습니다.  <br>
   <br>
4. 분석 결과는 "만약 A라면 B일 확률"과 같은 형태로 표현된다.<br>
: 연관분석의 결과는 "만약 A라면 B일 확률"과 같은 조건부 확률 형태로 표현됩니다.			<br>
			</div>
			<div class="t2">
									#연관분석									# 데이터 탐색									# 계산 복잡성									# 조건부 확률							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5576);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">58.</span>
			<span class="tt1t1">
				연관분석은 상품 간의 관계를 파악하는 데 유용한 기법이다. 다음 설명 중 부적절한 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			Apriori 알고리즘은 최소지지도 조건을 만족하는 항목집합을 찾고, 이를 통해 신뢰도와 향상도가 높은 연관규칙을 도출하는 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석은 판매 데이터를 바탕으로 특정 상품과 함께 자주 구매되는 다른 상품의 패턴을 찾는 데서 시작된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			두 품목이 서로 독립적이라면, 향상도 값은 항상 1로 나타난다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사건들이 어떤 순서로 일어나고 이 사건들 사이에 연관성을 알아내는 것이 시차 연관분석이지만 원인과 결과의 형태로 해석되지는 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a58" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a58" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			사건들이 어떤 순서로 일어나고 이 사건들 사이에 연관성을 알아내는 것이 시차 연관분석이지만 원인과 결과의 형태로 해석되지는 않는다.			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		시차 연관분석은 사건 간의 시간적 순서를 고려한 연관 분석 기법이다. 원인과 결과를 형태로 해석할 수는 있으나, 반드시 인과 관계를 보장하는 것은 아니다. 나머지 선택지들은 Apriori 알고리즘의 핵심 과정, 연관분석의 기본 개념 및 독립성 가정(향상도가 1인 경우 독립적)을 적절히 설명하고 있다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관분석은 상품 간의 관계를 파악하는 데 유용하며, Apriori 알고리즘은 이를 위한 대표적인 방법입니다. 시차 연관분석은 사건의 순서와 연관성을 파악하지만, 원인과 결과의 형태로 해석되지 않는다는 설명은 부적절합니다.   <br>
1. Apriori 알고리즘은 최소지지도 조건을 만족하는 항목집합을 찾고, 이를 통해 신뢰도와 향상도가 높은 연관규칙을 도출하는 방법이다.<br>
: Apriori 알고리즘은 연관분석에서 자주 사용되는 알고리즘으로, 최소지지도와 신뢰도, 향상도를 기반으로 연관규칙을 도출합니다. 설명이 정확합니다.<br>
<br>
2. 연관분석은 판매 데이터를 바탕으로 특정 상품과 함께 자주 구매되는 다른 상품의 패턴을 찾는 데서 시작된다.<br>
: 연관분석의 기본 개념은 특정 상품과 함께 자주 구매되는 다른 상품의 패턴을 찾는 것입니다. 설명이 정확합니다.<br>
<br>
3. 두 품목이 서로 독립적이라면, 향상도 값은 항상 1로 나타난다.<br>
: 두 품목이 독립적이라면 향상도 값은 1로 나타나는 것이 맞습니다. 설명이 정확합니다.<br>
<br>
4. 사건들이 어떤 순서로 일어나고 이 사건들 사이에 연관성을 알아내는 것이 시차 연관분석이지만 원인과 결과의 형태로 해석되지는 않는다.<br>
: 시차 연관분석은 사건의 순서와 연관성을 파악하는 것이지만, 원인과 결과의 형태로 해석되지 않는다는 설명은 부적절합니다. 시차 연관분석은 시간적 순서를 고려한 분석으로 원인과 결과를 파악할 수 있습니다.<br>
			</div>
			<div class="t2">
									#연관분석									# Apriori 알고리즘									# 최소지지도									# 신뢰도									# 향상도									# 시차 연관분석							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6543);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">59.</span>
			<span class="tt1t1">
				아래는 피자와 햄버거의 거래 관계를 나타낸 표로, Pizza/Hamburgers는 피자/햄버거를 포함하는 거래 수를 의미하고 (Pizza)/(Hamburgers)는 피자/햄버거를 포함하지 않은 거래 수를 의미한다. 아래 표에서 피자 구매와 햄버거 구매에 대해 설명한 것으로 가장 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=28f54863-afc8-af7a-ffd4-369cd31b4486.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/28f54863-afc8-af7a-ffd4-369cd31b4486.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지지도가 0.6로 전체 구매 중 햄버거와 피자가 같이 구매되는 경향이 높다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정확도가 0.7로 햄버거와 피자의 구매 관련성은 높다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			향상도가 1보다 크므로 햄버거와 피자 사이에 연관성이 높다고 할 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관 규칙 중 “햄버거 → 피자” 보다 “피자 → 햄버거”의 신뢰도가 더 높다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a59" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a59" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			향상도가 1보다 크므로 햄버거와 피자 사이에 연관성이 높다고 할 수 있다. 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		지지도는 피자와 햄버거를 동시에 구매한 거래 비율로 40%이다. 신뢰도는 햄버거 구매 시 피자를 구매할 확룔이 80%, 피자 구매 시 햄버거를 구매할 확률이 66.7%이다. 향상도는 1.3이므로 햄버거와 피자 구매 간의 양의 연관성이 존재한다고 볼 수 있다. 정확도는 관련이 없는 값이다. 따라서 3번 선택지가 올바르다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 표 데이터 요약<br>
• 피자를 구매한 총 거래 수 = 3,000<br>
• 햄버거를 구매한 총 거래 수 = 2,500<br>
• 피자와 햄버거를 모두 구매한 거래 수 = 2,000<br>
• 전체 거래 수 = 5,000<br>
<br>
2. 지지도(Support)<br>
• "햄버거와 피자를 함께 구매"의 지지도 = <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="26" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mn>2</mn><mo>,</mo><mn>000</mn></mrow><mrow><mn>5</mn><mo>,</mo><mn>000</mn></mrow></mfrac><mo>=</mo><mn>0.4</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
3. 향상도(Lift)<br>
• <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="27" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">향</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">상</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">도</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c4C"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">햄</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">버</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">피</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">자</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">햄</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">버</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">피</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">자</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mfrac size="s"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow style="font-size: 71.4%;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>향상도(Lift)</mtext><mo>=</mo><mfrac><mrow><mtext>P(햄버거</mtext><mo>∩</mo><mtext>피자)</mtext></mrow><mrow><mtext>P(햄버거)</mtext><mo>×</mo><mtext>P(피자)</mtext></mrow></mfrac><mo>=</mo><mfrac><mfrac><mrow><mn>2</mn><mo>,</mo><mn>000</mn></mrow><mrow><mn>5</mn><mo>,</mo><mn>000</mn></mrow></mfrac><mrow><mfrac><mrow><mn>2</mn><mo>,</mo><mn>500</mn></mrow><mrow><mn>5</mn><mo>,</mo><mn>000</mn></mrow></mfrac><mo>×</mo><mfrac><mrow><mn>3</mn><mo>,</mo><mn>000</mn></mrow><mrow><mn>5</mn><mo>,</mo><mn>000</mn></mrow></mfrac></mrow></mfrac></math></mjx-assistive-mml></mjx-container><br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="28" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfrac><mn>0.4</mn><mn>0.3</mn></mfrac><mo>=</mo><mn>1.33</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
4. 신뢰도(Confidence)<br>
• "햄버거 → 피자"의 신뢰도 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="29" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfrac><mrow><mn>2</mn><mo>,</mo><mn>000</mn></mrow><mrow><mn>2</mn><mo>,</mo><mn>500</mn></mrow></mfrac><mo>=</mo><mn>0.8</mn></math></mjx-assistive-mml></mjx-container><br>
• "피자 → 햄버거"의 신뢰도 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="30" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfrac><mrow><mn>2</mn><mo>,</mo><mn>000</mn></mrow><mrow><mn>3</mn><mo>,</mo><mn>000</mn></mrow></mfrac><mo>=</mo><mn>0.67</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
5. 선택지 분석<br>
1. 지지도는 0.6로 전체 구매 중 햄버거와 피자가 같이 구매되는 경향이 높다.<br>
: 계산 결과, 지지도는 0.4이므로 잘못된 설명입니다.<br>
<br>
2. 정확도는 0.7로 햄버거와 피자의 구매 관련성은 높다고 볼 수 있다.<br>
: 정확도는 연관성 평가에서 사용되지 않으며 부적절합니다.<br>
<br>
3. 향상도가 1보다 크므로 햄버거와 피자 사이에 연관성이 높다고 할 수 있다.<br>
: 향상도 1.33으로 1보다 크며, 연관성이 높음을 의미하므로 적절합니다.<br>
<br>
4. 연관규칙 중 “햄버거-&gt;피자” 보다 “피자-&gt;햄버거” 의 신뢰도가 더 높다고 할 수 있다.<br>
: 내용과 반대로 "햄버거 → 피자" 신뢰도가 더 높으므로 틀린 설명입니다.<br>
			</div>
			<div class="t2">
									#향상도									# 신뢰도									# 지지도									# 연관 분석							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5697);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">60.</span>
			<span class="tt1t1">
				연관규칙 분석에서 품목 A의 거래수가 50, 품목 B의 거래수가 30, 품목 A, B가 동시에 포함된 거래수가 20, 전체 거래수가 100일 때 품목 A, B의 지지도를 계산하시오.(단, 반올림하여 소수점 첫째자리까지 표현하시오.)							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.3					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.5					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.8					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a60" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a60" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			0.2			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		지지도는 특정 품목이 거래에 포함된 비율로 계산되며, 품목 A와 B의 지지도는 두 품목이 동시에 포함된 거래 비율이다. 주어진 조건에서 A와 B가 동시에 포함된 거래수는 20이며, 전체 거래수는 100이므로 지지도는 0.2이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 지지도(Support)<br>
지지도는 특정 항목 집합이 전체 거래에서 발생하는 비율로, 아래와 같은 공식을 따릅니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="31" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">전</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">체</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(X→Y)</mtext><mo>=</mo><mfrac><mrow><mtext>거래 건수(X</mtext><mo>∩</mo><mtext>Y)</mtext></mrow><mtext>전체 거래 건수</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
2. 주어진 값<br>
• 거래&nbsp;건수(A∩B)=20<br>
• 전체&nbsp;거래&nbsp;수=100<br>
<br>
3. 지지도<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="32" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(X→Y)</mtext><mo>=</mo><mfrac><mn>20</mn><mn>100</mn></mfrac><mo>=</mo><mn>0.2</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
따라서 정답은 ① 0.2 입니다.<br>
			</div>
			<div class="t2">
									#지지도									# 연관규칙 분석							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6544);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">61.</span>
			<span class="tt1t1">
				아래는 쇼핑몰의 거래내역이다. 연관 규칙 “우유 → 커피”에 대한 지지도(Support)는 얼마인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=ac1245b2-e797-8c78-1da6-c2ff24cc7333.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/ac1245b2-e797-8c78-1da6-c2ff24cc7333.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.1					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.3					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.4					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a61" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a61" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			0.3			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		Support(우유→커피)는 우유와 커피를 포함하는 거래 수를 전체 거래 수로 나눈 값이다. 우유와 커피를 포함한 거래 수는 30이고 전체 거래 수 는 100 이므로 정답은 0.3이 된다.				</div>
        
		<!-- 비기봇 해설 -->
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6028);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">62.</span>
			<span class="tt1t1">
				아래는 커피, 우유, 녹차에 대한 거래 전표이다. 연관규칙 ‘커피→우유’의 향상도(Lift)를 구하시오. (단, 나누어 떨어지지 않을 경우 소수 점 첫째 자리에서 반올림)							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=3f6b59ca-4e1c-bb02-6762-8c4dde70abd3.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/3f6b59ca-4e1c-bb02-6762-8c4dde70abd3.png" alt="문제에 포함된 이미지">
			</a>
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0.33					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.55					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			0.83					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			1					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a62" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a62" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			0.83			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		향상도는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="33" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mfrac size="s"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" style="font-size: 71.4%;"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2026"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mfrac><mn>300</mn><mn>1000</mn></mfrac><mrow><mfrac><mn>600</mn><mn>1000</mn></mfrac><mo>×</mo><mfrac><mn>600</mn><mn>1000</mn></mfrac></mrow></mfrac><mo>=</mo><mfrac><mn>5</mn><mn>6</mn></mfrac><mo>=</mo><mn>0.8333</mn><mo>…</mo></math></mjx-assistive-mml></mjx-container>이므로 0.83이다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 전체 거래 건수 계산<br>
데이터를 통해 모든 거래 건수를 합산하면 아래와 같습니다.<br>
100+100+100+50+200+250+200=1000<br>
<br>
2. P(커피)와 P(우유) 계산<br>
• 커피가 포함된 거래 건수<br>
: {커피}, {커피, 우유}, {커피, 녹차}, {커피, 우유, 녹차} = 100+250+200+50=600<br>
∴ P(커피)=600/1000=0.6<br>
• 우유가 포함된 거래 건수<br>
: {우유}, {커피, 우유}, {우유, 녹차}, {커피, 우유, 녹차} = 100+250+200+50=600<br>
∴ P(우유)=600/1000=0.6<br>
<br>
3. <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="34" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D443 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">커</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">피</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">우</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">유</mjx-utext></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><mtext>커피</mtext><mo>∩</mo><mtext>우유</mtext><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> 계산<br>
• 커피와 우유가 동시에 포함된 거래 건수<br>
: {커피, 우유}, {커피, 우유, 녹차} = 250+50=300<br>
∴ P(커피 ∩ 우유)=300/1000=0.3<br>
<br>
4. 향상도<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="35" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">향</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">상</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">도</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c4C"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">커</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">피</mjx-utext></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">우</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">유</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">커</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">피</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">우</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">유</mjx-utext><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>향상도(Lift)</mtext><mo>=</mo><mfrac><mrow><mtext>P(커피</mtext><mo>∩</mo><mtext>우유)</mtext></mrow><mrow><mtext>P(커피)</mtext><mo>⋅</mo><mtext>P(우유)</mtext></mrow></mfrac><mo>=</mo><mfrac><mn>0.3</mn><mrow><mn>0.6</mn><mo>⋅</mo><mn>0.6</mn></mrow></mfrac><mo>=</mo><mfrac><mn>0.3</mn><mn>0.36</mn></mfrac><mo>=</mo><mn>0.83</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
향상도(Lift) 값은 0.83이므로, 이를 백분율로 표현하면 83%입니다. 따라서 정답은 3. 0.83 입니다.<br>
			</div>
			<div class="t2">
									#향상도(Lift)									# 조건부 확률									# 연관규칙							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6546);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">63.</span>
			<span class="tt1t1">
				다음 중 R에서 연관성 분석을 위해 apriori함수를 활용하여 연관 규칙을 생성하였다. 다음 중 생성된 연관 규칙을 보기 위해 사용되는 함수로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			sort()					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			arule()					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			inspect()					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			apriori()					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a63" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a63" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			inspect()			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		R의 apriori 함수를 사용해 연관 규칙을 생성한 후, 생성된 규칙을 보기 위해서는 inspect() 함수를 사용한다. sort()는 규칙을 정렬하는 데 사용되고, arule()은 존재하지 않는 함수이며, apriori()는 규칙을 생성하는 데 사용된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관성 분석에서 생성된 연관 규칙을 보기 위해서는 규칙을 시각적으로 확인할 수 있는 함수가 필요합니다. "inspect()" 함수는 생성된 연관 규칙을 출력하여 사용자가 직접 확인할 수 있도록 도와줍니다. <br>
   1. sort(): 데이터나 객체를 정렬하는 함수로, 연관 규칙을 직접적으로 출력하는 기능은 없습니다. <br>
   2. arule(): R에서 연관 규칙을 다루는 객체의 클래스 이름으로, 규칙을 출력하는 함수가 아닙니다.<br>
   3. inspect(): 연관 규칙을 시각적으로 확인할 수 있도록 출력하는 함수로, 생성된 규칙을 직접 볼 수 있습니다.<br>
   4. apriori(): 연관 규칙을 생성하는 함수로, 생성된 규칙을 출력하는 기능은 없습니다.<br>
			</div>
			<div class="t2">
									#연관성 분석									# apriori 함수									# inspect 함수									# R 프로그래밍							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class=""></b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6133);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">64.</span>
			<span class="tt1t1">
				소매점에서 상품 배열을 최적화하거나 교차판매를 촉진하기 위해 활용할 수 있는 적절한 데이터 마이닝 기법은?							</span>
		</strong>
		<span class="tt1t1">
				    </span> 
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			텍스트 마이닝(text mining)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			회귀분석(regression analysis)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석(association analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			차원 축소(dimensionality reduction)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a64" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a64" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			연관분석(association analysis) 			</span>
					</div>
        <br>
          
        
				<strong class="tt1">해설</strong>
		<div class="t1">
		연관분석은 소매점에서 상품 배열을 최적화하거나 교차판매를 촉진하기 위해 활용되는 대표적인 데이터 마이닝 기법이다. 텍스트 마이닝은 텍스트 데이터를 분석하는 데 사용되며, 회귀분석은 연속형 변수 간 관계를 분석하는 기법이다. 차원 축소는 데이터의 차원을 줄이는 데 활용된다.				</div>
        
		<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 마이닝 기법 중에서 소매점에서 상품 배열 최적화와 교차판매 촉진에 가장 적합한 것은 "연관분석"입니다. 연관분석은 데이터 내에서 항목 간의 관계를 찾아내어, 예를 들어 어떤 상품이 함께 구매되는지를 분석하여 판매 전략을 수립하는 데 유용합니다. <br>
   <br>
1. 텍스트 마이닝(text mining)<br>
: 텍스트 마이닝은 비정형 데이터인 텍스트 데이터를 분석하여 유용한 정보를 추출하는 기법입니다. 주로 고객 리뷰, 소셜 미디어 분석, 감성 분석 등에 활용되며, 상품 배열 최적화나 교차판매 촉진과는 직접적인 관련이 없습니다.<br>
<br>
2. 회귀분석(regression analysis)<br>
: 회귀분석은 연속형 변수 간의 관계를 분석하는 기법으로, 주어진 독립변수를 사용하여 종속변수를 예측하는 데 활용됩니다. 예를 들어, 상품 가격과 매출 간의 관계를 분석하는 데는 유용하지만, 고객의 구매 패턴을 분석하여 교차판매를 촉진하는 데는 적절하지 않습니다.<br>
<br>
3. 연관분석(association analysis)<br>
: 연관분석은 고객이 함께 구매하는 상품 간의 관계를 분석하는 기법으로, 소매점의 상품 배열 최적화 및 교차판매 촉진에 효과적으로 활용됩니다. 예를 들어, 슈퍼마켓에서 빵과 버터를 함께 구매하는 패턴을 발견하고, 이를 바탕으로 두 제품을 가까이 배치하면 교차판매를 촉진할 수 있습니다.<br>
<br>
4. 차원 축소(dimensionality reduction)<br>
: 차원 축소는 데이터의 차원을 줄여서 분석의 효율성을 높이는 기법으로, 주로 PCA(주성분 분석) 또는 t-SNE와 같은 방법이 사용됩니다. 이는 대규모 데이터에서 중요한 특징을 추출하는 데 유용하지만, 직접적으로 상품 배열을 최적화하거나 교차판매를 촉진하는 데 사용되지는 않습니다.<br>
			</div>
			<div class="t2">
									#연관분석									# 장바구니 분석									# 교차 판매									# 데이터 마이닝							</div>
		</div>
		 
		<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->

<script>/*<![CDATA[*/
	// 20240424.
	// $('#m-help1').show().addClass('loaded');
/*]]>*/</script>


<script>/*<![CDATA[*/
	$('.w1').remove();
	$('.w2').remove();
	$(".tg2").hide()
	
	// 정답보기 토글. 20240702. @m.	
	$('.b2.help').parent().next('.tg2').hide(); // 정답, 해설 모두 감춤
	$('.b2.help').on('click', function(e){
		e.preventDefault();
		$(this).closest('.eg1').next('.tg2').toggle();
	});	
/*]]>*/


</script>

</div>
</body>
</html>