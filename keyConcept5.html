<!-- 

 -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <base href="https://www.dataedupt.kr/">
  <meta charset="UTF-8">
  <title>핵심개념체크 </title>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
</head>
<style>
body {width:100%;}
	.container {width:600px;margin:0 auto}	
	.eg1 {padding:10px 0px; text-align:center;width:100%;}
	.tg2 {border-bottom:1px solid #ddd;padding:5% 5%;}
	.cp1question1 {padding-bottom:12px;}
img {
  width: 100%;
  height: 100%;
  object-fit: contain; /* 또는 cover */
}

</style>
<body>
<div class="container clearfix">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
	</div>

<h3 class="hb1 h3">5장 - 정형 데이터 마이닝 회독</h3>

<!-- cp1question1 -->
<div class="cp1question1">
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">1.</span>
			<span class="tt1t1">
				다음 중 대용량 데이터 속에서 숨겨진 지식 또는 새로운 규칙을 추출해 내는 과정을 일컫는 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지식경영					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정지원시스템					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터웨어하우징					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터마이닝					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a1" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a1" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			데이터마이닝			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				데이터마이닝은 대용량 데이터에서 패턴, 규칙, 지식을 발견하는 과정이다. 지식경영은 조직의 지식을 관리하는 데 초점이 있으며, 의사결정지원시스템은 의사결정을 지원하는 시스템이고, 데이터웨어하우징은 데이터 저장과 관리를 위한 시스템이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				대용량 데이터에서 숨겨진 지식이나 새로운 규칙을 추출하는 과정은 "데이터마이닝"입니다. 이는 데이터 분석 기법을 통해 유용한 정보를 발견하고 이를 기반으로 의사결정을 지원하는 방법입니다. <br>
   1. 지식경영은 조직 내 지식을 관리하고 활용하는 방법으로, 데이터 분석과는 직접적인 관련이 없습니다. 이는 조직의 지식을 체계적으로 관리하여 효율성을 높이는 데 중점을 둡니다.<br>
   2. 의사결정지원시스템은 의사결정을 돕기 위한 시스템으로, 데이터 분석보다는 의사결정 과정에 초점을 맞춥니다. 이는 데이터 분석 결과를 활용하여 의사결정을 지원하는 도구입니다.<br>
   3. 데이터웨어하우징은 대량의 데이터를 저장하고 관리하는 시스템으로, 데이터마이닝과는 다르게 데이터의 저장과 통합에 중점을 둡니다. 이는 데이터를 효율적으로 저장하고 관리하는 데 초점을 맞춥니다.<br>
   4. 데이터마이닝은 대용량 데이터에서 패턴이나 규칙을 발견하여 유용한 정보를 추출하는 과정입니다. 이는 데이터 분석 기법을 활용하여 새로운 지식을 발견하는 데 중점을 둡니다.<br>
			</div>
			<div class="t2">
									#데이터마이닝									# 대용량 데이터									# 지식 추출									# 규칙 발견							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5992);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">2.</span>
			<span class="tt1t1">
				다음 중 비지도 학습 기법이 적합한 사례는 무엇인가?					
					<span class="tt1t1">
						가) 이미지 데이터를 분석해 각 이미지를 특정 카테고리로 자동 분류<br>
나) 고객의 구매 이력을 분석해 유사한 상품을 추천<br>
다) 과거 주택 거래 데이터를 분석해 주택 가격을 예측<br>
라) 고객 구매 데이터를 바탕으로 유사한 행동 패턴을 가진 고객군을 도출<br>
마) 장비 고장 데이터를 활용해 고장 발생 가능성을 예측					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			나, 다					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가, 라					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가, 다					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			나, 라					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a2" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a2" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			나, 라			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				비지도 학습은 데이터에 라벨이 없는 경우 사용되며, 고객의 구매 이력을 바탕으로 유사 상품을 추천하거나 유사한 행동 패턴을 가진 고객군을 도출하는 데 적합하다. 가)와 다)는 분류와 예측 문제로 지도 학습에 해당하며, 마) 역시 지도 학습 문제이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				비지도 학습은 레이블이 없는 데이터를 기반으로 패턴이나 구조를 찾는 기법입니다. 고객의 구매 이력을 분석해 유사한 상품을 추천하는 것은 협업 필터링과 같은 비지도 학습의 사례이며, 고객 구매 데이터를 바탕으로 유사한 행동 패턴을 가진 고객군을 도출하는 것은 클러스터링 기법을 활용한 비지도 학습의 사례입니다.<br>
<br>
가) 이미지 데이터를 분석해 각 이미지를 특정 카테고리로 자동 분류<br>
: 이미지를 특정 카테고리로 분류하는 것은 레이블이 필요한 지도 학습의 분류 문제에 해당합니다. 따라서 비지도 학습에 적합하지 않습니다.<br>
<br>
나) 고객의 구매 이력을 분석해 유사한 상품을 추천<br>
: 고객 구매 이력을 바탕으로 데이터 내에서 유사성을 분석해 추천하는 작업은 군집화와 같은 비지도 학습 기법에 해당합니다. 이는 레이블 없이 데이터 간의 관계를 분석하는 대표적인 사례입니다.<br>
<br>
다) 과거 주택 거래 데이터를 분석해 주택 가격을 예측<br>
: 주택 가격을 예측하는 문제는 레이블(목표 값)인 가격을 예측하는 지도 학습의 회귀 문제에 해당합니다. 따라서 비지도 학습과는 관련이 없습니다.<br>
<br>
라) 고객 구매 데이터를 바탕으로 유사한 행동 패턴을 가진 고객군을 도출<br>
: 고객 데이터를 군집화하여 비슷한 행동 패턴을 가진 그룹을 만드는 작업은 비지도 학습의 대표적인 활용 사례입니다. 이는 데이터를 기반으로 구조를 파악하고 군집을 형성하는 군집화 기법에 해당합니다.<br>
<br>
마) 장비 고장 데이터를 활용해 고장 발생 가능성을 예측<br>
: 고장 발생 여부를 예측하는 문제는 레이블(고장 여부)을 활용하는 지도 학습의 분류 문제에 해당합니다. 비지도 학습과는 관련이 없습니다.<br>
<br>
따라서, 문제의 정답은 '④ 나, 라' 입니다.<br>
			</div>
			<div class="t2">
									#비지도 학습									# 군집화									# 상품 추천							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6731);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">3.</span>
			<span class="tt1t1">
				데이터 마이닝의 목적 중 사람, 상품에 관한 이해를 증가시키기 위한 것으로 데이터의 특징 및 의미를 표현 및 설명하는 기능을 무엇이라고 하는가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			기술(Description) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			예측(Forecast) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			추정(Estimate) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분류(Classification)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a3" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a3" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			기술(Description) 			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				기술(Description)은 데이터를 분석해 특징과 패턴을 이해하고 설명하는 기능으로, 데이터를 요약하여 사람이 이해하기 쉽게 만드는 데 중점을 둔다. 반면, 예측(Forecast)은 미래의 결과를 예측하고, 추정(Estimate)은 특정 값의 추정치를 도출하며, 분류(Classification)은 데이터를 미리 정의된 그룹에 할당하는 기법이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 마이닝의 목적 중 하나는 데이터의 특징 및 의미를 표현하고 설명하는 것입니다. 이는 "기술(Description)"이라고 하며, 데이터의 패턴과 구조를 이해하여 정보를 제공하는 기능입니다. <br>
   1. 기술(Description): 데이터의 특징과 의미를 설명하는 기능으로, 데이터 마이닝의 목적 중 하나입니다. 데이터의 패턴을 파악하고 이해를 돕는 역할을 합니다.<br>
   2. 예측(Forecast): 미래의 결과를 예측하는 기능으로, 데이터의 과거 패턴을 기반으로 미래를 예측하는 데 사용됩니다. 이는 데이터의 설명보다는 미래 예측에 중점을 둡니다.<br>
   3. 추정(Estimate): 특정 값이나 결과를 추정하는 기능으로, 주어진 데이터로부터 결과를 추정하는 데 사용됩니다. 이는 설명보다는 결과 추정에 초점을 맞춥니다.<br>
   4. 분류(Classification): 데이터를 특정 그룹이나 카테고리로 분류하는 기능으로, 데이터의 설명보다는 분류에 중점을 둡니다. 이는 데이터의 특징을 설명하기보다는 그룹화하는 데 사용됩니다.<br>
			</div>
			<div class="t2">
									#데이터 마이닝									# 데이터 설명									# 기술(Description)							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6732);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">4.</span>
			<span class="tt1t1">
				데이터 마이닝 단계 중 모델링 목적에 따라 목적변수를 정리하고 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 단계는? 							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 마이닝 기법의 적용					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			목적 정의					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 가공					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 준비					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a4" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a4" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			데이터 가공			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				데이터 가공은 모델링 목적에 따라 데이터를 정리하고 데이터 마이닝 소프트웨어에 적용할 수 있도록 준비하는 과정이다. 데이터 준비는 더 광범위한 단계를 포함하며, 목적 정의와 데이터 마이닝 기법의 적용은 다른 단계이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 마이닝 단계는 아래와 같습니다.<br>
<br>
1단계: 목적 설정 (목적 정의)<br>
: 데이터 마이닝을 통해 무엇을, 왜 하는지 명확한 목적을 설정하는 단계입니다. 전문가가 참여하여 목적에 따라 사용할 모델과 필요한 데이터를 정의합니다.<br>
<br>
2단계: 데이터 준비<br>
: 데이터 소스를 확보하고, 필요한 데이터를 정리하는 단계입니다. 고객 정보, 거래 정보, 소셜 네트워크 데이터 등 다양한 데이터를 활용하며, IT 부서와 협의하여 데이터 접근 부하를 고려해야 합니다. 데이터 정제를 통해 데이터 품질을 보장하고, 필요 시 데이터를 보강하여 충분한 양의 데이터를 확보해야 합니다.<br>
<br>
3단계: 가공(데이터 가공)<br>
: 모델링 목적에 따라 목적 변수를 정의하는 단계입니다. 필요한 데이터를 데이터 마이닝 소프트웨어가 처리할 수 있도록 변환(정규화, 스케일링, 인코딩 등)하는 과정입니다.<br>
<br>
4단계: 기법 적용(데이터 마이닝 기법의 적용)<br>
: 데이터 마이닝 알고리즘을 적용하여 패턴을 추출하는 과정입니다. 1단계에서 정의한 목적에 맞게 분석을 수행합니다.<br>
<br>
5단계: 검증<br>
: 데이터 마이닝으로 추출된 정보를 검증하는 단계입니다. 테스트 데이터와 과거 데이터를 활용하여 최적의 모델을 선정합니다. 검증이 완료되면, 데이터 마이닝 결과를 실무에 적용하고 성과를 측정하여 추가 수익 및 투자 대비 효과(ROI)를 분석합니다.<br>
<br>
따라서 정답은 ③ 데이터 가공입니다.<br>
			</div>
			<div class="t2">
									#데이터 마이닝									# 데이터 준비									# 모델링									# 목적변수							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6733);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">5.</span>
			<span class="tt1t1">
				다음 중 데이터를 무작위로 두 집단으로 분리하여 실험데이터와 평가데이터로 설정하고 검정을 실시하는 모형 평가방법으로 적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			k-fold 교차 검정					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ROC 그래프					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			홀드아웃 방법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이익도표					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a5" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a5" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			홀드아웃 방법			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				홀드아웃 방법은 데이터를 학습용 데이터와 테스트용 데이터로 무작위로 분리하여 모델을 학습하고 평가하는 간단한 방법이다. K-fold 교차 검정은 데이터를 여러 개의 폴드로 나누어 교차 검증을 수행하는 방법이며, ROC 그래프와 이익도표는 성능 평가를 시각화하는 도구로 사용된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 3번입니다.<br>
<br>
데이터를 무작위로 두 집단으로 분리하여 실험데이터와 평가데이터로 설정하는 방법은 "홀드아웃 방법"입니다.<br>
이는 데이터를 학습용과 테스트용으로 나누어 모델의 성능을 평가하는 기법입니다.<br>
<br>
1. k-fold 교차 검정<br>
: k-fold 교차 검정은 데이터를 k개의 부분으로 나누어, 각 부분을 번갈아가며 검증데이터로 사용하고 나머지를 훈련에 사용하는 반복적 평가 방법입니다. 데이터가 적을 때 더 안정적인 평가를 제공합니다. <br>
<br>
2. ROC 그래프<br>
: ROC 그래프는 모형의 성능을 시각적으로 평가하는 방법으로, 민감도(True Positive Rate) 와 1−특이도(False Positive Rate) 의 관계를 나타냅니다. 하지만 데이터 분할 방법이 아닌 평가 지표 시각화 도구입니다.<br>
<br>
3. 홀드아웃 방법<br>
: 홀드아웃 방법은 데이터를 무작위로 나누어 훈련용(training set) 과 평가용(test set) 으로 구분하고, 모델 학습 후 평가 데이터로 성능을 검정합니다. 일반적으로 70:30 또는 80:20 비율로 분리하며, 문제에서 요구하는 방식입니다.<br>
<br>
4. 이익도표<br>
: 이익도표는 분류 모델의 예측 결과를 이용해 마케팅 효율이나 이익 향상 정도를 시각화하는 평가 도구입니다. 데이터 분리와는 관련이 없습니다.<br>
<br>
<br>
ROC와 이익도표는 시각적 평가 지표이며, k-fold 교차검정은 데이터 분할을 여러 번 반복하는 방법입니다. 단순히 두 집단으로 무작위 분할해 검정하는 방법은 홀드아웃에 해당됩니다.<br>
<br>
따라서 정답은 '3. 홀드아웃 방법' 입니다.<br>
			</div>
			<div class="t2">
									#데이터 분할									# 홀드아웃 방법									# 모형 평가							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5643);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">6.</span>
			<span class="tt1t1">
				데이터 분할에 대한 설명 중 가장 부적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			테스트용 데이터와 학습 데이터는 섞여서는 안된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			학습용 데이터는 모델의 가중치를 조정하는 데 사용된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			테스트용 데이터는 모델 훈련 중간 모델의 성능 평가에 사용된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터가 제한적인 경우, K-Fold 교차검증을 통해 다양한 학습-평가 조합을 활용한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a6" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a6" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			테스트용 데이터는 모델 훈련 중간 모델의 성능 평가에 사용된다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				테스트 데이터는 모델의 최종 평가에 사용되며 성능 평가에 사용되는 데이터는 학습 중간에 사용하는 검증용 데이터이다. 학습용 데이터는 모델 훈련에 사용되고, K-Fold 교차검증은 데이터가 제한적일 때 유용하다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분할의 핵심은 데이터의 역할에 따라 적절히 분리하여 사용하는 것입니다. <br>
<br>
1. 테스트용 데이터와 학습 데이터는 섞여서는 안된다.<br>
: 학습 데이터는 모델이 데이터 패턴을 학습하는 데 사용되며, 테스트 데이터는 학습된 모델의 성능을 독립적으로 평가하기 위해 사용됩니다. 만약 학습 데이터와 테스트 데이터가 섞인다면, 테스트 데이터의 결과는 학습 과정에 영향을 받아 모델의 성능을 과대평가하게 됩니다.<br>
<br>
2. 학습용 데이터는 모델의 가중치를 조정하는 데 사용된다.<br>
: 학습 데이터는 모델이 데이터를 학습하고, 패턴을 찾아내어 가중치를 최적화하기 위해 사용됩니다. 예를 들어, 선형 회귀 모델에서 학습 데이터는 가중치((beta))를 추정하는 데 활용됩니다.<br>
<br>
3. 테스트용 데이터는 모델의 성능 평가에 사용된다.<br>
: 테스트 데이터는 모델의 최종 평가에 사용됩니다. 모델의 학습 중간에 성능을 평가하는 데이터는 검증 데이터(Validation Set)입니다. 검증 데이터는 하이퍼파라미터 튜닝 등 모델의 최적화 과정에서 사용되며, 테스트 데이터는 학습이 완료된 후 모델의 일반화 성능을 평가하는 데 활용됩니다.<br>
<br>
4. 데이터가 제한적인 경우, K-Fold 교차검증을 통해 다양한 학습-평가 조합을 활용한다.<br>
: K-Fold 교차검증은 데이터를 K개의 폴드로 나누고, 학습-검증을 반복하여 모델의 성능을 안정적으로 평가하는 방법입니다. 데이터가 제한적일 때 유용하며, 각 데이터 포인트가 학습과 검증에 모두 사용될 기회를 갖기 때문에 데이터를 효율적으로 활용할 수 있습니다.<br>
			</div>
			<div class="t2">
									#데이터 분할									# 학습 데이터									# 검정 데이터									# 테스트 데이터							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(7210);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">7.</span>
			<span class="tt1t1">
				아래 오분류표에서 F1-score를 구하시오. (값은 분수로 표기)							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=dc4d9724-d8a3-44ef-30e6-5994d6ddc473.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/dc4d9724-d8a3-44ef-30e6-5994d6ddc473.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			1/10					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			1/5					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			3/10					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			2/5					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a7" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a7" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			1/5			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				F1-score는 분류 모델의 성능을 평가하는 지표 중 하나로, 정밀도(Precision)와 재현율(Recall)의 조화 평균이다. 위 모델에서 정밀도는 3/20이고 재현율은 3/10이다. 따라서 이 둘의 조화평균인 F1-score는 2× {(3/20×3/10)/(3/20+3/10)}의 값인 1/5로 계산된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. F1-score 공식<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="0" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c46"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2D"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c65"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c6C"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c6C"></mjx-c></mjx-mtext></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>F1-score</mtext><mo>=</mo><mn>2</mn><mo>×</mo><mfrac><mrow><mtext>Precision</mtext><mo>×</mo><mtext>Recall</mtext></mrow><mrow><mtext>Precision</mtext><mo>+</mo><mtext>Recall</mtext></mrow></mfrac></math></mjx-assistive-mml></mjx-container><br>
​<br>
2. Precision(정밀도)<br>
정밀도는 모델이 예측한 Positive 중에서 실제로 Positive인 비율을 뜻하며, 공식은 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="1" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c></mjx-mtext></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c2B"></mjx-c><mjx-c class="mjx-c46"></mjx-c><mjx-c class="mjx-c50"></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Precision</mtext><mo>=</mo><mfrac><mtext>TP</mtext><mtext>TP+FP</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
• TP(True Positive) = 30<br>
• FP(False Positive) = 170<br>
주어진 값으로 정밀도를 계산해보면 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="2" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c73"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Precision</mtext><mo>=</mo><mfrac><mn>30</mn><mrow><mn>30</mn><mo>+</mo><mn>170</mn></mrow></mfrac><mo>=</mo><mfrac><mn>30</mn><mn>200</mn></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>20</mn></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
3. Recall(재현율)<br>
재현율은 실제로 Positive인 데이터 중에서 모델이 Positive로 올바르게 예측한 비율을 의미하며, 공식은 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="3" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c6C"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c></mjx-mtext></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-c class="mjx-c54"></mjx-c><mjx-c class="mjx-c50"></mjx-c><mjx-c class="mjx-c2B"></mjx-c><mjx-c class="mjx-c46"></mjx-c><mjx-c class="mjx-c4E"></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Recall</mtext><mo>=</mo><mfrac><mtext>TP</mtext><mtext>TP+FN</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
• FN(False Negative) = 70<br>
주어진 값으로 재현율을 계산해보면 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="4" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c52"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c61"></mjx-c><mjx-c class="mjx-c6C"></mjx-c><mjx-c class="mjx-c6C"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mrow><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Recall</mtext><mo>=</mo><mfrac><mn>30</mn><mrow><mn>30</mn><mo>+</mo><mn>70</mn></mrow></mfrac><mo>=</mo><mfrac><mn>30</mn><mn>100</mn></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>10</mn></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
4. F1-score 계산<br>
계산된 정밀도와 재현율을 활용하여 F1-score을 계산하면 아래와 같습니다.<br>
<br>
<br>
분자:<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="5" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mfrac><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>3</mn><mn>20</mn></mfrac><mo>×</mo><mfrac><mn>3</mn><mn>10</mn></mfrac><mo>=</mo><mfrac><mn>9</mn><mn>200</mn></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
분모:<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="6" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mfrac><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mfrac><mn>3</mn><mn>20</mn></mfrac><mo>+</mo><mfrac><mn>3</mn><mn>10</mn></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>20</mn></mfrac><mo>+</mo><mfrac><mn>6</mn><mn>20</mn></mfrac><mo>=</mo><mfrac><mn>9</mn><mn>20</mn></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
F1-score:<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="7" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c39"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo><mjx-mfrac space="3"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mn>2</mn><mo>×</mo><mfrac><mfrac><mn>9</mn><mn>200</mn></mfrac><mfrac><mn>9</mn><mn>20</mn></mfrac></mfrac><mo>=</mo><mn>2</mn><mo>×</mo><mfrac><mn>9</mn><mn>200</mn></mfrac><mo>×</mo><mfrac><mn>20</mn><mn>9</mn></mfrac><mo>=</mo><mn>2</mn><mo>×</mo><mfrac><mn>1</mn><mn>10</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
따라서 정답은 '② 1/5'입니다.<br>
			</div>
			<div class="t2">
									#F1-score									# Precision									# Recall									# 조화평균							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5574);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">8.</span>
			<span class="tt1t1">
				구축된 모델의 과대 또는 과소 적합에 대한 미세조정 절차를 위해 사용되는 데이터는?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			학습용 데이터 (Training Data)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			검증용 데이터 (Validation Data)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			라벨링 데이터 (Labeled Data)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			테스트 데이터 (Test Data)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a8" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a8" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			검증용 데이터 (Validation Data)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				검증용 데이터는 모델의 성능을 평가하고, 과대적합(overfitting)이나 과소적합(underfitting)을 방지하기 위해 하이퍼파라미터를 조정하는 데 사용된다. 학습용 데이터는 모델 훈련에 사용되고, 테스트 데이터는 최종적으로 모델의 성능을 평가하는 데 사용된다. 라벨링 데이터는 지도 학습에서 정답이 제공된 데이터를 뜻한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				모델의 과대적합(overfitting)이나 과소적합(underfitting)을 조정하기 위해 사용하는 데이터는 "검증용 데이터"입니다. 이는 학습 과정에서 모델의 성능을 평가하고 하이퍼파라미터를 조정하는 데 사용됩니다.<br>
<br>
1. 학습용 데이터 (Training Data)<br>
: 학습용 데이터는 모델을 훈련시키는 데 사용되며, 과대적합이나 과소적합을 직접적으로 조정하는 데 사용되지 않습니다. 따라서, 모델의 성능을 평가하기 위한 데이터로는 적절하지 않습니다.<br>
<br>
2. 검증용 데이터 (Validation Data)<br>
: 검증용 데이터는 모델의 성능을 평가하고 하이퍼파라미터를 조정하는 데 사용되므로, 과대적합과 과소적합을 조정하는 데 적합합니다.<br>
<br>
3. 라벨링 데이터 (Labeled Data)<br>
: 라벨링 데이터는 데이터에 정답을 부여한 데이터로, 학습용, 검증용, 테스트 데이터 모두 라벨링 데이터를 포함할 수 있습니다. 따라서, 직접적인 조정 절차와는 관련이 없습니다.<br>
<br>
4. 테스트 데이터 (Test Data)<br>
: 테스트 데이터는 최종 모델의 성능을 평가하는 데 사용되며, 모델의 미세조정에는 사용되지 않습니다. 검증용 데이터와 달리, 하이퍼파라미터 조정에는 사용되지 않습니다.<br>
			</div>
			<div class="t2">
									#과대적합									# 과소적합									# 검증용 데이터									# 하이퍼파라미터 조정							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5636);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">9.</span>
			<span class="tt1t1">
				데이터마이닝에서 자주 사용되는 분석모형 중에 분류모형이 많이 활용된다. 다음 중 분류 모형의 성능을 평가하는데 사용하는 방법이 아닌 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			덴드로그램					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ROC 그래프 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			누적 이익 도표					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정밀도-재현율 곡선					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a9" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a9" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			덴드로그램			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				덴드로그램은 계층적 군집 분석에서 사용되는 시각화 도구로, 분류 모형의 성능 평가에 사용되지 않는다. ROC 그래프, 누적 이익 도표, 정밀도-재현율 곡선은 분류 모형의 성능을 평가하는 데 사용되는 주요 방법이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터마이닝에서 분류 모형의 성능을 평가하는 방법으로는 ROC 그래프, 누적 이익 도표, 정밀도-재현율 곡선 등이 있습니다. 덴드로그램은 주로 군집 분석에서 사용되는 시각화 도구로, 분류 모형의 성능 평가와는 관련이 없습니다.<br>
<br>
1. 덴드로그램<br>
: 군집 분석에서 사용되는 시각화 도구로, 데이터의 계층적 구조를 나타내며 분류 모형의 성능 평가와는 관련이 없습니다.<br>
<br>
2. ROC 그래프<br>
: 분류 모형의 성능을 평가하는 데 사용되며, 민감도와 특이도의 관계를 시각화합니다.<br>
<br>
3. 누적 이익 도표<br>
: 분류 모형의 성능을 평가하는 데 사용되며, 모델의 예측에 따른 누적 이익을 시각화합니다.<br>
<br>
4. 정밀도-재현율 곡선<br>
: 분류 모형의 성능을 평가하는 데 사용되며, 정밀도와 재현율 간의 관계를 시각화합니다.<br>
			</div>
			<div class="t2">
									#분류 모형									# 성능 평가									# 덴드로그램									# ROC 그래프									# 누적 이익 도표									# 정밀도-재현율 곡선							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6050);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">10.</span>
			<span class="tt1t1">
				다음 설명에 맞는 (    )에 들어갈 적절한 용어는 무엇인가?					
					<span class="tt1t1">
						(    )는 분류 분석 모형을 사용하여 분류된 관측치가 각 등급별로 얼마나 포함되는지를 나타내는 도표이다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			혼동 행렬 (Confusion Matrix)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이익도표 (Lift Chart)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			상관 행렬 (Correlation Matrix)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			파이 차트 (Pie Chart)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a10" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a10" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			혼동 행렬 (Confusion Matrix)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				혼동 행렬은 분류 모델의 성능을 평가하는 데 사용되며, 실제 값과 예측 값 간의 관계를 나타낸다. 이익도표는 모델의 유용성을 평가하는 데 사용되며, 상관 행렬은 변수 간의 상관관계를 나타낸다. 파이 차트는 데이터의 비율을 시각화하는 데 사용된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				혼동 행렬(Confusion Matrix)은 분류 모델의 성능을 평가하는 도구로, 실제값과 예측값의 비교를 통해 각 등급별로 얼마나 정확하게 분류되었는지를 확인할 수 있는 도표입니다. 주로 머신러닝의 분류 문제에서 사용되며, TP(참양성), FP(거짓양성), TN(참음성), FN(거짓음성)의 값을 포함합니다.<br>
<br>
1. 혼동 행렬 (Confusion Matrix)<br>
: 혼동 행렬은 모델이 예측한 값과 실제 정답을 비교하여 분류 모델의 성능을 평가하는 행렬입니다. 행은 실제 클래스, 열은 예측 클래스로 구성되며, 네 가지 값이 포함됩니다.<br>
• TP(참양성, True Positive): 실제로 긍정 클래스이며, 모델도 긍정 클래스로 예측한 경우입니다.<br>
• FP(거짓양성, False Positive): 실제로는 부정 클래스지만, 모델이 긍정 클래스로 잘못 예측한 경우입니다.<br>
• TN(참음성, True Negative): 실제로 부정 클래스이며, 모델도 부정 클래스로 예측한 경우입니다.<br>
• FN(거짓음성, False Negative): 실제로는 긍정 클래스지만, 모델이 부정 클래스로 잘못 예측한 경우입니다.<br>
이를 통해 모델이 얼마나 정확하게 예측했는지를 평가할 수 있으며, 모델의 오차를 분석하는 데 필수적인 도구입니다.<br>
<br>
2. 이익도표 (Lift Chart)<br>
: 이익도표(Lift Chart)는 모델의 예측 성능이 무작위 예측보다 얼마나 더 나은지를 평가하는 그래프입니다. 보통 마케팅, 금융 분야에서 특정 고객군을 대상으로 캠페인을 수행할 때 활용됩니다. 하지만 특정 등급별로 관측치가 얼마나 포함되는지를 나타내는 것은 아니므로 혼동 행렬과는 다른 개념입니다.<br>
<br>
3.상관 행렬 (Correlation Matrix)<br>
: 상관 행렬(Correlation Matrix)은 여러 변수 간의 관계를 나타내는 행렬입니다. 주어진 데이터에서 각 변수 간의 상관 계수를 계산하여 표시하며, 변수들 간의 연관성을 분석할 때 사용됩니다. 하지만 상관 행렬은 분류 모델의 성능을 평가하는 데 사용되지 않으므로 본 문제의 정답이 아닙니다.<br>
<br>
4. 파이 차트 (Pie Chart)<br>
: 파이 차트는 전체 데이터에서 각 범주의 비율을 나타내는 원형 차트입니다. 특정 범주가 전체에서 차지하는 비율을 한눈에 파악하는 데 유용하지만, 분류된 관측치가 각 등급별로 얼마나 포함되는지를 나타내는 것은 아닙니다. 따라서 혼동 행렬과는 다른 개념입니다.<br>
			</div>
			<div class="t2">
									#혼동 행렬									# 분류 모델									# 성능 평가							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6740);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">11.</span>
			<span class="tt1t1">
				오분류표(Confusion Matrix)를 사용하여 계산할 수 있는 평가 지표 중 민감도와 동일하며 모형의 완전성(Completeness)을 평가하는 지표는?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			F-1 지표(F1 Score)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정밀도(Precision) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			특이도(Specificity)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			재현율(Recall)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a11" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a11" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			재현율(Recall)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				재현율은 실제로 양성인 데이터 중에서 모델이 양성으로 올바르게 예측한 비율로, 민감도와 동일한 개념이다. 정밀도는 양성으로 예측한 데이터 중에서 실제로 양성인 비율을 나타내며, F-1 지표는 정밀도와 재현율의 조화 평균이다. 특이도는 음성인 데이터를 올바르게 음성으로 예측한 비율이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
오분류표(Confusion Matrix)를 통해 계산할 수 있는 평가 지표 중에서 재현율(Recall)은 실제 양성 중에서 모델이 올바르게 예측한 양성의 비율을 측정합니다. 이는 모형의 완전성(Completeness)을 평가하는 지표로, 민감도(Sensitivity)와 동일한 개념입니다.<br>
<br>
1. F-1 지표(F1 Score)<br>
: F-1 지표는 정밀도와 재현율의 조화 평균으로, 민감도와 동일하지 않습니다. 이는 모델의 균형을 평가하는 지표로, 완전성과는 다른 측면을 평가합니다.<br>
<br>
2. 정밀도(Precision)<br>
: 정밀도는 모델이 양성으로 예측한 것 중 실제로 양성인 비율을 측정하는 지표로, 민감도와는 다른 개념입니다. 이는 모델의 정확성을 평가하는 지표로, 완전성과는 관련이 없습니다.<br>
<br>
3. 특이도(Specificity)<br>
: 특이도는 실제 음성 중에서 모델이 올바르게 예측한 음성의 비율을 측정하는 지표로, 민감도와는 반대되는 개념입니다. 이는 모델의 음성 예측 능력을 평가하는 지표입니다.<br>
<br>
4. 재현율(Recall)<br>
: 재현율은 실제 양성 중에서 모델이 올바르게 예측한 양성의 비율을 측정하며, 민감도와 동일한 개념입니다. 이는 모형의 완전성을 평가하는 지표입니다.<br>
<br>
따라서 정답은 '4. 재현율(Recall)' 입니다.<br>
			</div>
			<div class="t2">
									#오분류표									# 민감도									# 재현율									# 모형 완전성									# 평가 지표							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">데이터 마이닝의 개요</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6096);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">12.</span>
			<span class="tt1t1">
				오분류표(Confusion Matrix)를 활용하여 모형을 평가하는 지표 중 실제값이 FALSE인 관측치 중 예측치가 적중한 정도를 나타내는 지표는?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			민감도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			특이도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정밀도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			재현율					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a12" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a12" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			특이도			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				특이도(Specificity)는 실제값이 FALSE인 관측치 중에서 모델이 올바르게 FALSE로 예측한 비율을 나타낸다. 민감도는 실제값이 TRUE인 관측치 중에서 모델이 올바르게 TRUE로 예측한 비율이고, 정밀도는 양성으로 예측된 것 중에서 실제 양성인 비율이다. 재현율은 민감도와 같은 개념이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				오분류표(Confusion Matrix)에서 특이도는 실제값이 FALSE인 관측치 중 예측치가 적중한 정도를 나타내는 지표입니다. 이는 실제로 Negative인 데이터 중에서 모델이 Negative로 정확히 예측한 비율을 의미합니다. <br>
   <br>
1. 민감도<br>
: 민감도는 실제 TRUE인 경우 중에서 TRUE로 정확히 예측한 비율입니다. 혼동 행렬에서 TP / (TP + FN)으로 계산되며, 문제에서 제시한 "실제값이 FALSE"와는 관련이 없습니다.<br>
<br>
2. 특이도<br>
: 특이도는 실제 FALSE인 경우 중에서 FALSE로 정확히 예측한 비율입니다. 혼동 행렬에서 TN / (TN + FP)로 계산되며, 문제에서 제시된 설명과 일치합니다.<br>
<br>
3. 정밀도<br>
: 정밀도는 TRUE로 예측한 것 중에서 실제 TRUE인 비율을 의미합니다. 혼동 행렬에서 TP / (TP + FP)로 계산되며, 문제에서 제시된 "실제값이 FALSE"와 관련이 없습니다.<br>
<br>
4. 재현율<br>
: 재현율은 민감도와 동일한 지표로, 실제 TRUE인 경우 중에서 TRUE로 정확히 예측한 비율입니다. 혼동 행렬에서 TP / (TP + FN)으로 계산되며, 문제의 설명과 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#혼동 행렬									# 특이도									# 민감도									# 정밀도									# 재현율							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5647);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">13.</span>
			<span class="tt1t1">
				다음 중 생물 진화의 과정을 모방하여 근삿값에 가까운 해답을 도출하는 최적화 탐색 분류 분석 알고리즘은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유전자 알고리즘 (Genetic Algorithm)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			심층 신경망 (Deep Neural Network)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 (Decision Tree)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트 (Random Forest)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a13" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a13" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			유전자 알고리즘 (Genetic Algorithm)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				유전자 알고리즘은 자연 선택과 유전 법칙을 모방하여 최적화 문제를 해결하는 탐색 알고리즘이다. 심층 신경망은 복잡한 데이터 표현을 학습하는 데 사용되며, 의사결정나무와 랜덤 포레스트는 분류와 회귀 문제에 활용되지만, 생물 진화 과정을 모방하지 않는다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				생물 진화의 과정을 모방하여 최적화 문제를 해결하는 알고리즘은 유전자 알고리즘입니다. 이는 자연 선택과 유전적 변이를 통해 점진적으로 해답을 개선하는 방식입니다.<br>
<br>
1. 유전자 알고리즘 (Genetic Algorithm)<br>
: 생물의 진화 과정을 모방하여 최적의 해를 찾는 알고리즘으로, 선택, 교차, 돌연변이 등의 과정을 통해 해답을 개선합니다.<br>
<br>
2. 심층 신경망 (Deep Neural Network)<br>
: 여러 층의 뉴런을 통해 복잡한 패턴을 학습하는 알고리즘으로, 최적화 탐색보다는 패턴 인식에 중점을 둡니다.<br>
<br>
3. 의사결정나무 (Decision Tree)<br>
: 데이터의 속성을 기반으로 분할하여 예측을 수행하는 알고리즘으로, 생물 진화 모방과는 관련이 없습니다.<br>
<br>
4. 랜덤 포레스트 (Random Forest)<br>
: 여러 개의 의사결정나무를 결합하여 예측 성능을 향상시키는 알고리즘으로, 최적화 탐색과는 거리가 멉니다.<br>
			</div>
			<div class="t2">
									#유전자 알고리즘									# 최적화 탐색									# 생물 진화 모방							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5695);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">14.</span>
			<span class="tt1t1">
				아래의 로지스틱 회귀모형에 대한 설명에서 괄호 안에 들어갈 단어는?					
					<span class="tt1t1">
						로지스틱 회귀모형에서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="8" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>의 의미는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="9" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2026"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="2"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-texatom></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mrow data-mjx-texclass="ORD"><mi>n</mi></mrow></msub></math></mjx-assistive-mml></mjx-container>이 주어질 때, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="10" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow></msub></math></mjx-assistive-mml></mjx-container>이 한 단위 증가할 때마다 성공(y=1)의 (      )이/가 증가하는지를 나타낸다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			확률 (Probability)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			오즈 (Odds)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			로그 오즈 (Log Odds)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			오즈비 (Odds Ratio)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a14" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a14" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			오즈 (Odds)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="11" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mrow data-mjx-texclass="ORD"><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>는 로지스틱 회귀모형에서 독립변수가 한 단위 증가할 때 성공(y=1)의 오즈가 얼마나 증가하는지를 나타낸다. 오즈는 사건이 발생할 확률과 발생하지 않을 확률의 비율이며, 확률이나 로그 오즈와는 구분된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				로지스틱 회귀모형은 종속변수가 이항형(성공/실패)인 데이터를 분석하는 데 사용됩니다.<br>
<br>
1. 확률 (Probability)<br>
: 확률은 p로, 사건이 발생할 가능성을 0에서 1 사이의 값으로 나타냅니다. 그러나 로지스틱 회귀모형에서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="12" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>는 확률 자체가 아니라 성공 확률 대비 실패 확률의 비율인 오즈(Odds)와 관련이 있습니다. 즉, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="13" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>는 확률의 변화를 직접 설명하지 않으므로 틀린 설명입니다.<br>
<br>
2. 오즈 (Odds)<br>
: 오즈는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="14" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mfrac><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mi>p</mi><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mfrac></math></mjx-assistive-mml></mjx-container>로 정의되며, 성공 확률 대비 실패 확률의 비율을 의미합니다. 로지스틱 회귀모형에서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="15" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="16" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub></math></mjx-assistive-mml></mjx-container>이 한 단위 증가할 때 오즈가 몇 배 증가하는지를 나타냅니다. 따라서 문제의 정답입니다.<br>
<br>
3. 로그 오즈 (Log Odds)<br>
: 로그 오즈는 오즈의 자연 로그 값으로, 로지스틱 회귀식의 형태는 로그 오즈로 표현됩니다. 로그 오즈의 공식에서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="17" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>β</mi><mn>1</mn></msub></math></mjx-assistive-mml></mjx-container>는 로그 오즈의 변화량을 나타내지만, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="18" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>는 로그 오즈가 아니라 오즈(Odds)의 변화를 설명하므로 부적절합니다.<br>
<br>
4. 오즈비 (Odds Ratio)<br>
: 오즈비는 두 오즈 간의 비율을 나타냅니다. 즉, 두 개의 집단(또는 상황)의 오즈를 비교할 때 사용하는 값으로, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="19" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D452 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D6FD TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>β</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> 자체는 오즈비를 의미합니다. 문제에서 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="20" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub></math></mjx-assistive-mml></mjx-container>이 한 단위 증가할 때마다 어떤 것이 증가하는지를 묻고 있으므로, 정답은 "오즈"가 됩니다.<br>
			</div>
			<div class="t2">
									#로지스틱 회귀모형									# 오즈									# 오즈비							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6741);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">15.</span>
			<span class="tt1t1">
				로지스틱 회귀분석은 독립 변수의 선형 결합을 이용하여 사건의 발생 가능성을 예측하는데 사용되는 통계기법이다. 다음 중 로지스틱 회귀모형의 모형 검정 방법으로 알맞은 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			최소제곱법 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			쌍측검정 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			F-검정 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			카이제곱 검정					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a15" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a15" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			카이제곱 검정			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				로지스틱 회귀분석에서 모형의 적합도를 평가하거나 변수의 유의성을 검정하는 데 카이제곱 검정이 사용된다. 최소제곱법은 회귀분석에 사용되며, 쌍측검정과 F-검정은 로지스틱 회귀모형의 검정 방법이 아니다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				로지스틱 회귀분석은 사건의 발생 가능성을 예측하는 데 사용되며, 모형의 적합성을 검정하기 위해 카이제곱 검정을 사용합니다. <br>
   카이제곱 검정은 관측된 빈도와 기대 빈도 간의 차이를 비교하여 모형의 적합성을 평가하는 데 적합합니다.<br>
   1. 최소제곱법: 최소제곱법은 회귀분석에서 잔차의 제곱합을 최소화하는 방법으로, 주로 선형 회귀분석에 사용됩니다. 로지스틱 회귀모형의 적합성을 검정하는 데는 적절하지 않습니다.<br>
   2. 쌍측검정: 쌍측검정은 두 집단 간의 평균 차이를 검정하는 방법으로, 로지스틱 회귀모형의 적합성을 평가하는 데는 사용되지 않습니다.<br>
   3. F-검정: F-검정은 주로 분산분석에서 사용되는 방법으로, 회귀모형의 설명력을 검정하는 데 사용되지만, 로지스틱 회귀모형의 적합성 검정에는 적합하지 않습니다.<br>
   4. 카이제곱 검정: 카이제곱 검정은 로지스틱 회귀모형의 적합성을 평가하는 데 사용되며, 관측된 데이터와 모형이 예측한 데이터 간의 차이를 검정합니다.<br>
			</div>
			<div class="t2">
									#로지스틱 회귀분석									# 모형 검정									# 카이제곱 검정							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6742);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">16.</span>
			<span class="tt1t1">
				Default 데이터는 10,000명의 신용카드 고객에 대한 체납 여부(default)와 학생여부(student), 카드 잔고(balance), 연봉(income)을 포함하고 있다. 고객의 체납 확률을 예측하기 위한 아래 결과에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=2c9f524e-db0f-80a5-5737-d9581c8cef7c.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/2c9f524e-db0f-80a5-5737-d9581c8cef7c.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			로지스틱 회귀모형을 사용한 결과이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			세 설명변수 모두가 체납확률을 예측하는 데 유익한 영향이 있지는 않다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			카드 잔고와 연봉이 동일한 수준일 때, 학생(studentYes)이 학생이 아닌 고객보다 체납확률이 높다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			해당 분석 결과에 대한 분산분석표를 확인하기 위해서는 anova(model)를 실행하면 된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a16" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a16" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			카드 잔고와 연봉이 동일한 수준일 때, 학생(studentYes)이 학생이 아닌 고객보다 체납확률이 높다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				위 모델은 로지스틱 회귀모형이다. p-value를 살펴보면 studentYes와 balance는 유의수준 5% 내에서 체납 여부에 유의미한 영향을 미친다. 특히, balance는 p-value &lt; 2e-16으로 매우 유의미하며 체납확률에 중요한 영향을 미치는 변수임을 나타낸다. 또한 studentYes의 계수가 -6.468e-01로 음수이므로 학생이 학생이 아닌 고객보다 체납확률이 낮음을 의미한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 로지스틱 회귀모형을 사용한 결과이다.<br>
: 결과에서 family="binomial"로 지정되어 있으므로 로지스틱 회귀모형이 사용되었음을 확인할 수 있습니다. 로지스틱 회귀는 종속변수가 이항(binary)일 때 적합하며, 여기서는 체납 여부(default)를 예측하기 위해 사용되었습니다.<br>
<br>
2. 세 설명변수 모두가 체납확률을 예측하는 데 유익한 영향이 있지는 않다.<br>
: Coefficients 부분에서 p-value를 확인해보면 아래와 같습니다.<br>
• balance: p-value &lt; 2e-16으로 유의미합니다.<br>
• studentYes: p-value = 0.00619로 유의미합니다.<br>
• income: p-value = 0.71152로 유의미하지 않습니다.<br>
카드 잔고(balance)와 학생 여부(studentYes)는 체납 확률에 유의미한 영향을 미치며, 연봉(income)은 유의미하지 않으므로 세 설명변수 모두가 유익한 영향이 있지는 않습니다.<br>
<br>
3. 카드 잔고와 연봉이 동일한 수준일 때, 학생(studentYes)이 학생이 아닌 고객보다 체납확률이 높다.<br>
: Coefficients 부분에서 studentYes의 계수(Estimate)는 -0.6468로 음수입니다. 이는 학생인 고객이 학생이 아닌 고객보다 체납 확률이 낮아지는 경향을 나타냅니다. 카드 잔고(balance)와 연봉(income)이 동일한 수준일 때, 학생의 체납 확률은 오히려 감소합니다. 따라서 "체납 확률이 높다"는 설명은 잘못된 해석입니다.<br>
<br>
4. 해당 분석 결과에 대한 분산분석표를 확인하기 위해서는 anova(model)를 실행하면 된다.<br>
: R에서 anova() 함수는 로지스틱 회귀 결과에서도 분산분석표를 확인할 수 있습니다. 이는 모델 비교 및 변수의 기여도를 평가하는 데 유용합니다.<br>
			</div>
			<div class="t2">
									#로지스틱 회귀분석									# 계수 해석									# 유의미성 판단							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6743);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">17.</span>
			<span class="tt1t1">
				다음 중 K-Nearest-Neighbor의 단점 중 옳지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			k 값을 구하기 어렵다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			수치형 데이터만 분석이 가능하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이상치에 영향을 많이 받는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			차원의 크기가 크면 계산량이 많아진다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a17" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a17" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			수치형 데이터만 분석이 가능하다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				KNN은 수치형 데이터뿐만 아니라 범주형 데이터에도 적용 가능하다. 예를 들어, 범주형 데이터는 원핫 인코딩 후 해밍거리와 같은 거리 측도를 활용하여 적용할 수 있다. 나머지 선택지들은 실제 단점으로, k 값 설정이 어렵고, 이상치에 민감하며, 차원이 커질수록 계산량이 증가하는 문제가 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 2번입니다.<br>
<br>
K-Nearest-Neighbor(KNN)의 단점은 주로 계산량과 데이터 특성에 따른 민감성에 있습니다. 비수치형 데이터에도 KNN을 사용할 수 있으며, 이를 위해 적절한 전처리나 거리 계산 방법을 적용할 수 있습니다.<br>
<br>
1.	k 값을 구하기 어렵다. <br>
: K값이 너무 작으면 노이즈에 민감하고, 너무 크면 경계가 모호해집니다. 최적의 K를 결정하기 위해 교차검증 등 추가 절차가 필요하므로, 단점이 맞습니다.<br>
<br>
2. 수치형 데이터만 분석이 가능하다.<br>
: KNN은 거리(distance) 계산을 기반으로 하지만, 범주형 변수에도 거리 개념(예: 해밍거리)을 적용하거나, 더미 변수(one-hot encoding)로 변환하여 분석할 수 있습니다. 따라서 수치형 데이터만 가능하다는 설명은 틀립니다.<br>
<br>
3. 이상치에 영향을 많이 받는다.<br>
: KNN은 거리 기반이기 때문에, 데이터에 극단값이 존재하면 가까운 이웃의 거리가 왜곡되어 예측 결과가 흔들릴 수 있습니다. 이는 KNN의 단점 중 하나입니다.<br>
<br>
4. 차원의 크기가 크면 계산량이 많아진다.<br>
: 차원이 커질수록 유클리드 거리의 의미가 약화되고(차원의 저주), 모든 학습데이터와의 거리를 계산해야 하므로 연산량이 급격히 증가합니다. KNN의 단점이 맞습니다.<br>
<br>
KNN은 “거리”라는 개념을 사용하는 모델이지, “수치형 변수만” 허용하는 모델이 아닙니다.<br>
<br>
따라서 정답은 '2. 수치형 데이터만 분석이 가능하다.' 입니다.<br>
			</div>
			<div class="t2">
									#K-Nearest-Neighbor									# 단점									# 비수치형 데이터									# 전처리							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6744);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">18.</span>
			<span class="tt1t1">
				다음 중 SVM에 대한 설명 중 틀린 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			SVM은 저차원과 고차원의 데이터에 대해서 모두 잘 작동한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SVM은 생성된 모델에 대한 해석이 어렵다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SVM은 이진분류가 아니어도 적용이 가능하므로 여러 개의 선을 그을 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			SVM은 다른 분석 방법론들보다 계산과정이 빠르다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a18" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a18" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			SVM은 다른 분석 방법론들보다 계산과정이 빠르다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				SVM(Support Vector Machine)은 고차원 데이터에서도 효과적으로 작동하며, 이진분류뿐만 아니라 다중분류에도 적용 가능하다. 하지만 SVM은 계산 과정이 복잡하고 대규모 데이터에 적용할 경우 학습 시간이 오래 걸릴 수 있다는 단점이 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
SVM(Support Vector Machine)은 주로 이진 분류에 사용되며, 고차원 데이터에서 효과적으로 작동하는 알고리즘입니다. 계산 과정은 다른 분석 방법론들보다 복잡할 수 있어, 빠르다고 보기 어렵습니다.<br>
<br>
1. SVM은 저차원과 고차원의 데이터에 대해서 모두 잘 작동한다.<br>
: SVM은 저차원과 고차원의 데이터에 대해 모두 잘 작동하는 특성을 가지고 있습니다. 이는 SVM의 핵심 장점 중 하나로, 데이터의 차원에 관계없이 효과적으로 분류할 수 있습니다.<br>
<br>
2. SVM은 생성된 모델에 대한 해석이 어렵다.<br>
: SVM의 결정 경계는 수학적으로 최적화된 초평면이지만, 각 특징(변수)이 결과에 미치는 영향을 직관적으로 해석하기 어렵습니다.<br>
<br>
3. SVM은 이진분류가 아니어도 적용이 가능하므로 여러 개의 선을 그을 수 있다.<br>
: 기본적으로 SVM은 이진분류 알고리즘이지만, One-vs-One, One-vs-Rest 방식을 통해 다중분류 문제로 확장할 수 있습니다. 따라서 여러 초평면을 형성할 수 있으므로 옳은 설명입니다.<br>
<br>
4. SVM은 다른 분석 방법론들보다 계산과정이 빠르다.<br>
: SVM은 최적화 문제를 풀어야 하며, 특히 데이터가 많거나 차원이 높을수록 계산이 복잡해지고 학습 속도가 느려집니다. 대용량 데이터에서는 의사결정나무, 로지스틱 회귀 등에 비해 훨씬 느린 편입니다.<br>
<br>
<br>
SVM은 고성능이지만 계산 복잡도가 높아 속도가 빠르지 않습니다.<br>
<br>
따라서 정답은 '4. SVM은 다른 분석 방법론들보다 계산과정이 빠르다.' 입니다.<br>
			</div>
			<div class="t2">
									#SVM									# 고차원 데이터									# 이진 분류									# 계산 복잡성							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6745);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">19.</span>
			<span class="tt1t1">
				SVM(Support Vector Machine)에서 커널 함수의 역할은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터의 차원을 축소한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 차원을 증가시킨다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 노이즈를 제거한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터의 분포를 균등하게 만든다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a19" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a19" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			데이터의 차원을 증가시킨다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				커널 함수는 데이터를 고차원 공간으로 변환하여 선형적으로 구분되지 않는 데이터를 선형적으로 분리 가능하게 만든다. 이는 차원을 축소하는 것이 아니라 차원을 확장하여 데이터 간의 패턴을 더 잘 찾을 수 있도록 돕는 역할을 한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				SVM에서 커널 함수는 데이터를 고차원으로 매핑하여 비선형 문제를 선형적으로 분리할 수 있도록 돕는 역할을 합니다. 이는 데이터의 차원을 증가시켜, 선형적으로 분리할 수 없는 데이터를 선형적으로 분리 가능하게 만드는 방법입니다.<br>
   <br>
   1. 데이터의 차원을 축소한다: 커널 함수는 차원을 축소하는 것이 아니라 증가시키는 역할을 합니다. 차원을 축소하는 것은 주성분 분석(PCA)과 같은 기법에서 사용됩니다.<br>
   <br>
   2. 데이터의 차원을 증가시킨다: 커널 함수는 데이터를 고차원 공간으로 매핑하여 비선형 문제를 해결할 수 있게 합니다. 이는 SVM의 핵심 기능 중 하나입니다.<br>
   <br>
   3. 데이터의 노이즈를 제거한다: 커널 함수는 노이즈 제거와는 관련이 없습니다. 노이즈 제거는 데이터 전처리 단계에서 이루어지는 작업입니다.<br>
   <br>
   4. 데이터의 분포를 균등하게 만든다: 커널 함수는 데이터의 분포를 균등하게 만드는 것이 아니라, 차원을 증가시켜 비선형 문제를 해결하는 데 사용됩니다.<br>
			</div>
			<div class="t2">
									#SVM									# 커널 함수									# 고차원 매핑									# 비선형 문제							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">분류분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6746);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">20.</span>
			<span class="tt1t1">
				다음은 베이즈정리에 대한 설명이다. 내용이 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			베이즈 정리는 연역적 추론 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			베이즈 정리 공식은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="21" style="font-size: 107.5%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>B</mtext><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>A</mtext><mo stretchy="false">)</mo><mo>⋅</mo><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mo stretchy="false">)</mo></mrow><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mo stretchy="false">)</mo></mrow></mfrac></math></mjx-assistive-mml></mjx-container>형태이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			P(B|A)는 P(A|B)와 상호 교환이 가능하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			베이즈 정리는 과거 경험과 현재 증거를 기반으로 추정한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a20" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a20" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			베이즈 정리는 과거 경험과 현재 증거를 기반으로 추정한다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				베이즈 정리는 확률을 추론하는 귀납적 방법으로, 과거의 경험(사전 확률)과 현재의 관찰된 증거를 조합하여 새로운 확률(사후 확률)을 추정하는 데 사용된다. 나머지 선택지도 잘못된 베이즈 정리의 정의 또는 공식이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
베이즈 정리는 확률론의 중요한 개념으로, 과거의 경험(사전 확률)과 현재의 증거(가능도)를 결합하여 사건의 사후 확률을 추정하는 방법입니다. 이는 데이터 분석과 머신러닝에서 불확실성을 다루는 데 유용하게 사용됩니다.<br>
<br>
1.베이즈 정리는 연역적 추론 방법이다.<br>
: 연역적 추론(deductive reasoning)은 일반적 법칙으로부터 구체적 사실을 도출하는 방식이며, 베이즈 정리는 귀납적·확률적 추론(inductive reasoning)에 속합니다.<br>
<br>
2. 베이즈 정리 공식은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="22" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>B</mtext><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>A</mtext><mo stretchy="false">)</mo><mo>⋅</mo><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mo stretchy="false">)</mo></mrow><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mo stretchy="false">)</mo></mrow></mfrac></math></mjx-assistive-mml></mjx-container>형태이다.<br>
: 베이즈 정리 공식은 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="23" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac><mjx-num><mjx-nstrut></mjx-nstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-texatom texclass="ORD"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-texatom><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c41"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line></mjx-line><mjx-row><mjx-den><mjx-dstrut></mjx-dstrut><mjx-mrow size="s"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c50"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-mrow></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>B</mtext><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mrow data-mjx-texclass="ORD"><mo stretchy="false">|</mo></mrow><mtext>A</mtext><mo stretchy="false">)</mo><mo>⋅</mo><mtext>P</mtext><mo stretchy="false">(</mo><mtext>A</mtext><mo stretchy="false">)</mo></mrow><mrow><mtext>P</mtext><mo stretchy="false">(</mo><mtext>B</mtext><mo stretchy="false">)</mo></mrow></mfrac></math></mjx-assistive-mml></mjx-container>형태입니다. P(B)와 P(A)가 바뀌어 잘못된 공식이 제시되었습니다.<br>
<br>
3. P(B|A)는 P(A|B)와 상호 교환이 가능하다.<br>
: P(B|A)와 P(A|B)는 서로 다른 조건부 확률로, 상호 교환이 불가능합니다. 두 확률은 각각 다른 사건의 조건부 확률을 나타내므로 혼동해서는 안 됩니다.<br>
<br>
4. 베이즈 정리는 과거 경험과 현재 증거를 기반으로 추정한다.<br>
: 베이즈 정리는 과거의 경험을 사전 확률로, 현재의 증거를 가능도로 사용하여 사후 확률을 추정하는 방법입니다. 이는 베이즈 정리의 핵심 개념을 잘 설명하고 있습니다.<br>
<br>
따라서 정답은 '4. 베이즈 정리는 과거 경험과 현재 증거를 기반으로 추정한다.' 입니다.<br>
			</div>
			<div class="t2">
									#베이즈 정리									# 사전 확률									# 사후 확률									# 조건부 확률									# 가능도							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6747);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">21.</span>
			<span class="tt1t1">
				다음 중 의사결정 나무 모형에서 과대적합되어 현실 문제에 적용할 수 있는 적절한 규칙이 나오지 않는 현상을 방지하기 위해 사용되는 방법으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			가지치기(Pruning)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스테밍(Stemming)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			정지규칙(Stopping rule) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random forest)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a21" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a21" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			가지치기(Pruning)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				가지치기는 의사결정나무의 과대적합을 방지하기 위해 불필요한 분기를 제거하는 작업이다. 정지 규칙은 의사결정 나무의 성장을 멈추는 규칙으로, 과대적합 방지에 일부 도움을 주나 가지치기보다 효과가 약할 수 있으며, 랜덤 포레스트는 앙상블 기법으로, 과대적합 방지에 효과적이지만 단일 의사결정 나무에는 적용되지 않는다. 스테밍은 자연어 처리 분야에서 단어의 어간을 추출하는 기법으로, 의사결정 나무와 관련이 없다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정 나무 모형에서 과대적합을 방지하기 위해 가지치기(Pruning)를 사용합니다. 이는 불필요한 가지를 제거하여 모델의 복잡성을 줄이고 일반화 성능을 향상시키는 방법입니다.<br>
   1. 가지치기(Pruning): 의사결정 나무의 복잡성을 줄여 과대적합을 방지하는 방법으로, 불필요한 노드를 제거하여 모델의 일반화 성능을 향상시킵니다.<br>
   2. 스테밍(Stemming): 단어의 어근을 추출하는 텍스트 전처리 기법으로, 의사결정 나무 모형의 과대적합 방지와는 관련이 없습니다.<br>
   3. 정지규칙(Stopping rule): 모델 학습을 중단하는 기준을 설정하는 방법이지만, 가지치기와 같은 구체적인 과대적합 방지 기법은 아닙니다.<br>
   4. 랜덤포레스트(Random forest): 여러 개의 의사결정 나무를 결합하여 예측 성능을 향상시키는 앙상블 기법으로, 개별 나무의 과대적합을 직접적으로 방지하는 방법은 아닙니다.<br>
			</div>
			<div class="t2">
									#의사결정 나무									# 과대적합									# 가지치기									# 모델 일반화							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6131);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">22.</span>
			<span class="tt1t1">
				의사결정나무 모형에 대한 설명 중 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			의사결정나무 모형은 지도학습 모형으로 상향식 의사결정 흐름을 가지고 있다는 특징을 가지고 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이익도표나 교차 타당성 같은 평가 기법을 사용해 모델의 성능을 평가할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가지치기는 과적합 방지를 위해 불필요하거나 부적절한 분류 규칙을 제거하는 작업이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대출 신용 평가, 의료 진단, 채무 불이행 예측 등 다양한 분야에서 활용될 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a22" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a22" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			의사결정나무 모형은 지도학습 모형으로 상향식 의사결정 흐름을 가지고 있다는 특징을 가지고 있다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				의사결정나무 모형은 지도학습에 속하지만, 상향식이 아니라 하향식(top-down) 방식으로 데이터를 분류한다. 즉, 루트 노드에서 시작하여 리프 노드로 내려가는 방식이다. 2번 선택지는 모델 성능 평가에 사용되는 도구를 정확히 설명하며, 3번 선택지는 가지치기의 정의를, 4번 선택지는 의사결정나무의 활용 범위를 적절히 설명하고 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정나무는 하향식(Top-down) 방식으로 분류 규칙을 생성하며, 상향식(Bottom-up) 의사결정 흐름을 가지지 않습니다.<br>
<br>
1. 의사결정나무 모형은 지도학습 모형으로 상향식 의사결정 흐름을 가지고 있다는 특징을 가지고 있다.<br>
: 의사결정나무는 데이터 분류와 예측에 사용되는 지도학습 모델로, 루트 노드에서 시작해 데이터를 분할하는 하향식 의사결정 흐름(Top-down Decision Making)을 따릅니다. 상향식(Bottom-up)은 데이터를 결합해 나가는 구조로 클러스터링과 같은 비지도학습에서 볼 수 있는 방식입니다. 따라서 "상향식 흐름"이라는 설명은 틀린 내용입니다.<br>
<br>
2. 이익도표나 교차 타당성 같은 평가 기법을 사용해 모델의 성능을 평가할 수 있다.<br>
: 의사결정나무 모형은 모델의 성능을 검증하기 위해 여러 평가 기법을 활용할 수 있습니다. 예를 들어, 이익도표는 각 분류의 성과를 시각적으로 표현하며, 교차 타당성(Cross Validation)은 데이터를 여러 폴드로 나누어 반복적으로 학습과 검증을 수행해 모델의 일반화 성능을 평가합니다.<br>
<br>
3. 가지치기는 과적합 방지를 위해 불필요하거나 부적절한 분류 규칙을 제거하는 작업이다.<br>
: 가지치기(Pruning)는 학습 데이터를 지나치게 세분화하여 발생하는 과적합 문제를 해결하기 위한 대표적인 방법입니다. 불필요하거나 신뢰도가 낮은 하위 분류 규칙(하위 노드)을 제거하여 모델의 복잡성을 줄이고 예측 성능을 개선합니다. 이는 의사결정나무의 중요한 특성 중 하나이며, 적절한 설명입니다.<br>
<br>
4. 대출 신용 평가, 의료 진단, 채무 불이행 예측 등 다양한 분야에서 활용될 수 있다.<br>
: 의사결정나무는 분류 및 예측에 적합한 알고리즘으로, 대출 신용 평가, 의료 진단, 채무 불이행 예측 등에서 널리 사용됩니다. 예를 들어, 대출 신용 평가에서는 고객의 소득, 직업, 신용 기록 등의 정보를 기반으로 대출 가능 여부를 판단하며, 의료 진단에서는 환자의 건강 상태와 관련된 데이터를 분석해 질병 여부를 분류합니다. 이는 의사결정나무가 다양한 분야에서 활용 가능한 알고리즘임을 보여주는 적절한 설명입니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 하향식 의사결정 흐름									# 가지치기									# 모델 성능 평가							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(8493);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">23.</span>
			<span class="tt1t1">
				다음 중 의사결정나무와 가장 관련 없는 내용은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지니 지수					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			결정 정지					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분리 기준					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가지 치기					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a23" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a23" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			결정 정지			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				의사결정나무는 데이터를 분류하거나 예측할 때 분기 기준을 사용하며, 가지 치기(pruning)를 통해 과적합을 방지한다. 지니 지수는 CART 알고리즘에서 불순도를 측정하는 기준으로 사용되므로 의사결정나무와 관련이 있다. 반면 결정 정지는 의사결정 과정을 멈추는 행위를 뜻하며, 이는 특정 알고리즘이나 프로세스에서 사용될 뿐 의사결정나무와 관련이 없다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정나무는 데이터를 분류하거나 회귀 분석을 수행하는 데 사용되는 기법으로, 지니 지수, 분기 기준, 가지 치기와 같은 요소가 관련됩니다.  <br>
1. 지니 지수: 의사결정나무에서 노드의 불순도를 측정하는 데 사용되는 지표로, 분류 문제에서 주로 사용됩니다.  <br>
2. 결정 정지: 의사결정나무와 직접적인 관련이 없는 용어로, 일반적으로 사용되지 않습니다.  <br>
3. 분기 기준: 데이터를 분할하는 기준으로, 의사결정나무의 핵심 요소 중 하나입니다.  <br>
4. 가지 치기: 의사결정나무의 복잡도를 줄이고 과적합을 방지하기 위해 사용되는 기법입니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 지니 지수									# 분기 기준									# 가지 치기							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6755);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">24.</span>
			<span class="tt1t1">
				다음 중 지니지수의 설명 중 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지니지수는 ‘불확실성’을 의미하며 같은 특성을 가진 객체들끼리 잘 모여 있는지를 판단한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지니지수 값이 작을수록 이질적이며 순수도(purit y)가 낮다고 할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지니지수는 데이터의 통계적 분산 정도를 정량화해서 표현한 값이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			지니지수는 이진 분류로 나뉠 때 사용된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a24" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a24" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			지니지수 값이 작을수록 이질적이며 순수도(purit y)가 낮다고 할 수 있다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				지니지수는 불확실성을 의미하며, 특정 클래스에 속하는 데이터가 얼마나 잘 분류되어 있는지를 나타내는 척도이다. 지니지수 값이 작을수록 데이터가 동일한 클래스에 포함될 가능성이 커지며, 이는 순수도가 높은 상태를 의미한다. 또한 지니지수는 데이터의 분산 정도를 정량화한 값으로, 데이터의 불확실성을 측정하기 위한 지표이며 주로 이진 분류 상황에서 사용 된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				지니지수는 데이터의 불확실성을 측정하는 지표로, 주로 분류 문제에서 사용됩니다. 지니지수 값이 작을수록 데이터가 더 순수하며, 같은 특성을 가진 객체들이 잘 모여 있는 것을 의미합니다. <br>
   1. 지니지수는 불확실성을 의미하며, 같은 특성을 가진 객체들끼리 잘 모여 있는지를 판단하는 데 사용됩니다. 이는 지니지수의 본질적인 정의와 일치합니다.<br>
   2. 지니지수 값이 작을수록 순수도가 높다는 것이 맞습니다. 따라서 이 설명은 부적절합니다.<br>
   3. 지니지수는 데이터의 통계적 분산 정도를 정량화해서 표현한 값입니다. 이는 지니지수가 데이터의 다양성을 측정하는 방법을 설명합니다.<br>
   4. 지니지수는 이진 분류 문제에서 주로 사용됩니다. 이는 지니지수가 분류 문제에서의 활용을 설명합니다.<br>
			</div>
			<div class="t2">
									#지니지수									# 불확실성									# 순수도									# 이진 분류							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5780);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">25.</span>
			<span class="tt1t1">
				데이터 분할 시 연속형에서는 분산감소량, 범주형에서는 지니지수를 사용하는 분할 방법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			K-means					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			DBSCAN					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			CART					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			PCA					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a25" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a25" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			CART			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				CART(Classification and Regression Trees)는 의사결정나무의 한 형태로, 연속형 데이터에서는 분산의 감소를 기준으로, 범주형 데이터에서는 지니 지수를 사용해 데이터의 불순도를 줄이는 방식으로 분할한다. K-means, DBSCAN, PCA는 각각 군집화와 차원 축소 기법이므로 적절하지 않다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분할 시 연속형 변수에서는 분산감소량을, 범주형 변수에서는 지니지수를 사용하는 분할 방법은 CART(Classification and Regression Trees)입니다. CART는 의사결정나무 알고리즘 중 하나로, 데이터의 특성에 따라 분할 기준을 다르게 설정하여 예측 모델을 생성합니다.<br>
<br>
1. K-means<br>
:  K-means는 군집화(Clustering) 알고리즘으로, 데이터를 K개의 그룹으로 나누는 비지도 학습 방법입니다. 데이터 분할 시 거리 기반 군집화를 사용하며, 지니지수나 분산 감소량을 기준으로 하지 않습니다.<br>
<br>
2. DBSCAN<br>
: DBSCAN은 밀도 기반 군집화 알고리즘으로, 데이터의 밀집도를 기준으로 군집을 형성합니다. 의사결정나무처럼 데이터를 분할하는 방식이 아니므로 오답입니다.<br>
<br>
3. CART<br>
: CART는 의사결정나무 알고리즘으로, 연속형 변수와 범주형 변수에 따라 각각 분산감소량과 지니지수를 사용하여 데이터를 분할합니다.<br>
<br>
4. PCA<br>
: PCA는 차원 축소(Dimensionality Reduction) 기법으로, 데이터를 분할하는 것이 아닌 변수를 변환하여 주성분(Principal Component)으로 표현하는 방식입니다.<br>
			</div>
			<div class="t2">
									#CART									#  분산 감소량									# 데이터 분할									# 지니지수							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">의사결정나무</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6756);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">26.</span>
			<span class="tt1t1">
				아래는 kyphosis라는 자료를 이용하여 의사결정나무 분석을 수행한 결과이다. 결과에 대한 해석으로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=5112d880-a9dd-ac8e-111a-67214eb89193.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/5112d880-a9dd-ac8e-111a-67214eb89193.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			뿌리마디의 자료는 Start 변수를 이용하여 분리했을 때 present와 absent를 가장 잘 분리시킬 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			위 결과의 단계에서 멈추지 않고 추가로 가지를 생성한다면, 새로운 자료에 대한 예측력은 떨어질 수도 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이 자료에서 Start 변수의 값이 14.58이상인 관찰치는 Kyphosis 변수의 값이 모두 absent였을 것이다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a26" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a26" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				의사결정나무는 뿌리마디(root node)에서 시작하여 특정 조건을 기준으로 데이터를 분할할 때마다 각 마디의 불순도는 줄어들며, 불순도가 최소화된 상태에서 최종 노드(터미널 노드)가 생성된다. 반면, 뿌리마디에서 Start 변수를 사용하여 가장 잘 분리했으며, 가지를 과도하게 확장하면 과적합이 발생해 새로운 데이터에 대한 예측력이 떨어질 수 있다. 또한 Start 값이 14.58 이상인 경우, 해당 노드는 모두 Kyphosis 값이 absent로 분류된 것을 확인할 수 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				의사결정나무 분석에서 뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 감소하는 것이 일반적입니다. 이는 의사결정나무가 데이터를 분류하면서 불순도를 줄여나가는 과정이기 때문입니다. <br>
   1. 뿌리마디에서 아래로 내려갈수록 각 마디에서의 불순도는 점차 증가한다: 의사결정나무의 기본 원리에 반하는 설명으로, 불순도는 감소해야 합니다.<br>
   2. 뿌리마디의 자료는 Start 변수를 이용하여 분리했을 때 present와 absent를 가장 잘 분리시킬 수 있다: 뿌리마디에서 가장 중요한 변수로 데이터를 분리하는 것이 일반적입니다.<br>
   3. 위 결과의 단계에서 멈추지 않고 추가로 가지를 생성한다면, 새로운 자료에 대한 예측력은 떨어질 수도 있다: 과적합(overfitting)의 위험을 설명한 것으로 타당한 해석입니다.<br>
   4. 이 자료에서 Start 변수의 값이 14.58이상인 관찰치는 Kyphosis 변수의 값이 모두 absent였을 것이다: 특정 조건에서의 분류 결과를 설명한 것으로, 데이터에 기반한 타당한 해석입니다.<br>
			</div>
			<div class="t2">
									#의사결정나무									# 불순도									# 과적합									# 데이터 분류							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5524);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">27.</span>
			<span class="tt1t1">
				다음 중 앙상블 모형의 특징으로 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			여러 모델을 결합하기 때문에 원인 분석에는 적합하지 않다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			이상값에 대한 반응을 완화하여 대응력을 높일 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			여러 모델의 결과를 종합하여 예측값의 변동성을 줄인다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			각 모형의 상호 연관성이 높을수록 정확도가 향상된다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a27" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a27" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			각 모형의 상호 연관성이 높을수록 정확도가 향상된다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				앙상블 모형에서는 각 모형이 독립적일수록(상호 연관성이 낮을수록) 예측 성능이 향상된다. 상호 연관성이 높은 경우 모형 간의 다변성이 부족하여 앙상블의 이점을 살릴 수 없다. 나머지 선택지들은 앙상블 모형의 일반적인 특징을 정확히 설명하고 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				앙상블 모형은 여러 모델을 결합하여 예측 성능을 향상시키는 방법입니다. 각 모형의 상호 연관성이 낮을수록 다양한 관점을 반영하여 더 나은 예측 성능을 발휘할 수 있습니다.<br>
   <br>
1. 여러 모델을 결합하기 때문에 원인 분석에는 적합하지 않다.<br>
: 여러 모델을 결합하면 개별 모델의 복잡성을 증가시켜 원인 분석이 어려워질 수 있습니다. 이는 앙상블 모형의 일반적인 특징 중 하나입니다.<br>
   <br>
2. 이상값에 대한 반응을 완화하여 대응력을 높일 수 있다.<br>
: 앙상블 모형은 이상값에 대한 민감도를 낮추어 예측의 안정성을 높이는 데 기여할 수 있습니다. 이는 다양한 모델의 결과를 결합하여 이상값의 영향을 완화하는 방식입니다.<br>
   <br>
3. 여러 모델의 결과를 종합하여 예측값의 변동성을 줄인다.<br>
: 여러 모델의 예측 결과를 종합하면 예측값의 변동성을 줄일 수 있습니다. 이는 앙상블 모형의 주된 장점 중 하나로, 예측의 신뢰성을 높입니다.<br>
   <br>
4. 각 모형의 상호 연관성이 높을수록 정확도가 향상된다.<br>
: 각 모형의 상호 연관성이 높을수록 동일한 오류를 범할 가능성이 커져 정확도가 떨어질 수 있습니다. 앙상블 모형은 다양한 관점을 반영하기 위해 상호 독립적인 모델을 사용하는 것이 바람직합니다.<br>
			</div>
			<div class="t2">
									#앙상블 모형									# 모델 결합									# 변동성 감소									# 상호 연관성							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6143);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">28.</span>
			<span class="tt1t1">
				다음 중 데이터를 복원 추출하여 여러 번 샘플링한 후 각 샘플에서 생성된 모델의 결과를 결합해 최종 예측을 수행하는 앙상블 기법은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			배깅(bagging)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤 포레스트(random forest)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			서포트 벡터 머신(support vector machine) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부스팅(boosting)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a28" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a28" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			배깅(bagging)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				배깅(Bootstrap Aggregating)은 데이터를 복원 추출로 여러 번 샘플링하여 각 샘플에서 모델을 생성하고, 이를 결합하여 예측 성능을 향상시키는 앙상블 기법이다. 랜덤포레스트는 배깅을 기반으로 한 기법으로, 서포트 벡터 머신과 부스팅은 배깅과 다른 방식의 알고리즘이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 복원 추출을 통해 여러 번 샘플링한 후 각 샘플에서 생성된 모델의 결과를 결합해 최종 예측을 수행하는 앙상블 기법은 배깅(bagging)입니다. 배깅은 데이터의 변동성을 줄이고 예측의 안정성을 높이기 위해 여러 모델의 평균을 취하는 방식입니다.<br>
   <br>
1. 배깅(bagging)<br>
: 배깅은 데이터를 복원 추출하여 여러 개의 훈련 데이터셋을 만들고, 각각의 샘플에 대해 독립적인 모델을 학습한 후, 결과를 결합하여 최종 예측을 수행하는 기법입니다. 배깅을 사용하면 분산(variance)을 줄이고 예측 안정성을 높일 수 있습니다. 랜덤 포레스트가 배깅의 대표적인 예시입니다.<br>
<br>
2. 랜덤 포레스트(random forest)<br>
: 랜덤 포레스트는 배깅을 기반으로 한 결정 트리(Decision Tree) 앙상블 기법입니다. 즉, 배깅을 활용하여 여러 개의 결정 트리를 학습시키고, 최종적으로 다수결 투표(Majority Voting) 또는 평균을 통해 결과를 산출합니다. 배깅 기법의 대표적인 응용 사례이지만, 배깅 자체를 의미하는 것은 아니므로 정답이 아닙니다.<br>
<br>
3. 서포트 벡터 머신(support vector machine)<br>
: 서포트 벡터 머신(SVM)은 초평면(Hyperplane)을 통해 데이터를 분류하는 지도학습 모델입니다. 이는 개별 모델을 결합하는 앙상블 기법이 아니라, 개별 데이터를 분류하는 단일 기법이므로 본 문항에서 요구하는 배깅과 관련이 없습니다.<br>
<br>
4. 부스팅(boosting)<br>
: 부스팅은 배깅과 달리 각 모델이 순차적으로 학습하면서 이전 모델이 만든 오류를 보완하는 방식입니다. 즉, 개별 모델들이 독립적으로 학습하는 배깅과 달리, 부스팅은 모델 간의 종속성이 존재합니다. 대표적인 알고리즘으로 AdaBoost, Gradient Boosting, XGBoost 등이 있습니다.<br>
			</div>
			<div class="t2">
									#배깅									# 복원 추출									# 랜덤 포레스트									# 앙상블 학습							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5978);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">29.</span>
			<span class="tt1t1">
				다음 중 분류가 잘못된 데이터에 더 높은 가중치를 부여하여 모델을 반복적으로 학습시키는 앙상블 기법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			배깅(Bagging)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			부스팅(Boosting)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random Forest)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			스태킹(Stacking)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a29" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a29" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			부스팅(Boosting)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				부스팅은 분류가 잘못된 데이터에 높은 가중치를 부여하며 모델을 반복적으로 학습시켜 성능을 향상시키는 기법이다. 배깅은 여러 샘플로 독립적으로 학습한 결과를 결합하는 방식이고, 랜덤포레스트는 배깅과 결정트리 기반의 앙상블 기법이다. 스태킹은 여러 모델의 예측 결과를 조합하는 기법이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분석에서 앙상블 기법은 여러 모델을 결합하여 예측 성능을 향상시키는 방법입니다. 부스팅은 잘못 분류된 데이터에 더 높은 가중치를 부여하여 모델을 반복적으로 학습시키는 기법입니다. <br>
   <br>
1. 배깅(Bagging)<br>
: 배깅은 여러 샘플을 독립적으로 학습하여 결과를 평균화하는 방식으로, 잘못된 데이터에 가중치를 부여하지 않습니다. <br>
   <br>
2. 부스팅(Boosting)<br>
: 부스팅은 잘못 분류된 데이터에 더 높은 가중치를 부여하여 모델을 반복적으로 학습시키는 기법으로, 문제의 설명에 부합합니다.<br>
   <br>
3. 랜덤포레스트(Random Forest)<br>
: 랜덤포레스트는 배깅의 일종으로, 여러 결정 트리를 사용하여 예측을 평균화하지만, 잘못된 데이터에 가중치를 부여하지 않습니다.<br>
   <br>
4. 스태킹(Stacking)<br>
: 스태킹은 여러 모델의 예측을 결합하여 최종 예측을 만드는 방식으로, 잘못된 데이터에 가중치를 부여하지 않습니다.<br>
			</div>
			<div class="t2">
									#앙상블 기법									# 부스팅									# 가중치 조정									# 반복 학습							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">앙상블분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6757);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">30.</span>
			<span class="tt1t1">
				한 보험회사에서는 자사 고객의 보험갱신 여부를 고객의 인구통계학적 특성, 보험가입 채널, 상품 종류 등의 정보를 사용하여 예측하려고 한다. 다음 중 가장 적절한 분석 기법은 무엇인가? 							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			시계열분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			k-means 군집분석					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			주성분분석					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a30" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a30" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			랜덤포레스트			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				보험갱신 여부는 이진 분류 문제로, 랜덤포레스트는 여러 개의 결정 트리를 결합하여 예측 성능을 높이는 앙상블 기법이다. 시계열분석은 시간에 따른 패턴을 분석하는 데 사용되며, K-means 군집분석과 주성분분석은 각각 군집화와 차원 축소에 초점을 맞추므로 적합하지 않다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				보험갱신 여부를 예측하기 위해서는 지도 학습 기법이 적절하며, 랜덤포레스트는 다양한 특성을 고려하여 예측의 정확성을 높일 수 있는 방법입니다.<br>
			</div>
			<div class="t2">
									#랜덤포레스트									# 지도 학습									# 예측									# 보험갱신							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5951);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">31.</span>
			<span class="tt1t1">
				다음 설명에 맞는 기법은 무엇인가?					
					<span class="tt1t1">
						데이터의 패턴을 발견하고 데이터 모델의 매개 변수를 자동으로 학습한다.<br>
자체 알고리즘을 사용하여 시간이 경과함에 따라서 경험을 축적하면서 작업 성능이 향상된다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			선형 회귀 (Linear Regression)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			주성분 분석 (Principal Component Analysis, PCA)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			인공신경망 분석 (Artificial Neural Network)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분산분석 (ANOVA)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a31" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a31" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			인공신경망 분석 (Artificial Neural Network)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				인공신경망은 데이터의 패턴을 발견하고, 매개 변수를 자동으로 학습하며, 훈련 데이터를 통해 시간이 지남에 따라 경험을 축적하면서 성능이 향상된다. 선형 회귀와 주성분 분석은 특정한 목적의 통계적 또는 수학적 기법이며, 분산분석은 평균 차이를 검정하는 데 사용되는 기법으로 머신러닝의 정의와 다르다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				인공신경망은 입력 데이터를 처리하여 출력 결과를 생성하는 과정을 여러 층의 뉴런으로 구성하며, 가중치를 조정하는 방식으로 스스로 학습하는 머신러닝 기반 기법입니다.<br>
<br>
1. 선형 회귀 (Linear Regression)<br>
: 선형 회귀는 주어진 데이터에 대해 선형 관계를 모델링하는 기법으로, 자동 학습보다는 주어진 데이터를 기반으로 회귀선을 찾는 데 중점을 둡니다.<br>
<br>
2. 주성분 분석 (Principal Component Analysis, PCA)<br>
: PCA는 데이터의 차원을 축소하여 주요 성분을 찾는 기법으로, 데이터 패턴 학습보다는 데이터의 변동성을 설명하는 데 중점을 둡니다.<br>
<br>
3. 인공신경망 분석 (Artificial Neural Network)<br>
: 인공신경망은 입력값과 출력값 사이의 복잡한 관계를 다층 구조를 통해 학습하며, 오차역전파(backpropagation) 기법을 사용해 가중치를 반복적으로 조정하므로 문제의 설명과 정확히 부합합니다.<br>
<br>
4. 분산분석 (ANOVA)<br>
: ANOVA는 여러 그룹 간의 평균 차이를 분석하는 기법으로, 데이터 패턴 학습이나 자동 매개 변수 학습과는 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#머신러닝									# 데이터 패턴									# 자동 학습									# 경험 축적							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5587);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">32.</span>
			<span class="tt1t1">
				다음 중 신경망 모형에 대한 설명으로 가장 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			피드포워드 신경망은 입력층에서 시작하여 정보가 출력층으로 전달되는 형태로, 딥러닝의 핵심 모델이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			은닉층의 뉴런의 수와 개수는 신경망 모형에서 자동으로 설정되며, 뉴런의 수가 많으면 예측력이 좋아지나 뉴런 수가 적으면 입력 데이터를 충분히 표현하지 못하는 경우가 발생한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다층 퍼셉트론은 기본적으로 여러 개의 은닉층을 포함하여 입력층과 출력층 간의 관계를 학습한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			역전파 알고리즘은 출력층에서 발생한 오차를 입력층으로 전달하며, 가중치를 조정하는 과정에서 중요한 역할을 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a32" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a32" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			은닉층의 뉴런의 수와 개수는 신경망 모형에서 자동으로 설정되며, 뉴런의 수가 많으면 예측력이 좋아지나 뉴런 수가 적으면 입력 데이터를 충분히 표현하지 못하는 경우가 발생한다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				은닉층의 뉴런 수와 개수는 자동으로 설정되지 않으며, 사용자가 설계해야 하는 하이퍼파라미터이다. 뉴런의 수가 많으면 과적합이 발생할 수 있고, 적으면 데이터의 복잡한 패턴을 표현하지 못할 수 있다. 나머지 선택지들은 피드포워드 신경망, 다층 퍼셉트론, 역전파 알고리즘의 특성을 올바르게 설명하고 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				신경망 모형에서는 은닉층의 뉴런 수와 개수를 수동으로 설정해야 하며, 자동으로 설정되지 않습니다.<br>
<br>
1. 피드포워드 신경망은 입력층에서 시작하여 정보가 출력층으로 전달되는 형태로, 딥러닝의 핵심 모델이다.<br>
: 피드포워드 신경망은 입력층에서 출력층으로 정보가 전달되는 구조로, 딥러닝의 기본 모델입니다. 설명이 정확합니다.<br>
<br>
2. 은닉층의 뉴런의 수와 개수는 신경망 모형에서 자동으로 설정되며, 뉴런의 수가 많으면 예측력이 좋아지나 뉴런 수가 적으면 입력 데이터를 충분히 표현하지 못하는 경우가 발생한다.<br>
: 은닉층의 뉴런 수와 개수는 사용자가 설정해야 하며, 자동으로 설정되지 않습니다. 또한, 뉴런 수가 많다고 항상 예측력이 좋아지는 것은 아니며, 과적합의 위험이 있습니다.<br>
<br>
3. 다층 퍼셉트론은 기본적으로 여러 개의 은닉층을 포함하여 입력층과 출력층 간의 관계를 학습한다.<br>
: 다층 퍼셉트론은 여러 은닉층을 통해 입력과 출력 간의 관계를 학습하는 구조로, 설명이 정확합니다.<br>
<br>
4. 역전파 알고리즘은 출력층에서 발생한 오차를 입력층으로 전달하며, 가중치를 조정하는 과정에서 중요한 역할을 한다.<br>
: 역전파 알고리즘은 출력층의 오차를 입력층으로 전달하여 가중치를 조정하는 데 중요한 역할을 합니다. 설명이 정확합니다.<br>
			</div>
			<div class="t2">
									#신경망 모형									# 피드포워드									# 은닉층									# 다층 퍼셉트론									# 역전파 알고리즘									# 하이퍼파라미터							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6188);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">33.</span>
			<span class="tt1t1">
				아래에서 설명하는 활성화 함수로 가장 적절한 것은?					
					<span class="tt1t1">
						단층 신경망에서 이 활성화 함수를 사용하면 출력값이 확률로 해석 가능하며, 로지스틱 회귀와 유사한 작동 원리를 가진다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			선형 함수					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Softmax 함수					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ReLU 함수 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시그모이드 함수					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a33" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a33" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			시그모이드 함수			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				시그모이드 함수는 출력값을 0과 1 사이로 변환하며, 로지스틱 회귀와 유사한 작동 원리를 가진다. 선형 함수는 값을 그대로 출력하고, Softmax 함수는 다중 클래스 분류에서 각 클래스의 확률을 계산하며, ReLU 함수는 음수를 0으로 변환한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				단층 신경망에서 출력값을 확률로 해석할 수 있는 활성화 함수는 시그모이드 함수입니다. 이는 로지스틱 회귀와 유사한 작동 원리를 가지며, 출력값을 0과 1 사이의 확률로 변환합니다.<br>
   <br>
1. 선형 함수<br>
: 선형 함수는 입력값을 그대로 출력하며, 확률로 해석할 수 없습니다. 이는 활성화 함수로 사용될 경우 출력값이 확률 범위를 벗어나기 때문에 적절하지 않습니다.<br>
   <br>
2. Softmax 함수<br>
: Softmax 함수는 다중 클래스 분류 문제에서 사용되며, 각 클래스의 확률을 출력합니다. 단층 신경망의 이진 분류에서는 시그모이드 함수가 더 적합합니다.<br>
   <br>
3. ReLU 함수<br>
: ReLU 함수는 음수 입력을 0으로 변환하고 양수 입력을 그대로 출력합니다. 이는 확률로 해석할 수 없으며, 주로 은닉층에서 사용됩니다.<br>
   <br>
4. 시그모이드 함수<br>
: 시그모이드 함수는 입력값을 0과 1 사이의 확률로 변환하여 출력합니다. 이는 로지스틱 회귀와 유사한 작동 원리를 가지며, 이진 분류 문제에 적합합니다.<br>
			</div>
			<div class="t2">
									#활성화 함수									# 단층 신경망									# 시그모이드 함수							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5537);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">34.</span>
			<span class="tt1t1">
				다음 중 신경망 모형에서 출력값이 여러 개이고 목표치가 다범주인 경우에 사용하는 활성화 함수는?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			선형 활성화 (Linear Activation)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ELU (Exponential Linear Unit)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ReLU (Rectified Linear Unit)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			소프트 맥스(Softmax)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a34" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a34" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			소프트 맥스(Softmax)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				소프트맥스 함수는 출력값을 확률로 변환하여 다범주 분류 문제에 적합하다. 입력값의 지수 함수 비율로 각 클래스의 확률을 계산하여 모든 출력값의 합이 1이 되도록 보장한다. 선형 활성화 함수는 회귀 문제에 주로 사용되며, ELU와 ReLU는 주로 은닉층에서 활성화 함수로 사용된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				신경망 모형에서 출력값이 여러 개이고 목표치가 다범주인 경우에는 "소프트 맥스(Softmax)" 활성화 함수를 사용합니다. 이는 출력값을 확률 분포로 변환하여 각 범주에 속할 확률을 계산하는 데 적합합니다.<br>
<br>
1. 선형 활성화 (Linear Activation)<br>
: 선형 활성화 함수는 입력값을 그대로 출력하며, 회귀 문제와 같이 연속적인 값을 예측하는 데 사용됩니다. 다중 클래스 분류 문제에는 적합하지 않습니다.<br>
<br>
2. ELU (Exponential Linear Unit)<br>
: ELU는 음수 값을 포함한 입력값에 대해 점진적으로 감소하는 출력을 반환하며, 주로 은닉층에서 사용되는 활성화 함수입니다. 다범주 출력값을 처리하는 출력층 활성화 함수로는 적합하지 않습니다.<br>
<br>
3. ReLU (Rectified Linear Unit)<br>
: ReLU는 음수 입력값을 0으로 변환하고 양수 입력값을 그대로 반환하는 비선형 활성화 함수입니다. 주로 은닉층에서 사용되며, 다중 클래스 분류 문제의 출력층 활성화 함수로는 적합하지 않습니다.<br>
<br>
4. 소프트 맥스(Softmax)<br>
: 소프트맥스 함수는 각 출력값을 0과 1 사이의 확률로 변환하며, 모든 출력값의 합이 1이 되도록 정규화합니다. 이를 통해 신경망이 각 클래스에 대해 예측 확률을 제공할 수 있어 다중 클래스 분류 문제에 적합합니다.<br>
			</div>
			<div class="t2">
									#신경망 모형									# 활성화 함수									# 소프트맥스									# 다중 클래스 분류							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(7219);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">35.</span>
			<span class="tt1t1">
				인공신경망 모형에서 가중치의 역할로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 차원 증대					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			입력 신호 강도 조절					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			모형 복잡도 감소					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			결과 데이터 크기 조절					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a35" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a35" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			입력 신호 강도 조절			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				가중치는 입력 신호의 중요도를 학습하는 과정에서 조절되며, 각 입력 노드의 영향을 반영하여 결과를 도출하는 데 핵심적인 역할을 한다. 나머지 선택지들은 가중치의 역할과는 무관하며, 데이터 차원 증대나 모형 복잡도 감소는 다른 기법에 해당한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				인공신경망 모형에서 가중치는 입력 신호의 강도를 조절하여 출력에 영향을 미치는 요소입니다. 이는 입력 데이터가 신경망을 통해 전달될 때 각 입력의 중요도를 조정하여 최종 출력에 기여하는 방식입니다.<br>
<br>
1. 데이터 차원 증대<br>
: 가중치는 데이터의 차원을 증대시키는 역할을 하지 않습니다. 데이터 차원 증대는 주로 데이터 전처리 과정에서 이루어지며, 가중치는 입력 신호의 중요도를 조절하는 역할을 합니다.   <br>
<br>
2. 입력 신호 강도 조절<br>
: 가중치는 입력 신호의 강도를 조절하여 신경망의 출력에 영향을 미칩니다. 이는 입력 데이터가 얼마나 중요한지를 결정하는 요소로, 신경망 학습의 핵심입니다.   <br>
<br>
3. 모형 복잡도 감소<br>
: 가중치는 모형의 복잡도를 감소시키는 역할을 하지 않습니다. 오히려 가중치는 모형의 복잡성을 증가시킬 수 있으며, 복잡도 감소는 주로 정규화 기법을 통해 이루어집니다.   <br>
<br>
4. 결과 데이터 크기 조절<br>
: 가중치는 결과 데이터의 크기를 조절하는 역할을 하지 않습니다. 결과 데이터 크기는 주로 출력층의 노드 수에 의해 결정됩니다.<br>
			</div>
			<div class="t2">
									#인공신경망 모형									# 가중치									# 입력 신호							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5631);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">36.</span>
			<span class="tt1t1">
				전체 신경망 노드 중 무작위로 노드를 선정해 다수의 모형을 구성하여 학습하고 각 모형의 결과를 결합해 예측 및 분류하는 기법은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			부스팅(Boosting) 기법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			드롭아웃(Dropout) 기법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			결정 트리(Decision Tree) 기법					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			아다부스팅(Adaboosting) 기법					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a36" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a36" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			드롭아웃(Dropout) 기법			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				드롭아웃은 학습 과정에서 무작위로 일부 노드를 제거하여 과적합을 방지하고, 모델의 일반화 성능을 향상시키는 기법이다. 부스팅, 결정 트리, 아다부스팅은 앙상블 학습 기법에 해당하며, 드롭아웃과는 다른 방식이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				전체 신경망 노드 중 무작위로 노드를 선정해 다수의 모형을 구성하여 학습하고 각 모형의 결과를 결합해 예측 및 분류하는 기법은 드롭아웃(Dropout) 기법입니다. 드롭아웃은 과적합을 방지하기 위해 신경망의 일부 노드를 무작위로 비활성화하여 학습하는 방식입니다. <br>
<br>
1. 부스팅(Boosting) 기법<br>
: 부스팅은 약한 학습기를 순차적으로 학습시켜 강한 학습기를 만드는 방법으로, 무작위로 노드를 선택하는 방식과는 다릅니다. 드롭아웃과는 목적과 방식이 다르며, 주로 에러를 줄이는 데 초점을 맞춥니다.<br>
   <br>
2. 드롭아웃(Dropout) 기법<br>
: 드롭아웃은 신경망의 일부 노드를 무작위로 비활성화하여 학습하는 기법으로, 과적합을 방지하고 일반화 성능을 향상시킵니다. 이는 문제에서 설명한 방식과 일치합니다.<br>
   <br>
3. 결정 트리(Decision Tree) 기법<br>
: 결정 트리는 데이터의 특성을 기반으로 분할하여 예측하는 방법으로, 무작위 노드 선택과는 관련이 없습니다. 드롭아웃과는 전혀 다른 구조적 접근을 취합니다.<br>
   <br>
4. 아다부스팅(Adaboosting) 기법<br>
: 아다부스팅은 부스팅의 한 종류로, 약한 학습기를 결합하여 강한 학습기를 만드는 방법입니다. 드롭아웃과는 무작위 노드 선택이라는 측면에서 차이가 있습니다.<br>
			</div>
			<div class="t2">
									#드롭아웃									# 신경망									# 과적합 방지									# 무작위 노드 선택							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6758);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">37.</span>
			<span class="tt1t1">
				150개의 식물 개체를 4개의 변수(꽃받침 길이, 꽃받침 폭, 꽃잎 길이, 꽃잎 폭)로 측정한 데이터를 사용하여 3개의 식물 군으로 구분하려 한다. 이 때 사용 가능한 분석 방법으로 적절한 것은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			회귀분석(Regression)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			시계열분석(Time series Analysis)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집분석(Cluster Analysis) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석(Association Analysis)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a37" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a37" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			군집분석(Cluster Analysis) 			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				군집분석은 사전 레이블이 없는 데이터를 유사성을 기반으로 그룹화하는 비지도 학습 기법이다. 회귀분석은 연속형 종속변수를 예측할 때 사용되고, 시계열분석은 시간적 순서를 고려한 데이터를 분석하며, 연관분석은 항목 간의 관계를 탐색한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				데이터 분석에서 군집분석은 데이터를 그룹으로 나누는 데 사용되는 방법입니다. 이는 주어진 데이터를 기준으로 유사한 특성을 가진 데이터들을 같은 그룹으로 묶어주는 분석 방법입니다. <br>
   1. 회귀분석(Regression): 회귀분석은 종속 변수와 독립 변수 간의 관계를 모델링하는 방법으로, 데이터를 그룹으로 나누는 데 적합하지 않습니다.<br>
   2. 시계열분석(Time series Analysis): 시계열분석은 시간에 따른 데이터의 변화를 분석하는 방법으로, 군집화를 위한 분석 방법이 아닙니다.<br>
   3. 군집분석(Cluster Analysis): 군집분석은 데이터를 유사한 특성을 가진 그룹으로 나누는 방법으로, 주어진 문제에서 3개의 식물 군으로 구분하는 데 적합합니다.<br>
   4. 연관분석(Association Analysis): 연관분석은 데이터 항목 간의 관계를 찾는 방법으로, 데이터의 군집화를 위한 분석 방법이 아닙니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 데이터 군집화									# 변수 측정							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6759);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">38.</span>
			<span class="tt1t1">
				군집분석은 비지도학습 기법 중 하나로 사전 정보 없이 자료를 유사한 대상끼리 묶는 방법이다. 다음 중 군집분석에 대한 설명으로 부적절한 것은? 							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집 결과에 대한 안정성을 검토하는 방법으로 교차 타당성을 이용할 수 있다. 데이터를 두 집단으로 나누어 각 집단에서 군집분석을 수행하고, 결과를 합쳐 전체 데이터로 군집 분석한 결과와 비교하여 유사하면 결과의 안정성이 있다고 할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집의 분리가 논리적인가를 살펴보기 위해서는 군집 간 변동의 크기 차이를 검토한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			개체를 분류하기 위한 명확한 기준이 존재하지 않거나 기준이 밝혀지지 않은 상태에서 유용하게 이용할 수 있다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a38" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a38" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				군집분석은 사전 가정 없이 데이터를 군집화하며, 거리 기준에 따라 자발적으로 군집화를 유도한다. 나머지 선택지는 군집 결과의 안정성, 군집 간 변동 검토, 개체 분류 기준의 유용성을 적절히 설명하고 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
군집분석(Clustering)은 데이터를 사전 분류 정보 없이 거리, 유사도, 밀도 등의 기준에 따라 자연스럽게 유사한 대상끼리 묶는 비지도학습의 대표적인 방법입니다. 다양한 응용 분야에서 패턴 발견이나 세분화(Segmentation)에 활용됩니다.<br>
<br>
1. 군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.<br>
: 군집분석은 군집의 개수나 형태를 미리 알지 못한 상태에서 거리나 유사도 기준에 따라 데이터를 자연스럽게 묶는 분석 방법입니다. 데이터 내의 패턴을 기반으로 스스로 군집을 형성해나가는 과정이므로 자발적인 군집화를 유도합니다.<br>
<br>
2. 군집 결과에 대한 안정성을 검토하는 방법으로 교차 타당성을 이용할 수 있다. 데이터를 두 집단으로 나누어 각 집단에서 군집분석을 수행하고, 결과를 합쳐 전체 데이터로 군집 분석한 결과와 비교하여 유사하면 결과의 안정성이 있다고 할 수 있다.<br>
: 군집분석은 비지도학습이기 때문에 결과의 해석이 주관적일 수 있습니다. 따라서 교차 타당성처럼 데이터를 나누어 분석하고 결과의 일관성을 검토하는 방법을 통해 안정성을 확인할 수 있습니다.<br>
<br>
3. 군집의 분리가 논리적인가를 살펴보기 위해서는 군집 간 변동의 크기 차이를 검토한다.<br>
: 군집 간 변동이 클수록 서로 다른 특성을 가진 그룹으로 잘 나뉘었다는 의미입니다. 군집 내 변동은 작고, 군집 간 변동은 클수록 좋은 군집화 결과로 평가됩니다.<br>
<br>
4. 개체를 분류하기 위한 명확한 기준이 존재하지 않거나 기준이 밝혀지지 않은 상태에서 유용하게 이용할 수 있다.<br>
: 군집분석은 분류 기준이 미리 정의되지 않은 경우, 즉 비지도 상황에서 매우 유용합니다. 소비자 세분화, 시장 조사 등에서 기존 레이블 없이도 의미 있는 그룹을 발견할 수 있습니다.<br>
<br>
군집분석은 사전 레이블이 없는 데이터를 유사도 기준으로 그룹화하는 비지도학습 기법입니다. 이 과정에서 보통 거리 기반(예: 유클리디안 거리) 등의 기준을 활용하며, 자발적으로 군집 구조를 찾는 것이 핵심입니다.<br>
<br>
따라서 정답은 '1. 군집분석에서는 군집의 개수나 구조에 대한 가정없이 다변량 데이터로부터 거리 기준에 의한 자발적인 군집화를 유도하지 않는다.'입니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 비지도학습									# 거리 기준									# 교차타당성							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6289);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">39.</span>
			<span class="tt1t1">
				거리를 이용하여 데이터 간 유사도를 측정할 수 있는 척도는 데이터의 속성과 구조에 따라 적합한 것을 사용해야 한다. 다음 중 유사도 측도에 대한 설명으로 부적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유클리드 거리는 두 점을 잇는 가장 짧은 직선거리이다. 공통으로 점수를 매긴 항목의 거리를 통해 판단하는 측도이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			맨하튼 거리는 각 방향 직각의 이동 거리 합으로 계산된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			표준화 거리는 각 변수를 해당 변수의 표준편차로 변환한 후 유클리드 거리를 계산한 거리이다. 표준화를 하게 되면 척도의 차이, 분산의 차이로 인해 왜곡을 피할 수 있다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a39" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a39" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				마할라노비스 거리는 변수 간의 상관성을 고려하는 거리 측도로, 공분산 행렬을 사용하여 상관성을 반영한다. 변수 간 상관성이 있는 경우 오히려 표준화 거리 대신 마할라노비스 거리를 사용하는 것이 적절하다. 유클리드 거리는 두 점 사이의 가장 짧은 직선거리를 측정하며 맨하튼 거리는 각 축 방향으로 직각 이동 거리를 합산하여 계산한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 4번입니다.<br>
<br>
유사도 척도는 데이터의 속성(수치형, 범주형 등), 분포, 변수 간 상관성 등에 따라 적절한 방법을 선택해야 하며, 각 거리 척도는 고유의 적용 조건과 특징을 가지고 있습니다.<br>
<br>
1. 유클리드 거리는 두 점을 잇는 가장 짧은 직선거리이다. 공통으로 점수를 매긴 항목의 거리를 통해 판단하는 측도이다.<br>
: 유클리드 거리는 피타고라스 정리에 기반한 직선 거리로, 대표적인 연속형 변수 간 거리 측정 방법입니다. 모든 변수가 같은 척도를 가지거나, 사전에 정규화 또는 표준화가 이루어졌다면 적절하게 적용됩니다.<br>
<br>
2. 맨하튼 거리는 각 방향 직각의 이동 거리 합으로 계산된다.<br>
: 맨하튼 거리는 각 변수(차원)별 차이의 절댓값을 합산하여 계산하는 거리 척도입니다. 이는 두 점 간 거리 계산 시, 직선 거리 대신 축 방향으로만 이동하는 방식을 따릅니다.<br>
<br>
3. 표준화 거리는 각 변수를 해당 변수의 표준편차로 변환한 후 유클리드 거리를 계산한 거리이다. 표준화를 하게 되면 척도의 차이, 분산의 차이로 인해 왜곡을 피할 수 있다.<br>
: 표준화 거리는 각 변수의 단위 차이, 분산 차이로 인한 왜곡을 줄이기 위해 사용되며, 정규화된 변수들로 유클리드 거리를 계산할 수 있도록 보정하는 방법입니다.<br>
<br>
4. 마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.<br>
: 마할라노비스 거리는 변수의 표준편차뿐 아니라 변수 간의 공분산(상관성 포함)을 모두 고려한 거리입니다. 따라서 변수 간 상관성이 있는 경우, 오히려 유클리드 거리나 표준화 거리보다 더 적합한 방법입니다. 즉, 상관성이 있을 때는 마할라노비스 거리를 사용하는 것이 권장되며, 표준화 거리로 대체하는 것이 적절하지 않습니다.<br>
<br>
따라서, 문제의 정답은 '4. 마할라노비스 거리는 변수의 표준편차를 고려한 거리 측도이나 변수 간에 상관성이 있는 경우에는 표준화 거리 사용을 검토해야 한다.' 입니다.<br>
			</div>
			<div class="t2">
									#유사도 측정									# 거리 측도									# 마할라노비스 거리							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5989);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">40.</span>
			<span class="tt1t1">
				다음 중 변수 간의 상관성을 고려하여 두 데이터 간의 통계적 거리를 계산하는 데 사용되는 방법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			유클리디안 거리					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			맨해튼 거리					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			마할라노비스 거리					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			코사인 유사도					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a40" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a40" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			마할라노비스 거리			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				마할라노비스 거리는 변수 간의 상관성을 고려하여 데이터 간의 통계적 거리를 계산하는 방법이다. 유클리디안 거리와 맨해튼 거리는 상관성을 고려하지 않고 단순 거리 계산에 사용되며, 코사인 유사도는 방향성에 기반한 유사도 측정 방법이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				변수 간의 상관성을 고려하여 두 데이터 간의 통계적 거리를 계산하는 방법은 "마할라노비스 거리"입니다. 이는 데이터의 분산과 공분산을 고려하여 데이터 간의 거리를 측정하는 방법으로, 변수 간의 상관관계를 반영합니다.<br>
   <br>
1. 유클리디안 거리<br>
: 두 점 간의 직선 거리를 계산하는 방법으로, 변수 간의 상관성을 고려하지 않습니다. 이는 단순한 거리 계산법으로, 데이터의 분산이나 공분산을 반영하지 않습니다.<br>
   <br>
2. 맨해튼 거리<br>
: 축을 따라 이동하는 방식으로 거리를 계산하며, 변수 간의 상관성을 고려하지 않습니다. 이는 각 차원의 절대적 차이의 합으로 거리를 측정하는 방법입니다.<br>
   <br>
3. 마할라노비스 거리<br>
: 변수 간의 상관성을 고려하여 두 데이터 간의 거리를 계산하는 방법입니다. 이는 데이터의 분산과 공분산을 고려하여, 변수 간의 상관관계를 반영합니다.<br>
   <br>
4. 코사인 유사도<br>
: 두 벡터 간의 각도를 측정하여 유사성을 평가하는 방법으로, 거리 계산과는 다릅니다. 이는 주로 텍스트 데이터의 유사성을 평가하는 데 사용됩니다.<br>
			</div>
			<div class="t2">
									#상관성									# 통계적 거리									# 마할라노비스 거리									# 변수 간 상관관계							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5529);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">41.</span>
			<span class="tt1t1">
				다음 중 아래 수식에 해당하는 거리 계산 방법은?					
					<span class="tt1t1">
						<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="24" style="font-size: 107.5%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="2"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-munderover space="4"><mjx-over style="padding-bottom: 0.111em; padding-left: 0.544em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-over><mjx-box><mjx-munder><mjx-row><mjx-base><mjx-mo class="mjx-lop"><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style="padding-top: 0.167em; padding-left: 0.148em;"><mjx-texatom size="s" texclass="ORD"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-texatom></mjx-under></mjx-row></mjx-munder></mjx-box></mjx-munderover><mjx-mrow space="2"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D456 TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo></mjx-mrow></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo data-mjx-texclass="CLOSE">|</mo></mrow></math></mjx-assistive-mml></mjx-container>					</span>
							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=16c3e924-acf2-c4b1-c092-b8315484f904.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/16c3e924-acf2-c4b1-c092-b8315484f904.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			자카드 거리 (Jaccard Distance)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			캔버라 거리 (Canberra Distance)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			코사인 유사도 (Cosine Similarity)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			맨하탄(Manhattan) 거리					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a41" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a41" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			맨하탄(Manhattan) 거리			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				맨하탄 거리는 두 점 사이의 직각 거리를 의미하며, 마치 맨해튼 거리의 블록을 따라 이동하는 것과 같아서 붙여진 이름이며, 각 차원에서의 절댓값 차이의 합으로 계산된다. 자카드 거리는 두 집합 간의 유사도를 측정하는 방법이고 캔버라 거리는 각 차원에서의 값의 차이를 해당 차원의 값의 합으로 나눈 값을 합하는 방식으로 계산되며 코사인 유사도는 두 벡터 사이의 코사인 값을 이용하여 유사도를 측정하는 방법이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				이 수식은 맨하탄 거리(Manhattan Distance)를 계산하는 방법입니다.  <br>
맨하탄 거리는 두 점 간의 축을 따라 이동하는 거리의 합으로, 각 차원의 절대 차이를 더하여 계산합니다.<br>
  <br>
1. 자카드 거리 (Jaccard Distance): 집합 간의 유사성을 측정하는 방법으로, 교집합과 합집합의 비율을 사용합니다. 절대 차이를 합산하는 방식이 아닙니다.<br>
  <br>
2. 캔버라 거리 (Canberra Distance): 각 차원의 차이를 각 차원의 합으로 나눈 후 합산하는 방식으로, 이 수식과는 다릅니다.<br>
  <br>
3. 코사인 유사도 (Cosine Similarity): 두 벡터 간의 각도를 측정하여 유사성을 계산하는 방법으로, 내적과 벡터 크기를 사용합니다.<br>
  <br>
4. 맨하탄(Manhattan) 거리: 각 차원의 절대 차이를 합산하여 두 점 간의 거리를 계산합니다.<br>
			</div>
			<div class="t2">
									#맨하탄 거리									# 절대 차이									# 거리 계산							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5675);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">42.</span>
			<span class="tt1t1">
				아래 데이터 셋 A, B 간의 유사성을 측정할 때 유클리드 거리를 구하는 방법으로 올바른 계산 값은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=a355c100-a5bc-df0f-b796-026cfbd54f9d.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/a355c100-a5bc-df0f-b796-026cfbd54f9d.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			0					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(sqrt{8} )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(sqrt{20} )					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			(sqrt{50} )					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a42" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a42" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			(sqrt{50} )			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				유클리드 거리는 A와 B의 각 데이터(키와 몸무게)를 비교하여 차이를 제곱한 후 합산한 값의 제곱근을 구한다. 따라서 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="25" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>5</mn></msqrt><mn>0</mn></math></mjx-assistive-mml></mjx-container>이 된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				유클리드 거리(Euclidean Distance)는 두 데이터 간의 유사성을 측정하는 대표적인 방법입니다. 이는 각 변수 간 차이를 제곱한 후 합산하여 제곱근을 취하는 방식으로 계산됩니다.<br>
<br>
1. 데이터 확인<br>
• A: 키 = 180, 몸무게 = 65<br>
• B: 키 = 175, 몸무게 = 70<br>
<br>
2. 유클리드 거리 계산<br>
두 점 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="26" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D434 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="27" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D435 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> 사이의 유클리드 거리 공식은 아래와 같습니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="28" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-lop"><mjx-c class="mjx-c221A TEX-S2"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.45em;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.289em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mo>=</mo><msqrt><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></msqrt></math></mjx-assistive-mml></mjx-container><br>
<br>
여기서 x = 키, y = 몸무게로 가정했을 때, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="29" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>와 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="30" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>의 값은 아래와 같습니다.<br>
• <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="31" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">키</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">의</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">차</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">이</mjx-utext></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mtext>키의 차이</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>180</mn><mo>−</mo><mn>175</mn><mo>=</mo><mn>5</mn></math></mjx-assistive-mml></mjx-container><br>
• <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="32" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-msub space="3"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D466 TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">몸</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">무</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">게</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">의</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">차</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">이</mjx-utext></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c37"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mtext>몸무게의 차이</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>65</mn><mo>−</mo><mn>70</mn><mo>=</mo><mo>−</mo><mn>5</mn></math></mjx-assistive-mml></mjx-container><br>
<br>
각 두 값을 제곱하여 합산하면,<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="33" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-msup><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-script style="vertical-align: 0.363em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>5</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mn>25</mn><mo>+</mo><mn>25</mn><mo>=</mo><mn>50</mn></math></mjx-assistive-mml></mjx-container> 이 되며, 제곱근을 계산하면 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="34" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D451 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-msqrt space="4"><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo>=</mo><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>이 됩니다.<br>
<br>
따라서, A와 B 간의 유클리드 거리는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="35" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class="mjx-n"><mjx-c class="mjx-c221A"></mjx-c></mjx-mo></mjx-surd><mjx-box style="padding-top: 0.163em;"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>50</mn></msqrt></math></mjx-assistive-mml></mjx-container>입니다.<br>
			</div>
			<div class="t2">
									#유클리드 거리									# 데이터 유사성							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">인공신경망분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6097);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">43.</span>
			<span class="tt1t1">
				계층적 군집분석 결과를 아래와 같이 덴드로그램으로 시각화하였다고 할 때, Tree의 높이 (height)가 60일 경우 나타나는 군집의 수는 몇 개인가?							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=31308792-6698-1725-2823-271b543aa50b.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/31308792-6698-1725-2823-271b543aa50b.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			2					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			3					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			4					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			5					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a43" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a43" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			3			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				덴드로그램(Dendrogram)은 계층적 군집 분석 결과를 시각화한 그림으로, 각 데이터 포인트간의 유사성을 나타내는 트리 구조이다. 덴드로그램에서 높이 60의 수평선을 그어보면, 이 선과 만나는 수직선의 개수가 곧 그 높이에서 생성되는 군집의 수를 의미한다. 문제의 덴드로그램에서 높이 60의 수평선을 그었을 때, 총 3개의 수직선과 만나게 된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 덴드로그램에서 군집의 수 결정 방법<br>
계층적 군집분석에서는 덴드로그램의 특정 높이(height)에서 수평선을 그어 군집을 나누는 방식으로 군집의 수를 결정합니다. Tree의 높이를 60으로 설정한 경우, 덴드로그램에서 높이 60에 수평선을 그리면 가지(branch) 개수에 따라 군집의 수를 확인할 수 있습니다. 가지가 교차하는 지점이 각 군집의 경계를 나타냅니다.<br>
<br>
2. 군집 개수 계산<br>
높이 60에서 덴드로그램을 분석하면, 수평선 아래로 3개의 독립된 가지(branch)가 형성됩니다. 각 가지는 하나의 군집으로 간주되므로, 이 기준에 따라 형성되는 군집의 총 개수는 3개입니다.<br>
			</div>
			<div class="t2">
									#계층적 군집분석									# 덴드로그램									# 가지(branch)							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5648);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">44.</span>
			<span class="tt1t1">
				다음 중 군집 간 거리를 군집에 속한 개체 간의 거리 중 가장 먼 거리로 정의하는 군집분석의 연결법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			최단연결법 (Single Linkage)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			최장연결법 (Complete Linkage)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			평균연결법 (Average Linkage)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			중심연결법 (Centroid Linkage)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a44" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a44" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">2</i>
			<span class="t2t1">
			최장연결법 (Complete Linkage)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				최장연결법은 두 군집 내의 가장 먼 개체 간의 거리를 기준으로 군집 간 거리를 정의한다. 최단연결법은 가장 가까운 개체 간의 거리를, 평균연결법은 모든 개체 간의 평균 거리를, 중심연결법은 군집의 중심 간 거리를 기준으로 한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집 간 거리를 정의하는 방법 중 최장연결법은 군집에 속한 개체 간의 거리 중 가장 먼 거리를 기준으로 합니다. 이는 군집 내의 가장 먼 두 점 사이의 거리를 고려하여 군집을 형성하는 방법입니다.<br>
<br>
1. 최단연결법 (Single Linkage)<br>
: 군집 간 거리를 가장 가까운 두 개체 간의 거리로 정의하는 방법입니다. 이는 군집 내의 가장 가까운 두 점을 기준으로 군집을 형성합니다.<br>
<br>
2. 최장연결법 (Complete Linkage)<br>
: 군집 간 거리를 가장 먼 두 개체 간의 거리로 정의하는 방법입니다. 이는 군집 내의 가장 먼 두 점을 기준으로 군집을 형성하여, 군집 내의 응집성을 높입니다.<br>
<br>
3. 평균연결법 (Average Linkage)<br>
: 군집 간 거리를 군집에 속한 모든 개체 간의 평균 거리로 정의하는 방법입니다. 이는 군집 내의 모든 점 사이의 평균 거리를 고려하여 군집을 형성합니다.<br>
<br>
4. 중심연결법 (Centroid Linkage)<br>
: 군집 간 거리를 군집의 중심(평균) 간의 거리로 정의하는 방법입니다. 이는 각 군집의 중심을 기준으로 군집 간의 거리를 측정합니다.<br>
			</div>
			<div class="t2">
									#군집분석									# 최장연결법									# 거리 측정							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6760);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">45.</span>
			<span class="tt1t1">
				비계층적 군집분석의 장점에 대한 설명이 잘못된 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			주어진 데이터의 내부 구조에 대한 사전 정보가 없어도 의미있는 결과를 얻을 수 있다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			다양한 형태의 데이터의 적용이 가능하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			분석방법의 적용이 용이하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			사전에 주어진 목적이 없으므로 결과 해석이 쉽다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a45" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a45" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			사전에 주어진 목적이 없으므로 결과 해석이 쉽다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				비계층적 군집분석은 알고리즘의 절차가 단순하기때문에 다양한 데이터를 활용하며 계산 효율성이 높아 적용이 용이하고 사전 정보가 없더라도 의미 있는 결과를 얻을 수 있다. 그러나 결과 해석은 데이터의 특성과 클러스터링 목적에 크게 의존하기 때문에 사전에 주어진 목적이 없으면 오히려 결과 해석이 어려울 수 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				비계층적 군집분석은 데이터의 사전 정보 없이도 유의미한 결과를 도출할 수 있는 분석 방법입니다. 이는 데이터의 구조적 정보 없이도 다양한 데이터 형태에 적용 가능하며, 분석 방법의 적용이 용이하다는 장점이 있습니다. <br>
   1. 주어진 데이터의 내부 구조에 대한 사전 정보가 없어도 의미있는 결과를 얻을 수 있다.  <br>
      - 비계층적 군집분석은 데이터의 사전 정보 없이도 클러스터를 형성할 수 있어 유의미한 결과를 도출할 수 있습니다. 이는 비계층적 군집분석의 주요 장점 중 하나입니다.<br>
   2. 다양한 형태의 데이터의 적용이 가능하다.  <br>
      - 비계층적 군집분석은 다양한 형태의 데이터에 적용할 수 있어 유연성이 높습니다. 이는 다양한 데이터 유형에 적합하게 사용할 수 있는 장점입니다.<br>
   3. 분석방법의 적용이 용이하다.  <br>
      - 비계층적 군집분석은 비교적 간단한 알고리즘을 사용하여 분석 방법의 적용이 용이합니다. 이는 사용자가 쉽게 접근할 수 있는 장점입니다.<br>
   4. 사전에 주어진 목적이 없으므로 결과 해석이 쉽다.  <br>
      - 비계층적 군집분석은 사전에 주어진 목적이 없기 때문에 결과 해석이 오히려 어려울 수 있습니다. 이는 해석의 주관성이 개입될 수 있는 단점입니다.<br>
			</div>
			<div class="t2">
									#비계층적 군집분석									# 데이터 구조									# 데이터 적용									# 결과 해석							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6761);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">46.</span>
			<span class="tt1t1">
				K-means 군집분석에 대한 설명으로 틀린 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 원하는 군집의 개수를 초기에 정하고 seed 중심으로 군집을 형성한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			K-means 군집분석은 각 개체를 가장 가까운 seed가 있는 군집으로 분류한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집으로 분류된 개체들의 정보를 활용하여 새로운 seed를 계산하면서 개체의 적용에 따른 seed의 변화를 관찰한다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a46" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a46" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			95%이상의 개체가 seed에 할당 되면 seed의 조정을 멈춘다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				K-means 군집분석에서는 수렴 기준에 도달하거나 군집 중심의 변화가 없을 때까지 반복되며, 특정 비율 이상의 개체가 할당되었다고 조정을 멈추지 않는다. 나머지 선택지는 K-means 군집분석의 원리를 정확히 설명한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				K-means 군집분석은 초기 설정한 군집의 개수에 따라 데이터를 분류하고, 각 개체를 가장 가까운 중심(seed)으로 할당하여 군집을 형성합니다.  <br>
   1. K-means 군집분석은 초기 군집 개수를 설정하고, 초기 중심(seed)을 기반으로 군집을 형성하는 방식이 맞습니다.  <br>
   2. 각 개체를 가장 가까운 중심(seed)으로 할당하는 것은 K-means의 기본 원리입니다.  <br>
   3. 군집으로 분류된 개체들의 정보를 활용하여 새로운 중심을 계산하는 과정은 K-means의 반복적 최적화 과정입니다.  <br>
   4. K-means는 95% 이상의 개체가 할당되었다고 해서 중심(seed)의 조정을 멈추지 않으며, 수렴할 때까지 반복합니다.<br>
			</div>
			<div class="t2">
									#K-means									# 군집분석									# 초기 군집 개수									# 중심(seed)									# 반복적 최적화							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6174);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">47.</span>
			<span class="tt1t1">
				다음 중 혼합분포군집 모형의 특징으로 부적절한 설명은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			각 군집은 특정 확률분포를 따른다고 가정한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집의 특성은 평균과 분산을 통해 정의된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			대규모 데이터에서 계산 비용이 커지며 시간이 소요된다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			군집의 크기가 작을수록 추정의 정도가 쉽다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a47" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a47" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			군집의 크기가 작을수록 추정의 정도가 쉽다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				군집의 크기가 작아질수록 데이터의 분산이 커지거나 샘플 수가 부족해져 추정의 정확도가 낮아질 수 있다. 1번 선택지는 혼합분포군집의 기본 가정을, 2번 선택지는 군집의 정의 방식을, 3번 선택지는 대규모 데이터에서의 계산 비용 문제를 올바르게 설명하고 있다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				혼합분포군집 모형은 데이터가 여러 개의 확률분포로 구성되어 있다고 가정하며, 각 군집의 특성을 평균과 분산으로 정의합니다. 대규모 데이터에서는 계산 비용이 커질 수 있지만, 군집의 크기가 작다고 해서 추정이 쉬워지는 것은 아닙니다. <br>
   <br>
1. 각 군집은 특정 확률분포를 따른다고 가정한다.<br>
: 혼합분포군집은 각 군집이 특정 확률분포(예: 정규분포, 베타분포 등)를 따른다고 가정합니다. 데이터가 여러 분포로 구성되어 있다고 판단될 때 사용되며, 이는 혼합분포군집의 기본 가정입니다.<br>
<br>
2. 군집의 특성은 평균과 분산을 통해 정의된다.<br>
: 각 군집의 분포는 평균과 분산 등의 매개변수로 정의됩니다. 예를 들어, 정규분포 기반의 혼합모형에서는 각 군집이 평균(Mean)과 분산(Variance)으로 표현됩니다.<br>
<br>
3. 대규모 데이터에서 계산 비용이 커지며 시간이 소요된다.<br>
: 혼합분포군집은 데이터가 클수록 매개변수 추정 과정에서 계산 비용이 증가합니다. 특히, EM 알고리즘은 반복적으로 수행되기 때문에 대규모 데이터에서는 시간이 많이 소요됩니다.<br>
<br>
4. 군집의 크기가 작을수록 추정의 정도가 쉽다.<br>
: 군집의 크기가 작아질수록 해당 군집에 포함된 데이터가 적어지므로, 평균, 분산 등의 매개변수를 정확히 추정하기 어려워질 수 있습니다. 군집 크기가 작아도 추정이 쉽다는 설명은 부적절합니다.<br>
			</div>
			<div class="t2">
									#혼합분포군집									# 확률분포									#EM 알고리즘							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6762);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">48.</span>
			<span class="tt1t1">
				다음 중 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬화하여 지도의 형태로 형성화하는 클러스터링 방법으로 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			의사결정나무(Decision Tree)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관규칙(Association Rule)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			랜덤포레스트(Random Forest)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			자기조직화지도(Self-Organizing Map)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a48" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a48" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			자기조직화지도(Self-Organizing Map)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				자기조직화지도(SOM)는 고차원의 데이터를 저차원으로 정렬화하여 시각화할 수 있는 클러스터링 방법이다. 의사결정나무, 연관규칙, 랜덤포레스트는 클러스터링 기법이 아니다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				고차원의 데이터를 저차원으로 변환하여 시각적으로 이해하기 쉽게 만드는 방법은 "자기조직화지도(Self-Organizing Map)"입니다. 이는 고차원 데이터를 저차원 공간에 투영하여 데이터의 패턴을 시각적으로 표현하는 비지도 학습 방법입니다.<br>
   1. 의사결정나무(Decision Tree)는 데이터를 분류하거나 회귀 분석을 수행하는 데 사용되며, 데이터의 차원을 축소하거나 시각화하는 데 적합하지 않습니다. <br>
   2. 연관규칙(Association Rule)은 데이터 간의 연관성을 찾는 데 사용되며, 데이터의 차원을 축소하거나 시각화하는 데 적절하지 않습니다.<br>
   3. 랜덤포레스트(Random Forest)는 여러 개의 의사결정나무를 사용하여 예측 성능을 향상시키는 방법으로, 데이터의 차원 축소나 시각화와는 관련이 없습니다.<br>
   4. 자기조직화지도(Self-Organizing Map)는 고차원 데이터를 저차원으로 변환하여 시각화하는 데 사용되는 클러스터링 방법입니다.<br>
			</div>
			<div class="t2">
									#고차원 데이터									# 저차원 변환									# 자기조직화지도									# 클러스터링									# 시각화							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6763);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">49.</span>
			<span class="tt1t1">
				SOM은 비지도 신경망으로 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도의 형태로 형상화 한다. 다음 중 입력벡터의 특성에 따라 벡터가 한 점으로 클러스터링 되는 층은 어떤 층인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			경쟁층(Competitive layer)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			입력층(Input layer) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			은닉층(Hidden layer) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			출력층(Output layer)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a49" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a49" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			경쟁층(Competitive layer)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				경쟁층은 입력 벡터를 받아 고차원의 데이터를 저차원의 뉴런으로 매핑하여 클러스터링한다. 입력층은 원시 데이터를 받아들이는 층이고, 은닉층은 데이터의 비선형 변환을 담당하며, 출력층은 최종 결과를 출력하는 층이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				정답은 1번입니다.<br>
<br>
SOM(Self-Organizing Map)은 비지도 학습 신경망으로, 입력 벡터의 특성에 따라 데이터를 클러스터링하는 데 사용됩니다. 경쟁층은 입력 벡터가 가장 잘 맞는 뉴런을 선택하여 클러스터링하는 역할을 합니다.<br>
<br>
1. 경쟁층(Competitive layer)<br>
: SOM의 핵심 학습 단계로, 입력벡터와 각 뉴런 간 거리(보통 유클리드 거리)를 계산한 후 가장 가까운 뉴런을 BMU(Best Matching Unit)로 선택합니다. 이 층에서 입력 벡터가 특정 뉴런으로 할당되며, 결과적으로 데이터가 지도 상의 한 점(클러스터)으로 표현됩니다.<br>
<br>
2. 입력층(Input layer)<br>
: 데이터를 신경망에 입력하는 층으로, 이 층에서는 외부 데이터 벡터를 받아 경쟁층으로 전달하는 역할만 수행합니다. 클러스터링과 직접적인 관련은 없습니다.<br>
<br>
3. 은닉층(Hidden layer)<br>
: 은닉층은 주로 다층 퍼셉트론에서 사용되며, SOM은 일반적인 다층 신경망(MLP)과 달리 은닉층이 존재하지 않습니다. SOM에서는 사용되지 않습니다.<br>
<br>
4. 출력층(Output layer)<br>
: SOM에서는 출력층 대신 경쟁층이 곧 결과를 출력하는 역할을 합니다. 즉, 별도의 출력층이 없습니다.<br>
<br>
SOM은 “입력층–경쟁층”의 단순 구조이며, 데이터를 지도 위의 점으로 표현하는 클러스터링은 경쟁층에서 수행됩니다.<br>
<br>
따라서 정답은 '1. 경쟁층(Competitive layer)' 입니다.<br>
			</div>
			<div class="t2">
									#SOM									# 비지도 학습									# 경쟁층									# 클러스터링							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5540);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">50.</span>
			<span class="tt1t1">
				군집분석 기법으로 가장 적절하지 않은 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			K-Means Clustering					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			계층적 군집화 (Hierarchical Clustering)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			Silhouette Coefficient					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			DBSCAN (Density-Based Spatial Clustering of Applications with Noise)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a50" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a50" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			Silhouette Coefficient			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				Silhouette Coefficient는 군집분석 기법이 아닌 군집의 품질을 평가하는 지표로, 데이터 포인트가 특정 군집에 얼마나 잘 속해 있는지를 측정한다. 반면 K-means Clustering, 계층적 군집화, DBSCAN은 실제 군집화를 수행하는 알고리즘이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집분석은 데이터를 그룹으로 나누어 유사한 특성을 가진 데이터끼리 묶는 기법입니다.<br>
 <br>
 1. K-Means Clustering은 데이터를 K개의 군집으로 나누는 비지도 학습의 대표적인 군집화 기법입니다.     <br>
 <br>
 2. 계층적 군집화는 데이터의 계층적 구조를 기반으로 군집을 형성하는 방법으로, 군집 간의 계층적 관계를 파악할 수 있습니다.     <br>
 <br>
 3. Silhouette Coefficient는 군집화의 품질을 평가하는 지표로, 군집분석 기법이 아닙니다. 이는 군집의 응집도와 분리도를 측정하여 군집화의 효율성을 평가하는 데 사용됩니다.     <br>
 <br>
 4. DBSCAN은 밀도 기반 군집화 기법으로, 데이터의 밀도를 기준으로 군집을 형성하며, 노이즈 데이터를 효과적으로 처리할 수 있습니다.<br>
			</div>
			<div class="t2">
									#군집분석									# K-Means									# 계층적 군집화									# DBSCAN									# Silhouette Coefficient							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">군집분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6770);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">51.</span>
			<span class="tt1t1">
				군집 모형 평가 기준 중 하나이며 군집의 밀집정도를 계산하는 방법으로 군집 내의 거리와 군집 간의 거리를 기준으로 군집 분할의 성과를 평가하는 것은 다음 중 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			피어슨 상관 계수(Pearson Correlation Coefficient) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			ARI(Adjusted Rand Index)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			NMI(Normalized Mutual Information) 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			실루엣 계수(Silhouette Coefficient)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a51" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a51" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			실루엣 계수(Silhouette Coefficient)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				실루엣 계수는 군집 내 거리와 군집 간 거리의 비율을 계산하여 군집화의 품질을 평가하는 데 사용된다. 피어슨 상관 계수는 변수 간의 상관성을 측정하고, ARI와 NMI는 군집 결과의 유사성을 평가하는 지표이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				군집 모형 평가 기준 중 군집의 밀집 정도를 계산하는 방법으로 군집 내의 거리와 군집 간의 거리를 기준으로 군집 분할의 성과를 평가하는 것은 "실루엣 계수(Silhouette Coefficient)"입니다. 이는 각 데이터 포인트가 얼마나 잘 군집화되어 있는지를 측정하며, 군집 내의 응집력과 군집 간의 분리를 동시에 고려합니다.<br>
   1. 피어슨 상관 계수(Pearson Correlation Coefficient)는 두 변수 간의 선형 상관 관계를 측정하는 지표로, 군집의 밀집 정도와는 관련이 없습니다. 군집 평가보다는 변수 간의 관계를 분석할 때 사용됩니다.<br>
   2. ARI(Adjusted Rand Index)는 군집화 결과와 실제 레이블 간의 일치도를 평가하는 지표로, 군집의 밀집 정도를 직접적으로 평가하지 않습니다. 주로 군집화의 정확성을 평가하는 데 사용됩니다.<br>
   3. NMI(Normalized Mutual Information)는 군집화 결과와 실제 레이블 간의 정보 공유 정도를 측정하는 지표로, 군집의 밀집 정도와는 관련이 없습니다. 정보 이론적 관점에서 군집화의 질을 평가합니다.<br>
   4. 실루엣 계수(Silhouette Coefficient)는 각 데이터 포인트가 자신이 속한 군집 내에서 얼마나 가까운지를 측정하고, 다른 군집과 얼마나 멀리 떨어져 있는지를 평가합니다. 군집의 응집력과 분리를 동시에 고려하는 지표입니다.<br>
			</div>
			<div class="t2">
									#군집 모형 평가									# 실루엣 계수									# 군집 밀집도									# 거리 기반 평가							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6194);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">52.</span>
			<span class="tt1t1">
				다음 중 연관분석의 특징에 대한 설명으로 가장 적절한 것은?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			거래 데이터의 양에 상관없이 계산 복잡도가 항상 일정하다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			세분화된 품목에 대해 연관 규칙을 찾으려 할 때 적절한 방법이다. 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석은 모든 품목 간의 관계를 자동으로 도출하며, 항상 높은 정확도를 제공한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조건 반응(if-then)으로 표현되는 연관분석의 결과를 이해하기 쉽다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a52" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a52" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			조건 반응(if-then)으로 표현되는 연관분석의 결과를 이해하기 쉽다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				연관분석은 "A가 발생하면 B가 발생한다"와 같은 조건 반응 형태로 결과가 표현되어 해석이 용이하다. 거래 데이터는 양이 많아질수록 계산 복잡도가 증가하며 세분화된 데이터를 다루는 것은 연관분석보다 다른 기법이 적합하다. 또한 연관분석은 모든 관계를 자동으로 도출하는 것이 아니라 지지도와 신뢰도 등의 기준으로 선택된 규칙만을 도출한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관분석의 핵심 개념은 데이터 간의 관계를 도출하여 조건 반응(if-then) 형태로 표현하는 것입니다. 이는 결과를 직관적으로 이해할 수 있게 해줍니다. <br>
<br>
1. 거래 데이터의 양에 상관없이 계산 복잡도가 항상 일정하다.<br>
: 거래 데이터의 양이 증가하면 계산 복잡도도 증가합니다. 특히, 가능한 모든 품목 간의 관계를 탐색해야 하므로 데이터가 많아질수록 연산량이 크게 늘어납니다.<br>
<br>
2. 세분화된 품목에 대해 연관 규칙을 찾으려 할 때 적절한 방법이다.<br>
: 연관분석은 품목 간의 관계를 찾는 데 효과적이지만, 세분화된 품목(예: 특정 브랜드의 특정 모델)에 대해 분석하려 하면 노이즈가 많아지고 유용한 패턴을 도출하기 어려울 수 있습니다.<br>
<br>
3. 연관분석은 모든 품목 간의 관계를 자동으로 도출하며, 항상 높은 정확도를 제공한다.<br>
: 연관분석은 모든 품목 간의 관계를 도출할 수 있지만, 도출된 규칙의 품질은 데이터 특성과 분석 설정(예: 최소 지지도와 신뢰도 임계값)에 따라 달라집니다. 따라서 항상 높은 정확도를 제공한다고 보장할 수 없습니다.<br>
<br>
4. 조건 반응(if-then)으로 표현되는 연관분석의 결과를 이해하기 쉽다.<br>
: 연관분석의 결과는 "if-then" 형태로 표현되며, 예를 들어 "A를 구매한 고객이 B도 구매할 확률이 높다"와 같은 방식으로 직관적으로 해석할 수 있습니다.<br>
			</div>
			<div class="t2">
									#연관분석									# 조건 반응									# if-then 규칙									# 계산 복잡도							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5632);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">53.</span>
			<span class="tt1t1">
				연관규칙의 장점에 대한 설명 중 부적절한 것을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			최소 지지도와 최소 신뢰도를 설정하여 분석한다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			거래 내용에 대한 데이터를 변환 없이 그 자체로 이용할 수 있는 간단한 자료구조를 갖는 분석 방법이다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			조건 반응(if-then) 형태로 표현되어 이해하기 쉽다.					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			품목 수가 증가해도 분석에 필요한 계산이 늘어나지 않는다.					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a53" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a53" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			품목 수가 증가해도 분석에 필요한 계산이 늘어나지 않는다.			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				품목 수가 증가하면 가능한 품목 조합의 수가 급격히 증가하여 계산 복잡도가 늘어난다. 최소 지지도와 신뢰도 설정, 간단한 자료구조, 조건 반응 형태는 연관규칙의 실제 장점을 정확히 설명한다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관규칙 분석은 데이터 마이닝 기법 중 하나로, 데이터 내에서 항목 간의 흥미로운 관계를 찾는 데 사용됩니다. 품목 수가 증가하면 분석에 필요한 계산이 늘어날 수밖에 없으며, 이는 연관규칙의 단점 중 하나입니다.<br>
<br>
1. 최소 지지도와 최소 신뢰도를 설정하여 분석한다.<br>
: 연관규칙 분석은 데이터를 효율적으로 분석하기 위해 최소 지지도(Minimum Support)와 최소 신뢰도(Minimum Confidence)를 설정합니다. 이를 통해 관심 있는 규칙만 추출하여 계산량을 줄이고 의미 있는 규칙을 도출할 수 있습니다. 이는 연관규칙 분석의 핵심 특성이므로 적절한 설명입니다.<br>
<br>
2. 거래 내용에 대한 데이터를 변환 없이 그 자체로 이용할 수 있는 간단한 자료구조를 갖는 분석 방법이다.<br>
: 연관규칙 분석은 거래 데이터를 단순한 이진 형태(예: 특정 품목 구매 여부)로 변환하여 분석합니다. 복잡한 데이터 변환 없이도 규칙을 도출할 수 있어 간단한 자료구조를 사용하는 것이 장점입니다.<br>
<br>
3. 조건 반응(if-then) 형태로 표현되어 이해하기 쉽다.<br>
: 연관규칙 분석 결과는 A→B와 같은 조건 반응(if-then) 형태로 표현되며, 이는 사용자가 쉽게 이해하고 활용할 수 있는 형태입니다. 예를 들어, "우유를 구매한 고객은 빵을 구매할 가능성이 높다"라는 규칙처럼 직관적이고 간단한 해석이 가능합니다.<br>
<br>
4. 품목 수가 증가해도 분석에 필요한 계산이 늘어나지 않는다.<br>
: 연관규칙 분석에서 품목 수가 증가하면 가능한 품목 집합(조합)의 수가 기하급수적으로 늘어나며, 이는 계산량 증가로 이어집니다. 예를 들어, n개의 품목이 있다면 가능한 후보 집합의 수는 <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" tabindex="0" ctxtmenu_counter="36" style="font-size: 113.1%; position: relative;"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45B TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2212"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container>개가 됩니다. 특히 대규모 데이터에서는 Apriori 알고리즘과 같은 기법을 사용해 계산량을 줄이려는 노력이 필요합니다.<br>
			</div>
			<div class="t2">
									#연관규칙 분석									# 최소 지지도									# 최소 신뢰도									# 후보 집합							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6123);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">54.</span>
			<span class="tt1t1">
				아래 거래 데이터를 바탕으로, 지지도가 25% 이상이고 신뢰도가 50% 이상인 연관 규칙을 고르시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=7a45ba91-41cf-8780-98e9-df5dc9ac29d8.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/7a45ba91-41cf-8780-98e9-df5dc9ac29d8.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			A → B 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			A → C					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			C → B					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			C → A					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a54" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a54" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			A → B 			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				지지도(support)와 신뢰도(confidence)는 연관 규칙의 성능을 평가하는 중요한 척도이다. 지지도는 전체 거래에서 특정 항목 집합이 얼마나 자주 함께 나타나는지를 나타낸다. 신뢰도는 특정 항목 집합이 발생했을 때, 다른 항목 집합이 얼마나 자주 함께 발생하는지를 나타냅니다. 각 항목의 지지도와 신뢰도를 계산하면 A → B는 25%, 50%이고 A → C는 20%, 40%이며 C → B는 25%, 약38%, C → A는 20%, 약 31%이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				1. 지지도(Support)<br>
지지도는 특정 항목 집합이 전체 거래에서 발생하는 비율로, 아래와 같은 공식을 따릅니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="37" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">전</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">체</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(X→Y)</mtext><mo>=</mo><mfrac><mrow><mtext>거래 건수(X</mtext><mo>∩</mo><mtext>Y)</mtext></mrow><mtext>전체 거래 건수</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
• 전체 거래 건수 = 10 + 5 + 25 + 5 + 20 + 20 + 15 = 100<br>
<br>
• A→B<br>
A와 B가 동시에 발생한 거래 건수 = 20 + 5 = 25<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="38" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(A→B)</mtext><mo>=</mo><mfrac><mn>25</mn><mn>100</mn></mfrac><mo>=</mo><mn>25</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• A→C<br>
A와 C가 동시에 발생한 거래 건수 = 15 + 5 = 20<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="39" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(A→C)</mtext><mo>=</mo><mfrac><mn>20</mn><mn>100</mn></mfrac><mo>=</mo><mn>20</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• C→B<br>
C와 B가 동시에 발생한 거래 건수 = 20 + 5 = 25<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="40" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(C→B)</mtext><mo>=</mo><mfrac><mn>25</mn><mn>100</mn></mfrac><mo>=</mo><mn>25</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• C→A<br>
C와 A가 동시에 발생한 거래 건수 = 5 + 15 = 20<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="41" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c53"></mjx-c><mjx-c class="mjx-c75"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c70"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c72"></mjx-c><mjx-c class="mjx-c74"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Support(C→A)</mtext><mo>=</mo><mfrac><mn>20</mn><mn>100</mn></mfrac><mo>=</mo><mn>20</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
2. 신뢰도(Confidence)<br>
신뢰도는 X가 발생했을 때 Y가 발생할 확률료, 아래와 같은 공식을 따릅니다.<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="42" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mrow><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2229"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-c59"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mtext class="mjx-n"><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">거</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">래</mjx-utext><mjx-c class="mjx-c20"></mjx-c><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">건</mjx-utext><mjx-utext variant="normal" style="font-size: 88.4%; padding: 0.848em 0px 0.226em; font-family: MJXZERO, serif;">수</mjx-utext><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c58"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence(X→Y)</mtext><mo>=</mo><mfrac><mrow><mtext>거래 건수(X</mtext><mo>∩</mo><mtext>Y)</mtext></mrow><mtext>거래 건수(X)</mtext></mfrac></math></mjx-assistive-mml></mjx-container><br>
<br>
• A→B<br>
A가 발생한 거래 건수 = 10 + 20 + 15 + 5 = 50<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="43" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence(A→B)</mtext><mo>=</mo><mfrac><mn>25</mn><mn>50</mn></mfrac><mo>=</mo><mn>50</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• A→C<br>
A가 발생한 거래 건수 = 10 + 20 + 15 + 5 = 50<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="44" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence(A→C)</mtext><mo>=</mo><mfrac><mn>20</mn><mn>50</mn></mfrac><mo>=</mo><mn>40</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• C→B<br>
C가 발생한 거래 건수 = 25 + 20 + 15 + 5 = 65<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="45" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c42"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c38"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence(C→B)</mtext><mo>=</mo><mfrac><mn>25</mn><mn>65</mn></mfrac><mo>=</mo><mn>38.5</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
• C→A<br>
C가 발생한 거래 건수 = 25 + 5 + 20 + 15 = 65<br>
<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" display="true" tabindex="0" ctxtmenu_counter="46" style="font-size: 113.1%; position: relative;"><mjx-math display="true" class="MJX-TEX" aria-hidden="true" style="margin-left: 0px; margin-right: 0px;"><mjx-mtext class="mjx-n"><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c6F"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c66"></mjx-c><mjx-c class="mjx-c69"></mjx-c><mjx-c class="mjx-c64"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c6E"></mjx-c><mjx-c class="mjx-c63"></mjx-c><mjx-c class="mjx-c65"></mjx-c><mjx-c class="mjx-c28"></mjx-c><mjx-c class="mjx-c43"></mjx-c><mjx-c class="mjx-c2192"></mjx-c><mjx-c class="mjx-c41"></mjx-c><mjx-c class="mjx-c29"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mfrac space="4"><mjx-frac type="d"><mjx-num><mjx-nstrut type="d"></mjx-nstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-num><mjx-dbox><mjx-dtable><mjx-line type="d"></mjx-line><mjx-row><mjx-den><mjx-dstrut type="d"></mjx-dstrut><mjx-mn class="mjx-n"><mjx-c class="mjx-c36"></mjx-c><mjx-c class="mjx-c35"></mjx-c></mjx-mn></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mi class="mjx-n"><mjx-c class="mjx-c25"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Confidence(C→A)</mtext><mo>=</mo><mfrac><mn>20</mn><mn>65</mn></mfrac><mo>=</mo><mn>31</mn><mi mathvariant="normal">%</mi></math></mjx-assistive-mml></mjx-container><br>
<br>
따라서 정답은 '①A→B' 입니다.<br>
			</div>
			<div class="t2">
									#지지도									# 신뢰도									# 연관규칙분석							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5973);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">55.</span>
			<span class="tt1t1">
				연관성 분석에서 특정 규칙의 중요도를 평가하기 위해 사용하는 측도(criterion) 중, 아래 설명에 해당하는 것으로 가장 적절한 것은?					
					<span class="tt1t1">
						데이터 전체에서 항목 A와 항목 B가 동시에 발생하는 빈도를 데이터 전체 건수로 나누어 계산한 값					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			지지도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			신뢰도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			향상도					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			민감도					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a55" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a55" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">1</i>
			<span class="t2t1">
			지지도			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				지지도는 전체 데이터에서 특정 항목 집합이 동시에 발생하는 빈도를 나타내는 값으로, 데이터 전체 건수 대비 발생 빈도로 계산된다. 신뢰도는 조건부 확률을 의미하며, 향상도는 규칙의 유용성을 측정하는 비율이다. 민감도는 주로 분류 문제에서 사용되는 평가 지표이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				연관성 분석(Association Rule Mining)은 데이터 간의 관계를 찾는 기법으로, 특정 규칙이 얼마나 중요한지 평가하기 위해 다양한 측도를 사용합니다. 주요 측도에는 지지도, 신뢰도, 향상도가 포함됩니다.<br>
<br>
1. 지지도<br>
: 지지도는 데이터 전체에서 특정 규칙이 얼마나 자주 발생하는지를 나타냅니다. A와 B가 동시에 발생한 빈도를 데이터 전체 건수로 나누어 계산하며, 규칙의 빈도와 분석의 신뢰성을 측정하는 기본 지표입니다. 보기에서 "항목 A와 항목 B가 동시에 발생하는 빈도를 데이터 전체 건수로 나누어 계산"한다는 설명과 정확히 일치하므로, 정답입니다.<br>
<br>
2. 신뢰도<br>
: 신뢰도는 특정 조건(A)이 발생했을 때 결과(B)가 발생할 확률을 나타냅니다. 이는 A와 B가 동시에 발생한 빈도를 A가 발생한 빈도로 나누어 계산하며, 규칙의 조건부 확률을 평가합니다. 지지도와는 계산 방식과 의미가 다릅니다.<br>
<br>
3. 향상도<br>
: 향상도는 특정 규칙이 실제로 얼마나 의미 있는지를 평가합니다. 이는 A와 B의 독립적인 발생 확률에 비해, A와 B가 동시에 발생할 확률이 얼마나 더 높은지를 나타냅니다. 향상도는 지지도나 신뢰도와는 다른 측도로, 보기의 설명과 관련이 없습니다.<br>
<br>
4. 민감도<br>
: 민감도는 주로 분류 모델에서 사용되며, 실제로 긍정 사건을 정확히 분류한 비율을 나타냅니다. 연관성 분석에서 사용되는 주요 측도가 아니며, 보기와는 관련이 없습니다.<br>
			</div>
			<div class="t2">
									#연관성 분석									# 지지도									# 신뢰도									# 향상도									# 규칙 평가							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5974);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">56.</span>
			<span class="tt1t1">
				아래의 거래 데이터를 바탕으로 연관 규칙 A→B의 향상도를 계산하시오.							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=5a97b9ab-e516-4b00-b836-65e805e48cb5.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/5a97b9ab-e516-4b00-b836-65e805e48cb5.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			33%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			50%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			83%					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			93%					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a56" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a56" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			83%			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				향상도는 특정 항목(A)을 구매했을 때 다른 항목(B)을 구매할 확률이 얼마나 증가했는지를 나타내는 지표이다. 향상도는 P(B|A) / P(B) 로 계산하며 문제에서 P(B|A)는 A를 구매했을 때 B를 구매할 확률, P(B)는 전체 데이터에서 B를 구매할 확률로 나타난다. 따라서 정답은 약 83%가 된다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				향상도(Lift) 공식은 아래와 같습니다.<br>
Lift = P(A ∩ B) ÷ (P(A) × P(B))<br>
• P(A∩B)=(동시 발생 거래 수)÷(전체 거래 수): A와 B가 동시에 발생하는 비율<br>
• P(A)=(A가 포함된 거래 수)÷(전체 거래 수): A가 발생하는 비율<br>
• P(B)=(B가 포함된 거래 수)÷(전체 거래 수): B가 발생하는 비율<br>
<br>
1. 전체 거래 수<br>
전체 거래 수 = 100 + 100+ 100 + 50 + 200 + 250 + 200 = 1000<br>
<br>
2. P(A∩B): A와 B가 동시에 발생하는 거래 수<br>
• A와 B가 동시에 발생하는 거래: {A, B, C, D}, {A, B, D}<br>
• 동시 발생 거래 수 = 50 + 250 = 300<br>
• P(A∩B) = 300 ÷ 1000 = 0.3<br>
<br>
3. P(A): A가 발생하는 거래 수<br>
• A가 포함된 거래: {A}, {A, B, C, D}, {A, B, D}, {A, C}<br>
• A 발생 거래 수 = 100 + 50 + 250 + 200 = 600<br>
• P(A) = 600 ÷ 1000 = 0.6<br>
<br>
4. P(B): B가 발생하는 거래 수<br>
• B가 포함되는 거래: {B, C}, {A, B, C, D}, {B, C}, {A, B, D}<br>
• B 발생 거래 수 = 100 + 50 + 200 + 250 = 700<br>
• P(B) = 600 ÷ 1000 = 0.6<br>
<br>
5. 향상도(Lift)<br>
• Lift = P(A ∩ B) ÷ (P(A) × P(B))<br>
• Lift = 0.3 ÷ (0.6 × 0..6) = 0.3 ÷ 0.36 ≈ 0.83(약 83%)<br>
<br>
따라서 정답은 3. 83% 입니다.<br>
			</div>
			<div class="t2">
									#연관 규칙									# 향상도							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(6140);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">57.</span>
			<span class="tt1t1">
				연관 분석 알고리즘인 Apriori의 분석 순서를 다음과 같이 나타낸다. 이 과정에서 올바른 순서를 순서대로 나열한 것은?					
					<span class="tt1t1">
						가. 빈발 품목 집합을 찾기 위한 최소 지지도를 설정한다.<br>
나. 3개의 품목 집합을 결합하여 최소 지지도를 넘는 집합을 찾는다.<br>
다. 최소 지지도를 초과하는 품목 집합을 반복적으로 찾는다.<br>
라. 각 품목에서 최소 지지도를 초과하는 2개의 품목 집합을 찾는다.<br>
마. 개별 품목 중에서 최소 지지도를 초과하는 모든 품목을 찾는다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			가-나-다-라-마					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가-나-마-다-라					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가-마-다-라-나 					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가-마-나-다-라					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a57" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a57" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			가-마-다-라-나 			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				Apriori 알고리즘의 분석 순서는 (가) 최소 지지도를 설정 → (마) 개별 품목 중 최소 지지도를 초과하는 모든 품목을 찾음 → (다) 최소 지지도를 초과하는 품목 집합을 반복적으로 찾음 → (라) 최소 지지도를 초과하는 2개의 품목 집합을 찾음 → (나) 3개 이상의 품목 집합을 결합하여 최소 지지도를 넘는 집합을 찾음으로 이루어진다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				Apriori 알고리즘은 빈발 항목 집합을 탐색하는 연관 분석 알고리즘입니다. 최소 지지도를 설정한 후, 개별 항목부터 시작해 반복적으로 빈발 집합을 확장하여 연관 규칙을 도출합니다.<br>
<br>
가. 빈발 품목 집합을 찾기 위한 최소 지지도를 설정한다.<br>
: Apriori 알고리즘의 첫 단계는 분석 기준이 되는 최소 지지도를 설정하는 것입니다. 최소 지지도는 빈발 품목 집합을 정의하는 기준이 되며, 이 값을 기반으로 데이터에서 중요하다고 판단되는 품목 집합을 탐색하게 됩니다. 예를 들어, 전체 거래 중 최소 20% 이상의 거래에서 나타나는 품목만을 빈발 품목으로 정의할 수 있습니다.<br>
<br>
마. 개별 품목 중에서 최소 지지도를 초과하는 모든 품목을 찾는다.<br>
: 데이터에서 각 품목의 빈도를 계산하고, 설정된 최소 지지도를 초과하는 품목을 식별하는 과정입니다. 이 과정에서 개별 품목(1-itemset)을 탐색하며, 불필요한 항목(빈도가 낮은 품목)을 제거해 효율성을 높입니다. 예를 들어, "우유", "빵", "계란" 등의 품목 중 최소 지지도를 초과하는 품목만 남깁니다.<br>
<br>
다. 최소 지지도를 초과하는 품목 집합을 반복적으로 찾는다.<br>
: 초기 1-itemset에서 시작해 더 큰 크기의 품목 집합을 생성하며 탐색을 반복합니다. 2-itemset, 3-itemset 등으로 확장되며, 각 단계에서 최소 지지도를 초과하는 품목 집합만 남깁니다. 이 반복 과정을 통해 빈발 품목 집합이 완성됩니다. 예를 들어, "우유-빵"이 최소 지지도를 초과하면 2-itemset으로 포함됩니다.<br>
<br>
라. 각 품목에서 최소 지지도를 초과하는 2개의 품목 집합을 찾는다.<br>
: 두 개의 개별 품목을 결합해 2-itemset을 형성하고, 이 조합이 최소 지지도를 초과하는지 확인합니다. 이를 통해 2-itemset 중에서도 빈발 품목 집합만 남깁니다. 예를 들어, "우유-빵"은 최소 지지도를 만족하지만, "우유-치즈"는 만족하지 못할 수 있습니다.<br>
<br>
나. 3개의 품목 집합을 결합하여 최소 지지도를 넘는 집합을 찾는다.<br>
: 마지막으로, 이전 단계에서 발견된 2-itemset을 기반으로 더 큰 크기의 품목 집합(3-itemset)을 형성합니다. 이후 동일한 방식으로 빈발 품목 집합을 반복적으로 탐색합니다. 이 과정은 설정된 최소 지지도를 초과하는 품목 집합이 더 이상 발견되지 않을 때까지 계속됩니다.<br>
			</div>
			<div class="t2">
									#Apriori 알고리즘									# 최소 지지도									# 빈발 항목 집합							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5986);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">58.</span>
			<span class="tt1t1">
				소매점의 상품 추천 시스템, 물건 배열, 교차판매 등에 활용하기 가장 적합한 데이터 마이닝 기법은 무엇인가?							</span>
		</strong>
		<span class="tt1t1">
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			데이터 분류(Classification)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 예측(Prediction)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			연관분석(Association Analysis)					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			데이터 군집화(Clustering)					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a58" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a58" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">3</i>
			<span class="t2t1">
			연관분석(Association Analysis)			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				연관분석은 항목 간의 관계를 탐색하여 상품 추천, 교차판매 등의 응용 분야에 적합하다. 데이터 분류는 주로 클래스 라벨을 예측하는 데 사용되며, 데이터 예측은 연속형 값을 예측하는 데 적합하다. 군집화는 비슷한 특성을 가진 그룹을 찾아내는 기법으로, 연관분석과는 다르다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				소매점의 상품 추천 시스템, 물건 배열, 교차판매 등에서는 연관성을 찾는 것이 중요합니다. 연관분석은 데이터 간의 관계를 파악하여 어떤 상품들이 함께 구매되는지를 분석하는 데 적합합니다. <br>
   <br>
1. 데이터 분류(Classification)<br>
: 데이터 분류는 사전 정의된 카테고리에 데이터를 할당하는 작업으로, 추천 시스템보다는 특정 범주에 데이터를 분류하는 데 사용됩니다. 이는 상품 추천보다는 고객 세그먼트 분류에 더 적합합니다.<br>
   <br>
2. 데이터 예측(Prediction)<br>
: 데이터 예측은 미래의 값을 예측하는 데 사용되며, 주로 시간에 따른 변화나 트렌드를 예측하는 데 사용됩니다. 이는 특정 상품의 판매량 예측에는 유용하지만, 상품 간의 연관성을 찾는 데는 적합하지 않습니다.<br>
   <br>
3. 연관분석(Association Analysis)<br>
: 연관분석은 데이터 간의 관계를 파악하여 어떤 상품들이 함께 구매되는지를 분석하는 데 적합합니다. 이는 소매점의 상품 추천 시스템과 교차판매 전략에 매우 유용합니다.<br>
   <br>
4. 데이터 군집화(Clustering)<br>
: 데이터 군집화는 유사한 특성을 가진 데이터를 그룹화하는 데 사용되며, 고객 세분화 등에 유용합니다. 이는 상품 추천보다는 고객 그룹을 정의하는 데 더 적합합니다.<br>
			</div>
			<div class="t2">
									#연관분석									# 상품 추천									# 교차판매									# 데이터 마이닝							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->
<!-- cp1question1 -->
<div class="cp1question1">
	<div class="sg1">
		<div class="w1">
			<span class="g1">3과목</span>
			<span class="g1">연관분석</span>
			<b class="st1 s2">오답</b> <!-- 정답 s1 | 오답 s2 -->
		</div>
		<div class="w2">
			<button type="button" class="b1 button type0 m-cunning " onclick="bookmark(5800);" title="컨닝페이퍼에 추가"><i class="ic1"></i><span class="t1 blind">북마크</span></button>
		</div>
	</div>
	<div class="tg1">
		<strong class="tt1">
			<span class="tt1n">59.</span>
			<span class="tt1t1">
				다음은 Groceries 데이터셋에 대한 연관 규칙을 분석한 결과이다. 옳은 설명을 모두 고르시오.					
					<span class="tt1t1">
						가. {citrus fruit, other vegetables} =&gt; {root vegetables} 규칙의 지지도는 0.01037112이며, 이는 전체 트랜잭션 중 약 1.04%에서 이 규칙이 발생함을 의미한다.<br>
<br>
나. {whole milk, curd} =&gt; {yogurt} 규칙의 신뢰도는 0.385214이며, 이는 whole milk와 curd를 동시에 구매한 고객 중 약 38.52%가 yogurt도 구매했음을 의미한다.<br>
<br>
다. {beef} =&gt; {root vegetables} 규칙의 향상도는 3.140367로, 이는 root vegetables 구매 확률이 beef를 구매했을 때 약 3.14배 증가함을 의미한다.<br>
<br>
라. {citrus fruit,root vegetables} =&gt; {other vegetables} 규칙은 신뢰도가 가장 높은 규칙이다.					</span>
							</span>
		</strong>
		<span class="tt1t1">
						<a href="exam1view1img1.php?img=64d52f5c-6c71-c4cc-d3a4-15824875f2ef.png" target="_blank" rel="noopener" title="새 창" class="p1">
				<img src="/data/img/question/64d52f5c-6c71-c4cc-d3a4-15824875f2ef.png" alt="문제에 포함된 이미지">
			</a>
				    </span>
	</div>
	<ol class="lst1">
				<li class="li1"><a class="a1"><span class="t1">
			가, 다					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			나, 라					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			나, 다, 라					</span></a></li>
		<li class="li1"><a class="a1"><span class="t1">
			가, 나, 라					</span></a></li>
					</ol>
	<div class="eg1">
		<a href="#m-help1a59" class="b2 help on" title="해설 여닫기"> <!-- m-help1a1, m-help1a2, … -->
			<span class="t1">정답보기</span>
			<i class="ic1"></i>
		</a>
	</div>
	<div class="tg2 loaded" id="m-help1a59" style=""> <!-- m-help1a1, m-help1a2, … -->
		<strong class="tt1">정답</strong>
		<div class="t2">
						<i class="t2n">4</i>
			<span class="t2t1">
			가, 나, 라			</span>
								</div>
				<strong class="tt1">해설</strong>
		<div class="t1">
				가는 {citrus fruit, other vegetables} =&gt; {root vegetables} 규칙의 지지도가 0.01037112로 전체 트랜잭션 중 약 1.04%에 해당하여 옳다. 나는 {whole milk, curd} =&gt; {yogurt} 규칙의 신뢰도가 0.385214로, 이 규칙을 따르는 고객 중 38.52%가 yogurt를 구매했음을 나타내 정확하다. 라는 {citrus fruit, root vegetables} =&gt; {other vegetables} 규칙이 신뢰도 0.5862069로 가장 높은 신뢰도를 가지고 있으므로 옳다. 다는 {beef} =&gt; {root vegetables} 규칙의 향상도가 3.140367가 아니므로 틀린 설명이다.				</div>
				<!-- 비기봇 해설 -->
				<a class="more">
			<span class="more-t1">
				<i>비</i><i>기</i><i>봇</i><i>에</i><i>게</i><i>&nbsp;</i><i>문</i><i>의</i><i>중</i><i>…</i>
			</span>
			<i class="more-ic1"></i>
		</a>
		<div class="more-c">
			<strong class="tt1">비기봇 해설</strong>
			<div class="t1">
				가. {citrus fruit, other vegetables} =&gt; {root vegetables} 규칙의 지지도는 0.01037112이며, 이는 전체 트랜잭션 중 약 1.04%에서 이 규칙이 발생함을 의미한다.<br>
: 결과에서 해당 규칙의 지지도(Support)는 0.01037112로 나타나 있습니다. 지지도는 전체 트랜잭션 수(9835) 중 이 규칙이 발생한 비율을 의미합니다. 비율을 계산해보면, 0.01037112 × 100 ≈ 1.04%가 됩니다. 이는 전체 트랜잭션 중 약 1.04%에서 해당 규칙이 발생했음을 나타냅니다.<br>
<br>
나. {whole milk, curd} =&gt; {yogurt} 규칙의 신뢰도는 0.385214이며, 이는 whole milk와 curd를 동시에 구매한 고객 중 약 38.52%가 yogurt도 구매했음을 의미한다.<br>
: 결과에서 해당 규칙의 신뢰도(Confidence)는 0.385214로 주어져 있습니다. 신뢰도는 선행 항목(LHS)이 포함된 트랜잭션 중 후행 항목(RHS)이 포함된 비율을 의미합니다. 즉, whole milk와 curd를 동시에 구매한 트랜잭션 중 약 38.52%에서 yogurt가 구매되었음을 나타냅니다.<br>
<br>
다. {beef} =&gt; {root vegetables} 규칙의 향상도는 3.140367로, 이는 root vegetables 구매 확률이 beef를 구매했을 때 약 3.14배 증가함을 의미한다.<br>
: 결과에서 해당 규칙의 향상도(Lift)는 3.04로 나타나 있습니다. 향상도는 후행 항목(RHS)이 독립적으로 발생할 확률에 비해 선행 항목(LHS)과 함께 발생할 확률이 얼마나 증가하는지를 나타내며, 이 값이 3.04라는 것은 root vegetables를 구매할 확률이 beef를 구매한 경우 약 3.04배 증가한다는 의미입니다. 이 보기는 적절하지 않습니다.<br>
<br>
라. {citrus fruit, root vegetables} =&gt; {other vegetables} 규칙은 신뢰도가 가장 높은 규칙이다.<br>
: {citrus fruit, root vegetables} =&gt; {other vegetables} 규칙의 신뢰도는 0.5862069로, 다른 모든 규칙 중 가장 높은 값을 가집니다. 이는 citrus fruit과 root vegetables를 구매한 고객 중 약 58.62%가 other vegetables를 함께 구매했음을 의미합니다.<br>
			</div>
			<div class="t2">
									#지지도									# 신뢰도									# 향상도									# 연관성 해석							</div>
		</div>
				<!-- /비기봇 해설 -->
	</div>
</div>
<!-- /cp1question1 -->


</div>


<script>/*<![CDATA[*/
	$('.w1').remove();
	$('.w2').remove();
	$(".tg2").hide()
	
	// 정답보기 토글. 20240702. @m.	
	$('.b2.help').parent().next('.tg2').hide(); // 정답, 해설 모두 감춤
	$('.b2.help').on('click', function(e){
		e.preventDefault();
		$(this).closest('.eg1').next('.tg2').toggle();
	});	
/*]]>*/


</script>

</body>

</html>
